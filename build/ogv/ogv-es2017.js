(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["ogvjs"] = factory();
	else
		root["ogvjs"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/js/ogv.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nmodule.exports = _interopRequireDefault;\n\n//# sourceURL=webpack://ogvjs/./node_modules/@babel/runtime/helpers/interopRequireDefault.js?");

/***/ }),

/***/ "./node_modules/audio-feeder/dist/AudioFeeder.js":
/*!*******************************************************!*\
  !*** ./node_modules/audio-feeder/dist/AudioFeeder.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t(function() {\n\n\t\tvar BufferQueue = __webpack_require__(1),\n\t\t\tWebAudioBackend = __webpack_require__(2),\n\t\t\tFlashBackend = __webpack_require__(4),\n\t\t\tAudioTempoChanger = __webpack_require__(6);\n\n\n\t\t/**\n\t\t * Audio sample buffer format passed to {@link AudioFeeder#bufferData} and its backends.\n\t\t *\n\t\t * Buffers are arrays containing one Float32Array of sample data\n\t\t * per channel. Channel counts must match the expected value, and\n\t\t * all channels within a buffer must have the same length in samples.\n\t\t *\n\t\t * Since input data may be stored for a while before being taken\n\t\t * back out, be sure that your Float32Arrays for channel data are\n\t\t * standalone, not backed on an ArrayBuffer that might change!\n\t\t *\n\t\t * @typedef {SampleBuffer} SampleBuffer\n\t\t * @todo consider replacing this with AudioBuffer-like wrapper object\n\t\t */\n\n\t\t/**\n\t\t * Object dictionary format used to pass options into {@link AudioFeeder} and its backends.\n\t\t *\n\t\t * @typedef {Object} AudioFeederOptions\n\t\t * @property {string} base - (optional) base URL to find additional resources in,\n\t\t *                           such as the Flash audio output shim\n\t\t * @property {AudioContext} audioContext - (optional) Web Audio API AudioContext\n\t\t *                          instance to use inplace of creating a default one\n\t\t */\n\n\t\t/**\n\t\t * Object dictionary format returned from {@link AudioFeeder#getPlaybackState} and friends.\n\t\t *\n\t\t * @typedef {Object} PlaybackState\n\t\t * @property {number} playbackPosition - total seconds so far of input audio data that have played (pre tempo change)\n\t\t * @property {number} outputPlaybackPosition - total seconds so far of audio that has been played (post tempo change)\n\t\t * @property {number} samplesQueued - number of samples at target rate that are queued up for playback\n\t\t * @property {number} dropped - number of underrun events, when we had to play silence due to data starvation\n\t\t * @property {number} delayedTime - total seconds so far of silent time during playback due to data starvation\n\t\t * @todo drop 'dropped' in favor of delayedTime\n\t\t * @todo replace sampledQueued with a time unit?\n\t\t */\n\n\t\t/**\n\t\t * Object that we can throw audio data into and have it drain out.\n\t\t * @class\n\t\t * @param {AudioFeederOptions} options - dictionary of config settings\n\t\t *\n\t\t * @classdesc\n\t\t * Object that we can throw audio data into and have it drain out.\n\t\t */\n\t\tfunction AudioFeeder(options) {\n\t\t\tthis._options = options || {};\n\t\t\tthis._backend = null; // AudioBackend instance, after init...\n\t\t\tthis._resampleFractional = 0;\n\t\t\tthis._resampleLastSampleData = undefined;\n\t\t\tthis._tempoChanger = null; // Initialized at init\n\t\t};\n\n\t\t/**\n\t\t * Sample rate in Hz, as requested by the caller in {@link AudioFeeder#init}.\n\t\t *\n\t\t * If the backend's actual sample rate differs from this requested rate,\n\t\t * input data will be resampled automatically.\n\t\t *\n\t\t * @type {number}\n\t\t * @readonly\n\t\t * @see AudioFeeder#targetRate\n\t\t */\n\t\tAudioFeeder.prototype.rate = 0;\n\n\t\t/**\n\t\t * Actual output sample rate in Hz, as provided by the backend.\n\t\t * This may differ from the rate requested, in which case input data\n\t\t * will be resampled automatically.\n\t\t *\n\t\t * @type {number}\n\t\t * @readonly\n\t\t * @see AudioFeeder#rate\n\t\t */\n\t\tAudioFeeder.prototype.targetRate = 0;\n\n\t\t/**\n\t\t * Number of output channels, as requested by the caller in {@link AudioFeeder#init}.\n\t\t *\n\t\t * If the backend's actual channel count differs from this requested count,\n\t\t * input data will be resampled automatically.\n\t\t *\n\t\t * Warning: currently more than 2 channels may result in additional channels\n\t\t * being cropped out, as downmixing has not yet been implemented.\n\t\t *\n\t\t * @type {number}\n\t\t * @readonly\n\t\t */\n\t\tAudioFeeder.prototype.channels = 0;\n\n\t\t/**\n\t\t * Size of output buffers in samples, as a hint for latency/scheduling\n\t\t * @type {number}\n\t\t * @readonly\n\t\t */\n\t\tAudioFeeder.prototype.bufferSize = 0;\n\n\t\t/**\n\t\t * Duration of the minimum buffer size, in seconds.\n\t\t * If the amount of buffered data falls below this,\n\t\t * caller will receive a synchronous 'starved' event\n\t\t * with a last chance to buffer more data.\n\t\t *\n\t\t * @type {number}\n\t\t * @readonly\n\t\t */\n\t\tObject.defineProperty(AudioFeeder.prototype, 'bufferDuration', {\n\t\t\tget: function getBufferDuration() {\n\t\t\t\tif (this.targetRate) {\n\t\t\t\t\treturn this.bufferSize / this.targetRate;\n\t\t\t\t} else {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t/**\n\t\t * Duration of remaining data at which a 'bufferlow' event will be\n\t\t * triggered, in seconds.\n\t\t *\n\t\t * This defaults to twice bufferDuration, but can be overridden.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tObject.defineProperty(AudioFeeder.prototype, 'bufferThreshold', {\n\t\t\tget: function getBufferThreshold() {\n\t\t\t\tif (this._backend) {\n\t\t\t\t\treturn this._backend.bufferThreshold / this.targetRate;\n\t\t\t\t} else {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t},\n\t\t\tset: function setBufferThreshold(val) {\n\t\t\t\tif (this._backend) {\n\t\t\t\t\tthis._backend.bufferThreshold = Math.round(val * this.targetRate);\n\t\t\t\t} else {\n\t\t\t\t\tthrow 'Invalid state: AudioFeeder cannot set bufferThreshold before init';\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\n\t\t/**\n\t\t * Current playback position, in seconds, in input time (i.e. pre tempo change)\n\t\t * This compensates for drops and underruns, and is suitable for a/v sync.\n\t\t *\n\t\t * @type {number}\n\t\t * @readonly\n\t\t */\n\t\tObject.defineProperty(AudioFeeder.prototype, 'playbackPosition', {\n\t\t\tget: function getPlaybackPosition() {\n\t\t\t\tif (this._backend) {\n\t\t\t\t\tvar playbackState = this.getPlaybackState();\n\t\t\t\t\treturn playbackState.playbackPosition;\n\t\t\t\t} else {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t/**\n\t\t * Current playback position, in seconds, in output time (i.e. post tempo change)\n\t\t * Also compensates for drops and underruns, and is suitable for a/v sync.\n\t\t *\n\t\t * @type {number}\n\t\t * @readonly\n\t\t */\n\t\tObject.defineProperty(AudioFeeder.prototype, 'outputPlaybackPosition', {\n\t\t\tget: function getOutputPlaybackPosition() {\n\t\t\t\tif (this._backend) {\n\t\t\t\t\tvar playbackState = this.getPlaybackState();\n\t\t\t\t\treturn playbackState.outputPlaybackPosition;\n\t\t\t\t} else {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t/**\n\t\t * Duration of remaining queued data, in seconds.\n\t\t *\n\t\t * @type {number}\n\t\t */\n\t\tObject.defineProperty(AudioFeeder.prototype, 'durationBuffered', {\n\t\t\tget: function getDurationBuffered() {\n\t\t\t\tif (this._backend) {\n\t\t\t\t\tvar playbackState = this.getPlaybackState();\n\t\t\t\t\treturn playbackState.samplesQueued / this.targetRate;\n\t\t\t\t} else {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t/**\n\t\t * Is the feeder currently set to mute output?\n\t\t * When muted, this overrides the volume property.\n\t\t *\n\t\t * @type {boolean}\n\t\t */\n\t\tObject.defineProperty(AudioFeeder.prototype, 'muted', {\n\t \t\tget: function getMuted() {\n\t\t\t\tif (this._backend) {\n\t\t\t\t\treturn this._backend.muted;\n\t\t\t\t} else {\n\t\t\t\t\tthrow 'Invalid state: cannot get mute before init';\n\t\t\t\t}\n\t \t\t},\n\t \t\tset: function setMuted(val) {\n\t\t\t\tif (this._backend) {\n\t\t\t\t\tthis._backend.muted = val;\n\t\t\t\t} else {\n\t\t\t\t\tthrow 'Invalid state: cannot set mute before init';\n\t\t\t\t}\n\t \t\t}\n\t \t});\n\n\t\t/**\n\t\t * @deprecated in favor of muted and volume properties\n\t\t */\n\t\tAudioFeeder.prototype.mute = function() {\n\t\t\tthis.muted = true;\n\t\t};\n\n\t\t/**\n\t\t* @deprecated in favor of muted and volume properties\n\t\t */\n\t\tAudioFeeder.prototype.unmute = function() {\n\t\t\tthis.muted = false;\n\t\t};\n\n\t\t/**\n\t\t * Volume multiplier, defaults to 1.0.\n\t\t * @name volume\n\t\t * @type {number}\n\t\t */\n\t\tObject.defineProperty(AudioFeeder.prototype, 'volume', {\n\t\t\tget: function getVolume() {\n\t\t\t\tif (this._backend) {\n\t\t\t\t\treturn this._backend.volume;\n\t\t\t\t} else {\n\t\t\t\t\tthrow 'Invalid state: cannot get volume before init';\n\t\t\t\t}\n\t\t\t},\n\t\t\tset: function setVolume(val) {\n\t\t\t\tif (this._backend) {\n\t\t\t\t\tthis._backend.volume = val;\n\t\t\t\t} else {\n\t\t\t\t\tthrow 'Invalid state: cannot set volume before init';\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t/**\n\t\t * Tempo multiplier, defaults to 1.0.\n\t\t * @name volume\n\t\t * @type {number}\n\t\t */\n\t\tObject.defineProperty(AudioFeeder.prototype, 'tempo', {\n\t\t\tget: function getTempo() {\n\t\t\t\tif (this._tempoChanger) {\n\t\t\t\t\treturn this._tempoChanger.getTempo();\n\t\t\t\t} else {\n\t\t\t\t\tthrow 'Invalid state: cannot get tempo before init';\n\t\t\t\t}\n\t\t\t},\n\t\t\tset: function setTempo(val) {\n\t\t\t\tif (this._tempoChanger) {\n\t\t\t\t\tthis._tempoChanger.setTempo(val);\n\t\t\t\t} else {\n\t\t\t\t\tthrow 'Invalid state: cannot set tempo before init';\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\n\t\t/**\n\t\t * Start setting up for output with the given channel count and sample rate.\n\t\t * Audio data you provide will be resampled if necessary to whatever the\n\t\t * backend actually supports.\n\t\t *\n\t\t * @param {number} numChannels - requested number of channels (output may differ)\n\t\t * @param {number} sampleRate - requested sample rate in Hz (output may differ)\n\t\t *\n\t\t * @todo merge into constructor?\n\t\t */\n\t\tAudioFeeder.prototype.init = function(numChannels, sampleRate) {\n\t\t\tthis.channels = numChannels;\n\t\t\tthis.rate = sampleRate;\n\n\t\t\tif (WebAudioBackend.isSupported()) {\n\t\t\t\tthis._backend = new WebAudioBackend(numChannels, sampleRate, this._options);\n\t\t\t} else if (FlashBackend.isSupported()) {\n\t\t\t\tthis._backend = new FlashBackend(numChannels, sampleRate, this._options);\n\t\t\t} else {\n\t\t\t\tthrow 'No supported backend';\n\t\t\t}\n\n\t\t\tthis.targetRate = this._backend.rate;\n\t\t\tthis.bufferSize = this._backend.bufferSize;\n\n\t\t\t// Initialize tempo changer (NB! no \"new\")\n\t\t\tthis._tempoChanger = AudioTempoChanger({ sampleRate: this.targetRate, numChannels: numChannels, tempo: 1.0 });\n\n\t\t\t// Pass through the starved event\n\t\t\tthis._backend.onstarved = (function() {\n\t\t\t\tif (this.onstarved) {\n\t\t\t\t\tthis.onstarved();\n\t\t\t\t}\n\t\t\t}).bind(this);\n\t\t\tthis._backend.onbufferlow = (function() {\n\t\t\t\tif (this.onbufferlow) {\n\t\t\t\t\tthis.onbufferlow();\n\t\t\t\t}\n\t\t\t}).bind(this);\n\t\t};\n\n\t\t/**\n\t\t * Resample a buffer from the input rate/channel count to the output.\n\t\t *\n\t\t * This is horribly naive and wrong.\n\t\t * Replace me with a better algo!\n\t\t *\n\t\t * @param {SampleBuffer} sampleData - input data in requested sample rate / channel count\n\t\t * @returns {SampleBuffer} output data in backend's sample rate/channel count\n\t\t */\n\t\tAudioFeeder.prototype._resample = function(sampleData) {\n\t\t\tvar rate = this.rate,\n\t\t\t\tchannels = this.channels,\n\t\t\t\ttargetRate = this._backend.rate,\n\t\t\t\ttargetChannels = this._backend.channels;\n\n\t\t\tif (rate == targetRate && channels == targetChannels) {\n\t\t\t\treturn sampleData;\n\t\t\t} else {\n\t\t\t\tvar newSamples = [];\n\n\t\t\t\t// Mind that packet boundaries won't always align on\n\t\t\t\t// sample boundaries in the resamples output, so maintain\n\t\t\t\t// a running rounding fractional offset of the portion of\n\t\t\t\t// a sample we'll have to pull from the previous run on\n\t\t\t\t// the next one.\n\t\t\t\tvar inputLen = sampleData[0].length,\n\t\t\t\t\tpreviousFractional = this._resampleFractional,\n\t\t\t\t\toutputLen = inputLen * targetRate / rate + previousFractional,\n\t\t\t\t\toutputSamples = Math.floor(outputLen),\n\t\t\t\t\tremainingFractional = (outputLen - outputSamples);\n\n\t\t\t\tvar interpolate;\n\t\t\t\tif (rate < targetRate) {\n\t\t\t\t\t// Input rate is lower than the target rate,\n\t\t\t\t\t// use linear interpolation to minimize \"tinny\" artifacts.\n\t\t\t\t\tinterpolate = function(input, output, previous, adjustment) {\n\t\t\t\t\t\tvar inputSample = function(i) {\n\t\t\t\t\t\t\tif (i < 0) {\n\t\t\t\t\t\t\t\tif (previous && previous.length + i > 0) {\n\t\t\t\t\t\t\t\t\t// Beware sometimes we have empty bits at start.\n\t\t\t\t\t\t\t\t\treturn previous[previous.length + i];\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// this probably shouldn't happen\n\t\t\t\t\t\t\t\t\t// but if it does be safe ;)\n\t\t\t\t\t\t\t\t\treturn input[0];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn input[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tfor (var i = 0; i < output.length; i++) {\n\t\t\t\t\t\t\t// Map the output sample to input space,\n\t\t\t\t\t\t\t// offset by one to give us room to interpolate.\n\t\t\t\t\t\t\tvar j = ((i + 1 - previousFractional) * rate / targetRate) - 1;\n\t\t\t\t\t\t\tvar a = Math.floor(j);\n\t\t\t\t\t\t\tvar b = Math.ceil(j);\n\n\t\t\t\t\t\t\tvar out;\n\t\t\t\t\t\t\tif (a == b) {\n\t\t\t\t\t\t\t\tout = inputSample(a);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tout = inputSample(a) * (b - j) +\n\t\t\t\t\t\t\t\t      inputSample(b) * (j - a);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\toutput[i] = adjustment * out;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\t// Input rate is higher than the target rate.\n\t\t\t\t\t// For now, discard extra samples.\n\t\t\t\t\tinterpolate = function(input, output, previous, adjustment) {\n\t\t\t\t\t\tfor (var i = 0; i < output.length; i++) {\n\t\t\t\t\t\t\toutput[i] = adjustment * input[(i * input.length / output.length) | 0];\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tvar adjustment = 1;\n\t\t\t\tif (targetChannels > channels) {\n\t\t\t\t\t// assume mono -> stereo conversion\n\t\t\t\t\t// tone down the loudness rather than duplicating to both channels\n\t\t\t\t\tadjustment = Math.SQRT1_2;\n\t\t\t\t}\n\n\t\t\t\tfor (var channel = 0; channel < targetChannels; channel++) {\n\t\t\t\t\tvar inputChannel = channel;\n\t\t\t\t\tif (channel >= channels) {\n\t\t\t\t\t\t// Flash forces output to stereo; if input is mono, dupe the first channel\n\t\t\t\t\t\tinputChannel = 0;\n\t\t\t\t\t}\n\t\t\t\t\tvar input = sampleData[inputChannel],\n\t\t\t\t\t\toutput = new Float32Array(outputSamples),\n\t\t\t\t\t\tprevious = this._resampleLastSampleData ? this._resampleLastSampleData[inputChannel] : undefined;\n\n\t\t\t\t\tinterpolate(input, output, previous, adjustment);\n\n\t\t\t\t\tnewSamples.push(output);\n\t\t\t\t}\n\t\t\t\tthis._resampleFractional = remainingFractional;\n\t\t\t\tthis._resampleLastSampleData = sampleData;\n\t\t\t\treturn newSamples;\n\t\t\t}\n\t\t};\n\n\n\t\t/**\n\t\t * Queue up some audio data for playback.\n\t\t *\n\t\t * @param {SampleBuffer} sampleData - input data to queue up for playback\n\t\t *\n\t\t * @todo throw if data invalid or uneven\n\t\t */\n\t\tAudioFeeder.prototype.bufferData = function(sampleData) {\n\t\t\tif (this._backend) {\n\t\t\t\tvar samples = this._resample(sampleData);\n\n\t\t\t\t// NB! it is important all samples go through tempoChanger\n\t\t\t\t//  it is built to switch to just copying if tempo = 1.0\n\t\t\t\t//  but it still needs the samples to transition smoothly\n\t\t\t\t//  and keep an accurate time map\n\t\t\t\tsamples = this._tempoChanger.process(samples);\n\n\t\t\t\tthis._backend.appendBuffer(samples);\n\t\t\t} else {\n\t\t\t\tthrow 'Invalid state: AudioFeeder cannot bufferData before init';\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Get an object with information about the current playback state.\n\t\t *\n\t\t * @return {PlaybackState} - info about current playback state\n\t\t */\n\t\tAudioFeeder.prototype.getPlaybackState = function() {\n\t\t\tif (this._backend) {\n\t\t\t\tvar state = this._backend.getPlaybackState();\n\t\t\t\tstate.outputPlaybackPosition = state.playbackPosition; // as _backend works only in output time\n\t\t\t\tstate.playbackPosition = this._tempoChanger.mapOutputToInputTime(state.outputPlaybackPosition);\n\t\t\t\treturn state;\n\t\t\t} else {\n\t\t\t\tthrow 'Invalid state: AudioFeeder cannot getPlaybackState before init';\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Checks if audio system is ready and calls the callback when ready\n\t\t * to begin playback.\n\t\t *\n\t\t * This will wait for the Flash shim to load on IE 10/11; waiting\n\t\t * is not required when using native Web Audio but you should use\n\t\t * this callback to support older browsers.\n\t\t *\n\t\t * @param {function} callback - called when ready\n\t\t */\n\t\tAudioFeeder.prototype.waitUntilReady = function(callback) {\n\t\t\tif (this._backend) {\n\t\t\t\tthis._backend.waitUntilReady(callback);\n\t\t\t} else {\n\t\t\t\tthrow 'Invalid state: AudioFeeder cannot waitUntilReady before init';\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Start/continue playback as soon as possible.\n\t\t *\n\t\t * You should buffer some audio ahead of time to avoid immediately\n\t\t * running into starvation.\n\t\t */\n\t\tAudioFeeder.prototype.start = function() {\n\t\t\tif (this._backend) {\n\t\t\t\tthis._backend.start();\n\t\t\t} else {\n\t\t\t\tthrow 'Invalid state: AudioFeeder cannot start before init';\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Stop/pause playback as soon as possible.\n\t\t *\n\t\t * Audio that has been buffered but not yet sent to the device will\n\t\t * remain buffered, and can be continued with another call to start().\n\t\t */\n\t\tAudioFeeder.prototype.stop = function() {\n\t\t\tif (this._backend) {\n\t\t\t\tthis._backend.stop();\n\t\t\t} else {\n\t\t\t\tthrow 'Invalid state: AudioFeeder cannot stop before init';\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Flush any queued data out of the system.\n\t\t */\n\t\tAudioFeeder.prototype.flush = function() {\n\t\t\tthis._resampleFractional = 0;\n\t\t\tthis._resampleLastSampleData = undefined;\n\t\t\tif (this._backend) {\n\t\t\t\tthis._tempoChanger.flush(this.durationBuffered);\n\t\t\t\tthis._backend.flush();\n\t\t\t} else {\n\t\t\t\tthrow 'Invalid state: AudioFeeder cannot flush before init';\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Close out the audio channel. The AudioFeeder instance will no\n\t\t * longer be usable after closing.\n\t\t *\n\t\t * @todo close out the AudioContext if no longer needed\n\t\t * @todo make the instance respond more consistently once closed\n\t\t */\n\t\tAudioFeeder.prototype.close = function() {\n\t\t\tif (this._backend) {\n\t\t\t\tthis._backend.close();\n\t\t\t\tthis._backend = null;\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Synchronous callback when we find we're out of buffered data.\n\t\t *\n\t\t * @type {function}\n\t\t */\n\t\tAudioFeeder.prototype.onstarved = null;\n\n\t\t/**\n\t\t * Asynchronous callback when we're running low on buffered data.\n\t\t *\n\t\t * @type {function}\n\t\t */\n\t\tAudioFeeder.prototype.onbufferlow = null;\n\n\t\t/**\n\t\t * Is the AudioFeeder class supported in this browser?\n\t\t *\n\t\t * Note that it's still possible to be supported but not work, for instance\n\t\t * if there are no audio output devices but the APIs are available.\n\t\t *\n\t\t * @returns {boolean} - true if Web Audio API is available\n\t\t */\n\t\tAudioFeeder.isSupported = function() {\n\t\t\treturn !!Float32Array && (WebAudioBackend.isSupported() || FlashBackend.isSupported());\n\t\t};\n\n\t\t/**\n\t\t * Force initialization of the default Web Audio API context, if applicable.\n\t\t *\n\t\t * Some browsers (such as mobile Safari) disable audio output unless\n\t\t * first triggered from a UI event handler; call this method as a hint\n\t\t * that you will be starting up an AudioFeeder soon but won't have data\n\t\t * for it until a later callback.\n\t\t *\n\t\t * @returns {AudioContext|null} - initialized AudioContext instance, if applicable\n\t\t */\n\t\tAudioFeeder.initSharedAudioContext = function() {\n\t\t\tif (WebAudioBackend.isSupported()) {\n\t\t\t\treturn WebAudioBackend.initSharedAudioContext();\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\n\t\tmodule.exports = AudioFeeder;\n\n\t})();\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * @file Abstraction around a queue of audio buffers.\n\t *\n\t * @author Brion Vibber <brion@pobox.com>\n\t * @copyright (c) 2013-2016 Brion Vibber\n\t * @license MIT\n\t */\n\n\t/**\n\t * Constructor for BufferQueue class.\n\t * @class\n\t * @param {number} numChannels - channel count to validate against\n\t * @param {number} bufferSize - desired size of pre-chunked output buffers, in samples\n\t *\n\t * @classdesc\n\t * Abstraction around a queue of audio buffers.\n\t *\n\t * Stuff input buffers of any length in via {@link BufferQueue#appendBuffer},\n\t * check how much is queued with {@link BufferQueue#sampleCount}, and pull out\n\t * data in fixed-size chunks from the start with {@link BufferQueue#shift}.\n\t */\n\tfunction BufferQueue(numChannels, bufferSize) {\n\t  if (numChannels < 1 || numChannels !== Math.round(numChannels)) {\n\t    throw 'Invalid channel count for BufferQueue';\n\t  }\n\t  this.channels = numChannels;\n\t  this.bufferSize = bufferSize;\n\t  this.flush();\n\t}\n\n\t/**\n\t * Flush any data out of the queue, resetting to empty state.\n\t */\n\tBufferQueue.prototype.flush = function() {\n\t  this._buffers = [];\n\t  this._pendingBuffer = this.createBuffer(this.bufferSize);\n\t  this._pendingPos = 0;\n\t};\n\n\t/**\n\t * Count how many samples are queued up\n\t *\n\t * @returns {number} - total count in samples\n\t */\n\tBufferQueue.prototype.sampleCount = function() {\n\t  var count = 0;\n\t  this._buffers.forEach(function(buffer) {\n\t    count += buffer[0].length;\n\t  });\n\t  return count;\n\t};\n\n\t/**\n\t * Create an empty audio sample buffer with space for the given count of samples.\n\t *\n\t * @param {number} sampleCount - number of samples to reserve in the buffer\n\t * @returns {SampleBuffer} - empty buffer\n\t */\n\tBufferQueue.prototype.createBuffer = function(sampleCount) {\n\t  var output = [];\n\t  for (var i = 0; i < this.channels; i++) {\n\t    output[i] = new Float32Array(sampleCount);\n\t  }\n\t  return output;\n\t};\n\n\t/**\n\t * Validate a buffer for correct object layout\n\t *\n\t * @param {SampleBuffer} buffer - an audio buffer to check\n\t * @returns {boolean} - true if input buffer is valid\n\t */\n\tBufferQueue.prototype.validate = function(buffer) {\n\t  if (buffer.length !== this.channels) {\n\t    return false;\n\t  }\n\n\t  var sampleCount;\n\t  for (var i = 0; i < buffer.length; i++) {\n\t    var channelData = buffer[i];\n\t    if (!(channelData instanceof Float32Array)) {\n\t      return false;\n\t    }\n\t    if (i == 0) {\n\t      sampleCount = channelData.length;\n\t    } else if (channelData.length !== sampleCount) {\n\t      return false;\n\t    }\n\t  }\n\n\t  return true;\n\t};\n\n\t/**\n\t * Append a buffer of input data to the queue...\n\t *\n\t * @param {SampleBuffer} sampleData - an audio buffer to append\n\t * @throws exception on invalid input\n\t */\n\tBufferQueue.prototype.appendBuffer = function(sampleData) {\n\t  if (!this.validate(sampleData)) {\n\t    throw \"Invalid audio buffer passed to BufferQueue.appendBuffer\";\n\t  }\n\n\t  var firstChannel = sampleData[0],\n\t    sampleCount = firstChannel.length;\n\n\t  // @todo this still seems kinda inefficient\n\t  var channels = this.channels;\n\t  var pendingPos = this._pendingPos;\n\t  var pendingBuffer = this._pendingBuffer;\n\t  var bufferSize = this.bufferSize;\n\t  for (var i = 0; i < sampleCount; i++) {\n\t    for (var channel = 0; channel < channels; channel++) {\n\t      pendingBuffer[channel][pendingPos] = sampleData[channel][i];\n\t    }\n\t    if (++pendingPos == bufferSize) {\n\t      this._buffers.push(pendingBuffer);\n\t      pendingPos = this._pendingPos = 0;\n\t      pendingBuffer = this._pendingBuffer = this.createBuffer(bufferSize);\n\t    }\n\t  }\n\t  this._pendingPos = pendingPos;\n\t};\n\n\t/**\n\t * Unshift the given sample buffer onto the beginning of the buffer queue.\n\t *\n\t * @param {SampleBuffer} sampleData - an audio buffer to prepend\n\t * @throws exception on invalid input\n\t *\n\t * @todo this is currently pretty inefficient as it rechunks all the buffers.\n\t */\n\tBufferQueue.prototype.prependBuffer = function(sampleData) {\n\t  if (!this.validate(sampleData)) {\n\t    throw \"Invalid audio buffer passed to BufferQueue.prependBuffer\";\n\t  }\n\n\t  // Since everything is pre-chunked in the queue, we're going to have\n\t  // to pull everything out and re-append it.\n\t  var buffers = this._buffers.slice(0)\n\t  buffers.push(this.trimBuffer(this._pendingBuffer, 0, this._pendingPos));\n\n\t  this.flush();\n\t  this.appendBuffer(sampleData);\n\n\t  // Now put back any old buffers, dividing them up into chunks.\n\t  for (var i = 0; i < buffers.length; i++) {\n\t    this.appendBuffer(buffers[i]);\n\t  }\n\t};\n\n\t/**\n\t * Shift out a buffer from the head of the queue, containing a maximum of\n\t * {@link BufferQueue#bufferSize} samples; if there are not enough samples\n\t * you may get a shorter buffer. Call {@link BufferQueue#sampleCount} to\n\t * check if enough samples are available for your needs.\n\t *\n\t * @returns {SampleBuffer} - an audio buffer with zero or more samples\n\t */\n\tBufferQueue.prototype.nextBuffer = function() {\n\t  if (this._buffers.length) {\n\t    return this._buffers.shift();\n\t  } else {\n\t    var trimmed = this.trimBuffer(this._pendingBuffer, 0, this._pendingPos);\n\t    this._pendingBuffer = this.createBuffer(this.bufferSize);\n\t    this._pendingPos = 0;\n\t    return trimmed;\n\t  }\n\t};\n\n\t/**\n\t * Trim a buffer down to a given maximum sample count.\n\t * Any additional samples will simply be cropped off of the view.\n\t * If no trimming is required, the same buffer will be returned.\n\t *\n\t * @param {SampleBuffer} sampleData - input data\n\t * @param {number} start - sample number to start at\n\t * @param {number} maxSamples - count of samples to crop to\n\t * @returns {SampleBuffer} - output data with at most maxSamples samples\n\t */\n\tBufferQueue.prototype.trimBuffer = function(sampleData, start, maxSamples) {\n\t  var bufferLength = sampleData[0].length,\n\t    end = start + Math.min(maxSamples, bufferLength);\n\t  if (start == 0 && end >= bufferLength) {\n\t    return sampleData;\n\t  } else {\n\t    var output = [];\n\t    for (var i = 0; i < this.channels; i++) {\n\t      output[i] = sampleData[i].subarray(start, end);\n\t    }\n\t    return output;\n\t  }\n\t};\n\n\tmodule.exports = BufferQueue;\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @file Web Audio API backend for AudioFeeder\n\t * @author Brion Vibber <brion@pobox.com>\n\t * @copyright (c) 2013-2016 Brion Vibber\n\t * @license MIT\n\t */\n\n\t(function() {\n\n\t  var AudioContext = window.AudioContext || window.webkitAudioContext,\n\t    BufferQueue = __webpack_require__(1),\n\t    nextTick = __webpack_require__(3);\n\n\t  /**\n\t   * Constructor for AudioFeeder's Web Audio API backend.\n\t   * @class\n\t   * @param {number} numChannels - requested count of output channels\n\t   * @param {number} sampleRate - requested sample rate for output\n\t   * @param {Object} options - pass URL path to directory containing 'dynamicaudio.swf' in 'base' parameter\n\t   *\n\t   * @classdesc Web Audio API output backend for AudioFeeder.\n\t   * Maintains an internal {@link BufferQueue} of audio samples to be output on demand.\n\t   */\n\t  function WebAudioBackend(numChannels, sampleRate, options) {\n\t    var context = options.audioContext || WebAudioBackend.initSharedAudioContext();\n\n\t    this._context = context;\n\n\n\t    /*\n\t     * Optional audio node can be provided to connect the feeder to\n\t     * @type {AudioNode}\n\t     */\n\t    this.output = options.output || context.destination\n\n\t    /**\n\t     * Actual sample rate supported for output, in Hz\n\t     * @type {number}\n\t     * @readonly\n\t     */\n\t    this.rate = context.sampleRate;\n\n\t    /**\n\t     * Actual count of channels supported for output\n\t     * @type {number}\n\t     * @readonly\n\t     *\n\t     * Note currently this is forced to 2. More channels (5.1, etc)\n\t     * aren't well specified and need to be tested. Fewer channels\n\t     * (mono) ends up too loud unless we reduce amplitude in the\n\t     * resampling operation.\n\t     */\n\t    //this.channels = Math.min(numChannels, 2); // @fixme remove this limit\n\t    this.channels = 2; // @fixme remove this limit\n\n\t    if (options.bufferSize) {\n\t        this.bufferSize = (options.bufferSize | 0);\n\t    }\n\t    this.bufferThreshold = 2 * this.bufferSize;\n\n\t    this._bufferQueue = new BufferQueue(this.channels, this.bufferSize);\n\t    this._playbackTimeAtBufferTail = context.currentTime;\n\t    this._queuedTime = 0;\n\t    this._delayedTime = 0;\n\t    this._dropped = 0;\n\t    this._liveBuffer = this._bufferQueue.createBuffer(this.bufferSize);\n\n\t    // @todo support new audio worker mode too\n\t    if (context.createScriptProcessor) {\n\t      this._node = context.createScriptProcessor(this.bufferSize, 0, this.channels);\n\t    } else if (context.createJavaScriptNode) {\n\t      // In older Safari versions\n\t      this._node = context.createJavaScriptNode(this.bufferSize, 0, this.channels);\n\t    } else {\n\t      throw new Error(\"Bad version of web audio API?\");\n\t    }\n\t  }\n\n\t  /**\n\t   * Size of output buffers in samples, as a hint for latency/scheduling\n\t   * @type {number}\n\t   * @readonly\n\t   */\n\t  WebAudioBackend.prototype.bufferSize = 4096;\n\n\t  /**\n\t   * Remaining sample count at which a 'bufferlow' event will be triggered.\n\t   *\n\t   * Will be pinged when falling below bufferThreshold or bufferSize,\n\t   * whichever is larger.\n\t   *\n\t   * @type {number}\n\t   */\n\t  WebAudioBackend.prototype.bufferThreshold = 8192;\n\n\t  /**\n\t   * Internal volume property backing.\n\t   * @type {number}\n\t   * @access private\n\t   */\n\t  WebAudioBackend.prototype._volume = 1;\n\n\t  /**\n\t\t * Volume multiplier, defaults to 1.0.\n\t\t * @name volume\n\t\t * @type {number}\n\t\t */\n\t\tObject.defineProperty(WebAudioBackend.prototype, 'volume', {\n\t\t\tget: function getVolume() {\n\t      return this._volume;\n\t\t\t},\n\t\t\tset: function setVolume(val) {\n\t      this._volume = +val;\n\t\t\t}\n\t\t});\n\n\t  /**\n\t   * Internal muted property backing.\n\t   * @type {number}\n\t   * @access private\n\t   */\n\t  WebAudioBackend.prototype._muted = false;\n\n\t  /**\n\t\t * Is the backend currently set to mute output?\n\t\t * When muted, this overrides the volume property.\n\t\t *\n\t\t * @type {boolean}\n\t\t */\n\t\tObject.defineProperty(WebAudioBackend.prototype, 'muted', {\n\t \t\tget: function getMuted() {\n\t      return this._muted;\n\t \t\t},\n\t \t\tset: function setMuted(val) {\n\t      this._muted = !!val;\n\t \t\t}\n\t \t});\n\n\t  /**\n\t   * onaudioprocess event handler for the ScriptProcessorNode\n\t   * @param {AudioProcessingEvent} event - audio processing event object\n\t   * @access private\n\t   */\n\t  WebAudioBackend.prototype._audioProcess = function(event) {\n\t    var channel, input, output, i, playbackTime;\n\t    if (typeof event.playbackTime === 'number') {\n\t      playbackTime = event.playbackTime;\n\t    } else {\n\t      // Safari 6.1 hack\n\t      playbackTime = this._context.currentTime + (this.bufferSize / this.rate);\n\t    }\n\n\t    var expectedTime = this._playbackTimeAtBufferTail;\n\t    if (expectedTime < playbackTime) {\n\t      // we may have lost some time while something ran too slow\n\t      this._delayedTime += (playbackTime - expectedTime);\n\t    }\n\n\t    if (this._bufferQueue.sampleCount() < this.bufferSize) {\n\t      // We might be in a throttled background tab; go ping the decoder\n\t      // and let it know we need more data now!\n\t      // @todo use standard event firing?\n\t      if (this.onstarved) {\n\t        this.onstarved();\n\t      }\n\t    }\n\n\t    // If we still haven't got enough data, write a buffer of silence\n\t    // to all channels and record an underrun event.\n\t    // @todo go ahead and output the data we _do_ have?\n\t    if (this._bufferQueue.sampleCount() < this.bufferSize) {\n\t      for (channel = 0; channel < this.channels; channel++) {\n\t        output = event.outputBuffer.getChannelData(channel);\n\t        for (i = 0; i < this.bufferSize; i++) {\n\t          output[i] = 0;\n\t        }\n\t      }\n\t      this._dropped++;\n\t      return;\n\t    }\n\n\t    var volume = (this.muted ? 0 : this.volume);\n\n\t    // Actually get that data and write it out...\n\t    var inputBuffer = this._bufferQueue.nextBuffer();\n\t    if (inputBuffer[0].length < this.bufferSize) {\n\t      // This should not happen, but trust no invariants!\n\t      throw 'Audio buffer not expected length.';\n\t    }\n\t    for (channel = 0; channel < this.channels; channel++) {\n\t      input = inputBuffer[channel];\n\n\t      // Save this buffer data for later in case we pause\n\t      this._liveBuffer[channel].set(inputBuffer[channel]);\n\n\t      // And play it out with volume applied...\n\t      output = event.outputBuffer.getChannelData(channel);\n\t      for (i = 0; i < input.length; i++) {\n\t        output[i] = input[i] * volume;\n\t      }\n\t    }\n\t    this._queuedTime += (this.bufferSize / this.rate);\n\t    this._playbackTimeAtBufferTail = playbackTime + (this.bufferSize / this.rate);\n\n\t    if (this._bufferQueue.sampleCount() < Math.max(this.bufferSize, this.bufferThreshold)) {\n\t      // Let the decoder know ahead of time we're running low on data.\n\t      // @todo use standard event firing?\n\t      if (this.onbufferlow) {\n\t        nextTick(this.onbufferlow.bind(this));\n\t      }\n\t    }\n\t  };\n\n\n\t  /**\n\t   * Return a count of samples that have been queued or output but not yet played.\n\t   *\n\t   * @returns {number} - sample count\n\t   * @access private\n\t   */\n\t  WebAudioBackend.prototype._samplesQueued = function() {\n\t    var bufferedSamples = this._bufferQueue.sampleCount();\n\t    var remainingSamples = Math.floor(this._timeAwaitingPlayback() * this.rate);\n\n\t    return bufferedSamples + remainingSamples;\n\t  };\n\n\t  /**\n\t   * Return time duration between the present and the endpoint of audio\n\t   * we have already sent out from our queue to Web Audio.\n\t   *\n\t   * @returns {number} - seconds\n\t   */\n\t  WebAudioBackend.prototype._timeAwaitingPlayback = function() {\n\t    return Math.max(0, this._playbackTimeAtBufferTail - this._context.currentTime);\n\t  };\n\n\t  /**\n\t   * Get info about current playback state.\n\t   *\n\t   * @return {PlaybackState} - info about current playback state\n\t   */\n\t  WebAudioBackend.prototype.getPlaybackState = function() {\n\t    return {\n\t      playbackPosition: this._queuedTime - this._timeAwaitingPlayback(),\n\t      samplesQueued: this._samplesQueued(),\n\t      dropped: this._dropped,\n\t      delayed: this._delayedTime\n\t    };\n\t  };\n\n\t  /**\n\t   * Wait asynchronously until the backend is ready before continuing.\n\t   *\n\t   * This will always call immediately for the Web Audio API backend,\n\t   * as there is no async setup process.\n\t   *\n\t   * @param {function} callback - to be called when ready\n\t   */\n\t  WebAudioBackend.prototype.waitUntilReady = function(callback) {\n\t    callback();\n\t  };\n\n\t  /**\n\t   * Append a buffer of audio data to the output queue for playback.\n\t   *\n\t   * Audio data must be at the expected sample rate; resampling is done\n\t   * upstream in {@link AudioFeeder}.\n\t   *\n\t   * @param {SampleBuffer} sampleData - audio data at target sample rate\n\t   */\n\t  WebAudioBackend.prototype.appendBuffer = function(sampleData) {\n\t    this._bufferQueue.appendBuffer(sampleData);\n\t  };\n\n\t  /**\n\t   * Start playback.\n\t   *\n\t   * Audio should have already been queued at this point,\n\t   * or starvation may occur immediately.\n\t   */\n\t  WebAudioBackend.prototype.start = function() {\n\t    this._node.onaudioprocess = this._audioProcess.bind(this);\n\t    this._node.connect(this.output);\n\t    this._playbackTimeAtBufferTail = this._context.currentTime;\n\t  };\n\n\t  /**\n\t   * Stop playback, but don't release resources or clear the buffers.\n\t   * We'll probably come back soon.\n\t   */\n\t  WebAudioBackend.prototype.stop = function() {\n\t    if (this._node) {\n\t      var timeRemaining = this._timeAwaitingPlayback();\n\t      if (timeRemaining > 0) {\n\t        // We have some leftover samples that got queued but didn't get played.\n\t        // Unshift them back onto the beginning of the buffer.\n\t        // @todo make this not a horrible hack\n\t        var samplesRemaining = Math.round(timeRemaining * this.rate),\n\t            samplesAvailable = this._liveBuffer ? this._liveBuffer[0].length : 0;\n\t        if (samplesRemaining > samplesAvailable) {\n\t          //console.log('liveBuffer size ' + samplesRemaining + ' vs ' + samplesAvailable);\n\t          this._bufferQueue.prependBuffer(this._liveBuffer);\n\t          this._bufferQueue.prependBuffer(\n\t            this._bufferQueue.createBuffer(samplesRemaining - samplesAvailable));\n\t        } else {\n\t          this._bufferQueue.prependBuffer(\n\t            this._bufferQueue.trimBuffer(this._liveBuffer, samplesAvailable - samplesRemaining, samplesRemaining));\n\t        }\n\t        this._playbackTimeAtBufferTail -= timeRemaining;\n\t      }\n\t      this._node.onaudioprocess = null;\n\t      this._node.disconnect();\n\t    }\n\t  };\n\n\t  /**\n\t   * Flush any queued data out of the system.\n\t   */\n\t  WebAudioBackend.prototype.flush = function() {\n\t    this._bufferQueue.flush();\n\t  };\n\n\t  /**\n\t   * Close out the playback system and release resources.\n\t   *\n\t   * @todo consider releasing the AudioContext when possible\n\t   */\n\t  WebAudioBackend.prototype.close = function() {\n\t    this.stop();\n\n\t    this._context = null;\n\t  };\n\n\t  /**\n\t   * Synchronous callback for when we run out of input data\n\t   *\n\t   * @type function|null\n\t   */\n\t  WebAudioBackend.prototype.onstarved = null;\n\n\t  /**\n\t   * Asynchronous callback for when the buffer runs low and\n\t   * should be refilled soon.\n\t   *\n\t   * @type function|null\n\t   */\n\t  WebAudioBackend.prototype.onbufferlow = null;\n\n\t  /**\n\t   * Check if Web Audio API appears to be supported.\n\t   *\n\t   * Note this is somewhat optimistic; will return true even if there are no\n\t   * audio devices available, as long as the API is present.\n\t   *\n\t   * @returns {boolean} - true if this browser appears to support Web Audio API\n\t   */\n\t  WebAudioBackend.isSupported = function() {\n\t    return !!AudioContext;\n\t  };\n\n\t  /**\n\t   * Holder of audio context to be used/reused by WebAudioBackend.\n\t   * @see {WebAudioBackend#initSharedAudioContext}\n\t   *\n\t   * @type {AudioContext}\n\t   */\n\t  WebAudioBackend.sharedAudioContext = null;\n\n\t  /**\n\t\t * Force initialization of the default Web Audio API context.\n\t\t *\n\t\t * Some browsers (such as mobile Safari) disable audio output unless\n\t\t * first triggered from a UI event handler; call this method as a hint\n\t\t * that you will be starting up an AudioFeeder soon but won't have data\n\t\t * for it until a later callback.\n\t   *\n\t   * @returns {AudioContext|null} - initialized AudioContext instance, if applicable\n\t\t */\n\t  WebAudioBackend.initSharedAudioContext = function() {\n\t\t\tif (!WebAudioBackend.sharedAudioContext) {\n\t\t\t\tif (WebAudioBackend.isSupported()) {\n\t\t\t\t\t// We're only allowed 4 contexts on many browsers\n\t\t\t\t\t// and there's no way to discard them (!)...\n\t\t\t\t\tvar context = new AudioContext(),\n\t\t\t\t\t\tnode;\n\t\t\t\t\tif (context.createScriptProcessor) {\n\t\t\t\t\t\tnode = context.createScriptProcessor(1024, 0, 2);\n\t\t\t\t\t} else if (context.createJavaScriptNode) {\n\t\t\t\t\t\tnode = context.createJavaScriptNode(1024, 0, 2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error( \"Bad version of web audio API?\" );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Don't actually run any audio, just start & stop the node\n\t\t\t\t\tnode.connect(context.destination);\n\t\t\t\t\tnode.disconnect();\n\n\t        // So far so good. Keep it around!\n\t        WebAudioBackend.sharedAudioContext = context;\n\t\t\t\t}\n\t\t\t}\n\t    return WebAudioBackend.sharedAudioContext;\n\t\t};\n\n\t  module.exports = WebAudioBackend;\n\n\t})();\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = (function() {\n\t\t// Don't try to check for setImmediate directly; webpack implements\n\t\t// it using setTimeout which will be throttled in background tabs.\n\t\t// Checking directly on the global window object skips this interference.\n\t\tif (typeof window.setImmediate !== 'undefined') {\n\t\t\treturn window.setImmediate;\n\t\t}\n\n\t\t// window.postMessage goes straight to the event loop, no throttling.\n\t\tif (window && window.postMessage) {\n\t\t\tvar nextTickQueue = [];\n\t\t\twindow.addEventListener('message', function(event) {\n\t\t\t\tif (event.source === window) {\n\t\t\t\t\tvar data = event.data;\n\t\t\t\t\tif (typeof data === 'object' && data.nextTickBrowserPingMessage) {\n\t\t\t\t\t\tvar callback = nextTickQueue.pop();\n\t\t\t\t\t\tif (callback) {\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn function(callback) {\n\t\t\t\tnextTickQueue.push(callback);\n\t\t\t\twindow.postMessage({\n\t\t\t\t\tnextTickBrowserPingMessage: true\n\t\t\t\t}, document.location.toString())\n\t\t\t};\n\t\t}\n\n\t\t// Timeout fallback may be poor in background tabs\n\t\treturn function(callback) {\n\t\t\tsetTimeout(callback, 0);\n\t\t}\n\t})();\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t(function() {\n\n\t  /* global ActiveXObject */\n\t  var dynamicaudio_swf = __webpack_require__(5);\n\n\t  var nextTick = __webpack_require__(3);\n\n\t  /**\n\t   * Constructor for AudioFeeder's Flash audio backend.\n\t   * @class\n\t   * @param {number} numChannels - requested count of output channels (actual will be fixed at 2)\n\t   * @param {number} sampleRate - requested sample rate for output (actual will be fixed at 44.1 kHz)\n\t   * @param {Object} options - pass URL path to directory containing 'dynamicaudio.swf' in 'base' parameter\n\t   *\n\t   * @classdesc Flash audio output backend for AudioFeeder.\n\t   * Maintains a local queue of data to be sent down to the Flash shim.\n\t   * Resampling to stereo 44.1 kHz is done upstream in AudioFeeder.\n\t   */\n\t  var FlashBackend = function(numChannels, sampleRate, options) {\n\t    options = options || {};\n\t    var flashOptions = {};\n\t    if (typeof options.base === 'string') {\n\t      // @fixme replace the version string with an auto-updateable one\n\t      flashOptions.swf = options.base + '/' + dynamicaudio_swf;\n\t    }\n\t    if (options.bufferSize) {\n\t      this.bufferSize = (options.bufferSize | 0);\n\t    }\n\n\t    this._flashaudio = new DynamicAudio(flashOptions);\n\t    this._flashBuffer = '';\n\t    this._cachedFlashState = null;\n\t    this._cachedFlashTime = 0;\n\t    this._cachedFlashInterval = 185; // resync state no more often than every X ms\n\n\t    this._waitUntilReadyQueue = [];\n\t    this.onready = function() {\n\t        this._flashaudio.flashElement.setBufferSize(this.bufferSize);\n\t        this._flashaudio.flashElement.setBufferThreshold(this.bufferThreshold);\n\t        while (this._waitUntilReadyQueue.length) {\n\t            var callback = this._waitUntilReadyQueue.shift();\n\t            callback.apply(this);\n\t        }\n\t    };\n\t    this.onlog = function(msg) {\n\t        console.log('AudioFeeder FlashBackend: ' + msg);\n\t    }\n\n\t    this.bufferThreshold = this.bufferSize * 2;\n\n\t    var events = {\n\t        'ready': 'sync',\n\t        'log': 'sync',\n\t        'starved': 'sync',\n\t        'bufferlow': 'async'\n\t    };\n\t    this._callbackName = 'AudioFeederFlashBackendCallback' + this._flashaudio.id;\n\t    var self = this;\n\t    window[this._callbackName] = (function(eventName) {\n\t        var method = events[eventName],\n\t            callback = this['on' + eventName];\n\t        if (method && callback) {\n\t            if (method === 'async') {\n\t                nextTick(callback.bind(this));\n\t            } else {\n\t                callback.apply(this, Array.prototype.slice.call(arguments, 1));\n\t                this._flushFlashBuffer();\n\t            }\n\t        }\n\t    }).bind(this);\n\t  };\n\n\t  /**\n\t   * Actual sample rate supported for output, in Hz\n\t   * Fixed to 44.1 kHz for Flash backend.\n\t   * @type {number}\n\t   * @readonly\n\t   */\n\t  FlashBackend.prototype.rate = 44100;\n\n\t  /**\n\t   * Actual count of channels supported for output\n\t   * Fixed to stereo for Flash backend.\n\t   * @type {number}\n\t   * @readonly\n\t   */\n\t  FlashBackend.prototype.channels = 2;\n\n\t  /**\n\t   * Buffer size hint.\n\t   * @type {number}\n\t   * @readonly\n\t   */\n\t  FlashBackend.prototype.bufferSize = 4096;\n\n\t  /**\n\t   * Internal bufferThreshold property backing.\n\t   * @type {number}\n\t   * @access private\n\t   */\n\t  FlashBackend.prototype._bufferThreshold = 8192;\n\n\t  /**\n\t   * Remaining sample count at which a 'bufferlow' event will be triggered.\n\t   *\n\t   * Will be pinged when falling below bufferThreshold or bufferSize,\n\t   * whichever is larger.\n\t   *\n\t   * @type {number}\n\t   */\n\t  Object.defineProperty(FlashBackend.prototype, 'bufferThreshold', {\n\t    get: function getBufferThreshold() {\n\t      return this._bufferThreshold;\n\t    },\n\t    set: function setBufferThreshold(val) {\n\t      this._bufferThreshold = val | 0;\n\t      this.waitUntilReady((function() {\n\t        this._flashaudio.flashElement.setBufferThreshold(this._bufferThreshold);\n\t      }).bind(this));\n\t    }\n\t  });\n\n\t  /**\n\t   * Internal volume property backing.\n\t   * @type {number}\n\t   * @access private\n\t   */\n\t  FlashBackend.prototype._volume = 1;\n\n\t  /**\n\t\t * Volume multiplier, defaults to 1.0.\n\t\t * @name volume\n\t\t * @type {number}\n\t\t */\n\t\tObject.defineProperty(FlashBackend.prototype, 'volume', {\n\t\t\tget: function getVolume() {\n\t      return this._volume;\n\t\t\t},\n\t\t\tset: function setVolume(val) {\n\t      this._volume = +val;\n\t      this.waitUntilReady(this._flashVolumeUpdate.bind(this));\n\t\t\t}\n\t\t});\n\n\t  /**\n\t   * Internal muted property backing.\n\t   * @type {number}\n\t   * @access private\n\t   */\n\t  FlashBackend.prototype._muted = false;\n\n\t  /**\n\t\t * Is the backend currently set to mute output?\n\t\t * When muted, this overrides the volume property.\n\t\t *\n\t\t * @type {boolean}\n\t\t */\n\t\tObject.defineProperty(FlashBackend.prototype, 'muted', {\n\t \t\tget: function getMuted() {\n\t      return this._muted;\n\t \t\t},\n\t \t\tset: function setMuted(val) {\n\t      this._muted = !!val;\n\t      this.waitUntilReady(this._flashVolumeUpdate.bind(this));\n\t \t\t}\n\t \t});\n\n\t  /**\n\t   * Are we paused/idle?\n\t   * @type {boolean}\n\t   * @access private\n\t   */\n\t  FlashBackend.prototype._paused = true;\n\n\t  /**\n\t   * Pass the currently configured muted+volume state down to the Flash plugin\n\t   * @access private\n\t   */\n\t  FlashBackend.prototype._flashVolumeUpdate = function() {\n\t    if (this._flashaudio && this._flashaudio.flashElement && this._flashaudio.flashElement.setVolume) {\n\t      this._flashaudio.flashElement.setVolume(this.muted ? 0 : this.volume);\n\t    }\n\t  }\n\n\t  /**\n\t   * Reordering of output for the Flash fallback.\n\t   * Input data must be pre-resampled to the correct sample rate.\n\t   * Mono input is doubled to stereo; more than 2 channels are dropped.\n\t   *\n\t   * @param {SampleBuffer} samples - input data as separate channels of 32-bit float\n\t   * @returns {Float32Array} - interleaved stereo 32-bit float output\n\t   * @access private\n\t   *\n\t   * @todo handle input with higher channel counts better\n\t   */\n\t  FlashBackend.prototype._resampleFlash = function(samples) {\n\t  \tvar samplecount = samples[0].length;\n\t  \tvar newSamples = new Float32Array(samplecount * 2);\n\t  \tvar chanLeft = samples[0];\n\t  \tvar chanRight = this.channels > 1 ? samples[1] : chanLeft;\n\t  \tfor(var s = 0; s < samplecount; s++) {\n\t  \t\tvar idx = s;\n\t  \t\tvar idx_out = s * 2;\n\n\t  \t\tnewSamples[idx_out] = chanLeft[idx];\n\t  \t\tnewSamples[idx_out + 1] = chanRight[idx];\n\t  \t}\n\t  \treturn newSamples;\n\t  };\n\n\t  var binBytes = [];\n\t  for (var i = 0; i < 256; i++) {\n\t    binBytes[i] = String.fromCharCode(i + 0xe000);\n\t  }\n\t  function binaryString(buffer) {\n\t    var samples = new Uint8Array(buffer);\n\t    var len = samples.length;\n\t    var str = '';\n\t    for (var i = 0; i < len; i += 8) {\n\t      str += binBytes[samples[i]];\n\t      str += binBytes[samples[i + 1]];\n\t      str += binBytes[samples[i + 2]];\n\t      str += binBytes[samples[i + 3]];\n\t      str += binBytes[samples[i + 4]];\n\t      str += binBytes[samples[i + 5]];\n\t      str += binBytes[samples[i + 6]];\n\t      str += binBytes[samples[i + 7]];\n\t    }\n\t    return str;\n\t  }\n\n\t  /**\n\t   * Send any pending data off to the Flash plugin.\n\t   *\n\t   * @access private\n\t   */\n\t  FlashBackend.prototype._flushFlashBuffer = function() {\n\t    var chunk = this._flashBuffer,\n\t      flashElement = this._flashaudio.flashElement;\n\n\t    this._flashBuffer = '';\n\n\t    if (chunk.length > 0) {\n\t      this._cachedFlashState = flashElement.write(chunk);\n\t      this._cachedFlashTime = Date.now();\n\t    }\n\t  };\n\n\t  /**\n\t   * Append a buffer of audio data to the output queue for playback.\n\t   *\n\t   * Audio data must be at the expected sample rate; resampling is done\n\t   * upstream in {@link AudioFeeder}.\n\t   *\n\t   * @param {SampleBuffer} sampleData - audio data at target sample rate\n\t   */\n\t  FlashBackend.prototype.appendBuffer = function(sampleData) {\n\t    var resamples = this._resampleFlash(sampleData);\n\t    if (resamples.length > 0) {\n\t      var str = binaryString(resamples.buffer);\n\t      this._flashBuffer += str;\n\t      if (this._flashBuffer.length >= this.bufferSize * 8) {\n\t        // consolidate multiple consecutive tiny buffers in one pass;\n\t        // pushing data to Flash is relatively expensive on slow machines\n\t        this._flushFlashBuffer();\n\t      }\n\t    }\n\t  };\n\n\t  /**\n\t   * Get info about current playback state.\n\t   *\n\t   * @return {PlaybackState} - info about current playback state\n\t   */\n\t  FlashBackend.prototype.getPlaybackState = function() {\n\t    if (this._flashaudio && this._flashaudio.flashElement && this._flashaudio.flashElement.write) {\n\t      var now = Date.now(),\n\t        delta = this._paused ? 0 : (now - this._cachedFlashTime),\n\t        state;\n\t      if (this._cachedFlashState && delta < this._cachedFlashInterval) {\n\t        var cachedFlashState = this._cachedFlashState;\n\t        state = {\n\t          playbackPosition: cachedFlashState.playbackPosition + delta / 1000,\n\t          samplesQueued: cachedFlashState.samplesQueued -\n\t            Math.max(0, Math.round(delta * this.rate / 1000)),\n\t          dropped: cachedFlashState.dropped,\n\t          delayed: cachedFlashState.delayed\n\t        };\n\t      } else {\n\t        state = this._flashaudio.flashElement.getPlaybackState();\n\t        this._cachedFlashState = state;\n\t        this._cachedFlashTime = now;\n\t      }\n\t      state.samplesQueued += this._flashBuffer.length / 8;\n\t      return state;\n\t    } else {\n\t      //console.log('getPlaybackState USED TOO EARLY');\n\t      return {\n\t        playbackPosition: 0,\n\t        samplesQueued: 0,\n\t        dropped: 0,\n\t        delayed: 0\n\t      };\n\t    }\n\t  };\n\n\t  /**\n\t   * Wait until the backend is ready to start, then call the callback.\n\t   *\n\t   * @param {function} callback - called on completion\n\t   * @todo handle fail case better?\n\t   */\n\t  FlashBackend.prototype.waitUntilReady = function(callback) {\n\t    if (this._flashaudio && this._flashaudio.flashElement.write) {\n\t      callback.apply(this);\n\t    } else {\n\t      this._waitUntilReadyQueue.push(callback);\n\t    }\n\t  };\n\n\t  /**\n\t   * Start playback.\n\t   *\n\t   * Audio should have already been queued at this point,\n\t   * or starvation may occur immediately.\n\t   */\n\t  FlashBackend.prototype.start = function() {\n\t    this._flushFlashBuffer();\n\t    this._flashaudio.flashElement.start();\n\t    this._paused = false;\n\t    this._cachedFlashState = null;\n\t  };\n\n\t  /**\n\t   * Stop playback, but don't release resources or clear the buffers.\n\t   * We'll probably come back soon.\n\t   */\n\t  FlashBackend.prototype.stop = function() {\n\t    this._flashaudio.flashElement.stop();\n\t    this._paused = true;\n\t    this._cachedFlashState = null;\n\t  };\n\n\t  /**\n\t   * Flush any queued data out of the system.\n\t   */\n\t  FlashBackend.prototype.flush = function() {\n\t    this._flashBuffer = '';\n\t    this._flashaudio.flashElement.flush();\n\t    this._cachedFlashState = null;\n\t  };\n\n\t  /**\n\t   * Close out the playback system and release resources.\n\t   */\n\t  FlashBackend.prototype.close = function() {\n\t    this.stop();\n\n\t    var wrapper = this._flashaudio.flashWrapper;\n\t    wrapper.parentNode.removeChild(wrapper);\n\t    this._flashaudio = null;\n\t    delete window[this._callbackName];\n\t  };\n\n\t  /**\n\t   * Synchronous callback for when we run out of input data\n\t   *\n\t   * @type function|null\n\t   */\n\t  FlashBackend.prototype.onstarved = null;\n\n\t  /**\n\t   * Asynchronous callback for when the buffer runs low and\n\t   * should be refilled soon.\n\t   *\n\t   * @type function|null\n\t   */\n\t  FlashBackend.prototype.onbufferlow = null;\n\n\t  /**\n\t   * Check if the browser appears to support Flash.\n\t   *\n\t   * Note this is somewhat optimistic, in that Flash may be supported\n\t   * but the dynamicaudio.swf file might not load, or it might load\n\t   * but there might be no audio devices, etc.\n\t   *\n\t   * Currently only checks for the ActiveX Flash plugin for Internet Explorer,\n\t   * as other target browsers support Web Audio API.\n\t   *\n\t   * @returns {boolean} - true if this browser appears to support Flash\n\t   */\n\t  FlashBackend.isSupported = function() {\n\t\t\tif (navigator.userAgent.indexOf('Trident') !== -1) {\n\t\t\t\t// We only do the ActiveX test because we only need Flash in\n\t\t\t\t// Internet Explorer 10/11. Other browsers use Web Audio directly\n\t\t\t\t// (Edge, Safari) or native playback, so there's no need to test\n\t\t\t\t// other ways of loading Flash.\n\t\t\t\ttry {\n\t\t\t\t\tvar obj = new ActiveXObject('ShockwaveFlash.ShockwaveFlash');\n\t\t\t\t\treturn true;\n\t\t\t\t} catch(e) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t  };\n\n\t\t/** Flash fallback **/\n\n\t\t/*\n\t\tThe Flash fallback is based on https://github.com/an146/dynamicaudio.js\n\n\t\tThis is the contents of the LICENSE file:\n\n\t\tCopyright (c) 2010, Ben Firshman\n\t\tAll rights reserved.\n\n\t\tRedistribution and use in source and binary forms, with or without\n\t\tmodification, are permitted provided that the following conditions are met:\n\n\t\t * Redistributions of source code must retain the above copyright notice, this\n\t\t   list of conditions and the following disclaimer.\n\t\t * Redistributions in binary form must reproduce the above copyright notice,\n\t\t   this list of conditions and the following disclaimer in the documentation\n\t\t   and/or other materials provided with the distribution.\n\t\t * The names of its contributors may not be used to endorse or promote products\n\t\t   derived from this software without specific prior written permission.\n\n\t\tTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n\t\tANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n\t\tWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n\t\tDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n\t\tANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n\t\t(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n\t\tLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n\t\tANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t\t(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n\t\tSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t\t*/\n\n\n\t  /**\n\t   * Wrapper class for instantiating Flash plugin.\n\t   *\n\t   * @constructor\n\t   * @param {Object} opt - pass 'swf' to override default dynamicaudio.swf URL\n\t   * @access private\n\t   */\n\t\tfunction DynamicAudio(opt) {\n\t\t\tthis.init(opt);\n\t\t}\n\n\n\t\tDynamicAudio.nextId = 1;\n\n\t\tDynamicAudio.prototype = {\n\t\t\tnextId: null,\n\t\t\tswf: dynamicaudio_swf,\n\n\t\t\tflashWrapper: null,\n\t\t\tflashElement: null,\n\n\t\t\tinit: function(opts) {\n\t\t\t\tvar self = this;\n\t\t\t\tself.id = DynamicAudio.nextId++;\n\n\t\t\t\tif (opts && typeof opts.swf !== 'undefined') {\n\t\t\t\t\tself.swf = opts.swf;\n\t\t\t\t}\n\n\n\t\t\t\tself.flashWrapper = document.createElement('div');\n\t\t\t\tself.flashWrapper.id = 'dynamicaudio-flashwrapper-'+self.id;\n\t\t\t\t// Credit to SoundManager2 for this:\n\t\t\t\tvar s = self.flashWrapper.style;\n\t\t\t\ts.position = 'fixed';\n\t\t\t\ts.width = '11px'; // must be at least 6px for flash to run fast\n\t\t\t\ts.height = '11px';\n\t\t\t\ts.bottom = s.left = '0px';\n\t\t\t\ts.overflow = 'hidden';\n\t\t\t\tself.flashElement = document.createElement('div');\n\t\t\t\tself.flashElement.id = 'dynamicaudio-flashelement-'+self.id;\n\t\t\t\tself.flashWrapper.appendChild(self.flashElement);\n\n\t\t\t\tdocument.body.appendChild(self.flashWrapper);\n\n\t\t\t\tvar id = self.flashElement.id;\n\t            var params = '<param name=\"FlashVars\" value=\"objectId=' + self.id + '\">';\n\n\t\t\t\tself.flashWrapper.innerHTML = \"<object id='\"+id+\"' width='10' height='10' type='application/x-shockwave-flash' data='\"+self.swf+\"' style='visibility: visible;'><param name='allowscriptaccess' value='always'>\" + params + \"</object>\";\n\t\t\t\tself.flashElement = document.getElementById(id);\n\t\t\t},\n\t\t};\n\n\t  module.exports = FlashBackend;\n\n\t})();\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"dynamicaudio.swf?version=2c1ce3bfb7e6fa65c26d726a00017a94\";\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory();\n\t\telse {}\n\t})(window, function() {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t/******/\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t/******/\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId]) {\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t/******/ \t\t}\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\ti: moduleId,\n\t/******/ \t\t\tl: false,\n\t/******/ \t\t\texports: {}\n\t/******/ \t\t};\n\t/******/\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t/******/\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.l = true;\n\t/******/\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t/******/\n\t/******/\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t/******/\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t/******/\n\t/******/ \t// define getter function for harmony exports\n\t/******/ \t__webpack_require__.d = function(exports, name, getter) {\n\t/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n\t/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n\t/******/ \t\t}\n\t/******/ \t};\n\t/******/\n\t/******/ \t// define __esModule on exports\n\t/******/ \t__webpack_require__.r = function(exports) {\n\t/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t/******/ \t\t}\n\t/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n\t/******/ \t};\n\t/******/\n\t/******/ \t// create a fake namespace object\n\t/******/ \t// mode & 1: value is a module id, require it\n\t/******/ \t// mode & 2: merge all properties of value into the ns\n\t/******/ \t// mode & 4: return value when already ns object\n\t/******/ \t// mode & 8|1: behave like require\n\t/******/ \t__webpack_require__.t = function(value, mode) {\n\t/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n\t/******/ \t\tif(mode & 8) return value;\n\t/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n\t/******/ \t\tvar ns = Object.create(null);\n\t/******/ \t\t__webpack_require__.r(ns);\n\t/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n\t/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n\t/******/ \t\treturn ns;\n\t/******/ \t};\n\t/******/\n\t/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n\t/******/ \t__webpack_require__.n = function(module) {\n\t/******/ \t\tvar getter = module && module.__esModule ?\n\t/******/ \t\t\tfunction getDefault() { return module['default']; } :\n\t/******/ \t\t\tfunction getModuleExports() { return module; };\n\t/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n\t/******/ \t\treturn getter;\n\t/******/ \t};\n\t/******/\n\t/******/ \t// Object.prototype.hasOwnProperty.call\n\t/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\t/******/\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t/******/\n\t/******/\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ (function(module, exports) {\n\n\n\t// Define an allocator and blit function for float arrays\n\t// Can be used to achieve backwards compatibility down to dark ages pre IE 10 if needed\n\t// Also reduces code size a little with closure.\n\n\tvar VH = { \n\t\tfloat_array: function(len) { return new Float32Array(len); },\n\t\tblit: function(src, spos, dest, dpos, len) { dest.set(src.subarray(spos,spos+len),dpos); }\n\t};\n\n\t// Pre-IE10 versions:\n\t/*VH.prototype.float_array = function(len) { return new Array(len); }\n\tVH.prototype.blit = function(src, spos, dest, dpos, len) { for(var i=0;i<len;i++) dest[dpos+i] = src[spos+i]; };*/\n\n\tmodule.exports = VH;\n\n\t/***/ }),\n\t/* 1 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\n\t(function() {\n\n\t\t/*\n\t\t * Phase Vocoder for changing tempo of audio without affecting pitch\n\t\t * Originally cross-compiled from HaXe\n\t\t *\n\t\t * Copyright (c) 2015-2019 Margus Niitsoo\n\t\t */\n\n\t\tvar VH = __webpack_require__(0);\n\t\tvar FFT = __webpack_require__(2);\n\n\t\tvar AudioTempoChanger = function(opts) {\n\n\t\t\t/**************************\n\t\t\t* Fill in sensible defaults\n\t\t\t**************************/\n\n\t\t\topts = opts || {};\n\t\t\tvar sampleRate = opts.sampleRate || 44100;\n\t\t\tvar wsizeLog = opts.wsizeLog || 11; // 2048 - good for 44100 \n\t\t\tvar chosen_tempo = opts.tempo || 1.0;\n\t\t\tvar numChannels = opts.numChannels || 2;\n\n\t\t\t/**************************\n\t\t\t* Initialize variables\n\t\t\t**************************/\n\n\t\t\t// Some constants\n\t\t\tvar GAIN_DEAMPLIFY = 0.9; // Slightly lower the volume to avoid volume overflow-compression\n\t\t\tvar MAX_PEAK_RATIO = 1e-8; // Do not find peaks below this level: 80dB from max\n\t\t\tvar MAX_PEAK_JUMP = (Math.pow(2.0,50/1200.0)-1.0); // Rel distance (in freq) to look for matches\n\t\t\tvar MATCH_MAG_THRESH = 0.1; // New if mag_prev < MATCH_MAG_THRESH * mag_new\n\t\t\t\n\t\t\tvar windowSize = 1 << wsizeLog;\n\t\t\tvar fft = FFT(wsizeLog);\n\n\t\t\t// Caluclate max step size for both ana and syn windows\n\t\t\t// Has to be < 1/4 of window length or audible artifacts occur\n\t\t\tvar max_step_len = 1 << (wsizeLog - 2); // 1/4 of window_size\n\t\t\tmax_step_len -= max_step_len % 100; // Change to a multiple of 100 as tempo is often changed in percents\n\n\t\t\t//console.log(\"MAX STEP\",max_step_len,windowSize);\n\t\t\tvar in_buffer = VH.float_array(windowSize + max_step_len + 5);\n\t\t\tvar out_buffer = VH.float_array(windowSize + max_step_len + 5);\n\t\t\tvar ana_len = max_step_len, syn_len = max_step_len;\n\n\t\t\t// Hanning window\n\t\t\tvar win = VH.float_array(windowSize);\n\t\t\tfor(var i=0;i<windowSize;i++)\n\t\t\t\twin[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / windowSize));\n\n\t\t\tvar hWS = (windowSize >> 1) + 1;\n\t\t\tvar re1 = VH.float_array(hWS), im1 = VH.float_array(hWS);\n\t\t\tvar re2 = VH.float_array(hWS), im2 = VH.float_array(hWS);\n\t\t\tvar pre2 = VH.float_array(hWS), pim2 = VH.float_array(hWS);\n\n\t\t\tvar qWS = (hWS >> 1) + 1;\n\t\t\tvar b_npeaks = [0,0], b_peaks = [], b_in_angs = [], b_peak_adeltas = [];\n\t\t\tvar b_mags = [];\n\t\t\tfor(var i=0;i<2;i++) { // Double buffering\n\t\t\t\tb_peaks.push(VH.float_array(qWS));\n\t\t\t\tb_in_angs.push(VH.float_array(qWS));\n\t\t\t\tb_peak_adeltas.push(VH.float_array(qWS));\n\t\t\t\tb_mags.push(VH.float_array(hWS));\n\t\t\t}\n\t\t\t\n\t\t\tvar peaks_re = VH.float_array(qWS), peaks_im = VH.float_array(qWS);\n\n\t\t\t// Keep track of time (in samples) in both input and output streams\n\t\t\tvar in_time = 0.0, out_time = 0.0;\n\n\t\t\t// Track the changes for mapOutputToInputTime\n\t\t\tvar changes = [{ in_time: 0.0, out_time: 0.0, tempo: chosen_tempo }];\n\n\t\t\tvar f_ind = 0, prev_out_len = 0, gain_comp = 1.0;\n\t\t\tvar syn_drift = 0.0, syn_drift_per_step = 0.0;\n\n\t\t\t// Two variables used for \"process\"\n\t\t\tvar inbuffer_contains = 0, unused_in_outbuf = 0;\n\n\t\t\tvar obj = { };\n\n\t\t\t// Should map time in output to time in input\n\t\t\tobj['mapOutputToInputTime'] = function(given_out_time) {\n\t\t\t\tvar ci = changes.length-1;\n\t\t\t\twhile(given_out_time<changes[ci].out_time && ci>0) ci--;\n\t\t\t\tvar cc = changes[ci];\n\t\t\t\treturn cc.in_time + cc.tempo*(given_out_time-cc.out_time);\n\t\t\t};\n\n\t\t\tobj['flush'] = function(discard_output_seconds) {\n\t\t\t\tsyn_drift = 0.0; b_npeaks = [0,0]; prev_out_len = 0;\n\t\t\t\tunused_in_outbuf = 0; inbuffer_contains = 0;\n\n\t\t\t\tfor(var i=0;i<2;i++)\n\t\t\t\t\tfor(var k=0;k<hWS;k++)\n\t\t\t\t\t\tb_mags[i][k] = 0.0;\n\n\t\t\t\tfor(var i=0;i<in_buffer.length;i++) in_buffer[i] = 0.0;\n\t\t\t\tfor(var i=0;i<out_buffer.length;i++) out_buffer[i] = 0.0;\n\n\t\t\t\t// Scroll time cursor back by discard_output_seconds\n\t\t\t\tif (discard_output_seconds) {\n\n\t\t\t\t\t// Scroll back time in both coordinates\n\t\t\t\t\tout_time = Math.max(0,out_time-discard_output_seconds);\n\t\t\t\t\tin_time = obj['mapOutputToInputTime'](out_time);\n\n\t\t\t\t\t// Clear the now-made-future tempo changes (if any)\n\t\t\t\t\tvar ci = changes.length-1;\n\t\t\t\t\twhile(out_time<=changes[ci].out_time && ci>=0) { changes.pop(); ci--; }\n\n\t\t\t\t\t// Add a tempo change reflecting current state\n\t\t\t\t\tchanges.push({ \n\t\t\t\t\t\tin_time: in_time, out_time: out_time,\n\t\t\t\t\t\ttempo: chosen_tempo\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Small utility function to calculate gain compensation\n\t\t\tvar compute_gain_comp = function(win,syn_len) {\n\t\t\t\tvar n = win.length / syn_len | 0, sum = 0.0;\n\t\t\t\tfor(var i=0;i<n;i++) sum += win[i * syn_len];\n\t\t\t\treturn GAIN_DEAMPLIFY / sum;\n\t\t\t};\n\t\t\t\n\t\t\tobj['getTempo'] = function() { return chosen_tempo; };\n\t\t\tobj['setTempo'] = function(tempo_ratio) {\n\t\t\t\tana_len = syn_len = max_step_len;\n\t\t\t\tif(tempo_ratio >= 1.0) {\n\t\t\t\t\tsyn_len = Math.round(ana_len / tempo_ratio);\n\t\t\t\t} else {\n\t\t\t\t\tana_len = Math.round(syn_len * tempo_ratio);\n\t\t\t\t}\n\t\t\t\tsyn_drift_per_step = (1.0 / tempo_ratio - 1.0 * syn_len / ana_len) * ana_len;\n\t\t\t\tgain_comp = compute_gain_comp(win,syn_len);\n\t\t\t\tchosen_tempo = tempo_ratio;\n\t\t\t\t//console.log(\"TEMPO CHANGE\",tempo_ratio,\"LENS\",ana_len,syn_len,\"GAIN\",gain_comp);\n\n\t\t\t\t// Handle book-keeping for time map\n\t\t\t\tvar lc = changes[changes.length-1];\n\t\t\t\tif (lc.out_time == out_time) // no samples since last change\n\t\t\t\t\tlc.tempo = tempo_ratio; // Just replace last change event\n\t\t\t\telse //add new entry\n\t\t\t\t\tchanges.push({ \n\t\t\t\t\t\tin_time: in_time, out_time: out_time,\n\t\t\t\t\t\ttempo: tempo_ratio\n\t\t\t\t\t})\n\t\t\t};\n\n\t\t\tobj['flush'](0); obj['setTempo'](chosen_tempo);\n\n\n\t\t\t/**************************\n\t\t\t* Small utility functions\n\t\t\t**************************/\n\t\t\t\n\t\t\t// Estimate the phase at (fractional) fft bin ind\n\t\t\tvar interpolate_phase = function(re,im,ind) {\n\t\t\t\tvar i = Math.floor(ind);\n\t\t\t\tvar sgn = i % 2 == 1 ? -1.0 : 1.0;\n\t\t\t\treturn Math.atan2(sgn * (im[i] - im[i + 1]),sgn * (re[i] - re[i + 1]));\n\t\t\t};\n\n\t\t\t// Get ang between -PI and PI\n\t\t\tvar unwrap = function(ang) {\n\t\t\t\treturn ang - 2 * Math.PI * Math.round(ang / (2 * Math.PI) );\n\t\t\t};\n\n\t\t\t// Try to estimate the phase change if window lengths differ by ratio\n\t\t\tvar estimate_phase_change = function(ang,k,pang,pk,ratio) {\n\t\t\t\tvar pred = 2 * Math.PI / windowSize * 0.5 * (pk + k) * ana_len;\n\t\t\t\tvar ywang = unwrap(ang - pang - pred);\n\n\t\t\t\treturn (ywang + pred) * ratio;\n\t\t\t};\n\n\t\t\t/**************************\n\t\t\t* Find peaks of spectrum\n\t\t\t**************************/\n\n\t\t\tvar find_rpeaks = function(mags,res) {\n\n\t\t\t\tvar max = 0; for(var i=0;i<mags.length;i++) if (mags[i]>max) max=mags[i];\n\t\t\t\tvar thresh = MAX_PEAK_RATIO * max;\n\n\t\t\t\tvar n_peaks = 1, prev_pi = 1; res[0] = 1.0;\n\t\t\t\tfor(var i=2;i<mags.length;i++) {\n\t\t\t\t\tvar f_delta = i * MAX_PEAK_JUMP;\n\t\t\t\t\tif(mags[i]>thresh && mags[i] > mags[i - 1] && mags[i] >= mags[i + 1]) { // Is local peak\n\n\t\t\t\t\t\t// Use quadratic interpolation to fine-tune the peak location\n\t\t\t\t\t\tvar ppos = i + (mags[i - 1] - mags[i + 1]) / (2 * (mags[i - 1] - 2 * mags[i] + mags[i + 1]));\n\n\t\t\t\t\t\t// If far enough from previous peak, add to list\n\t\t\t\t\t\tif(ppos - res[n_peaks - 1] > f_delta) { res[n_peaks++] = ppos; prev_pi = i; }\n\t\t\t\t\t\t// Else, if not far enough, but higher than previous, just replace prev \n\t\t\t\t\t\telse if(mags[i] > mags[prev_pi]) { res[n_peaks - 1] = ppos;\tprev_pi = i; }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn n_peaks;\n\t\t\t};\n\n\t\t\t/**************************\n\t\t\t* Rigid phase shift\n\t\t\t**************************/\n\n\t\t\tvar pshift_rigid = function(frame_ind,re,im,p_re,p_im,ratio) {\n\t\t\t\tvar CUR = frame_ind % 2, PREV = 1 - CUR;\n\n\t\t\t\tvar prev_mags = b_mags[PREV];\n\n\t\t\t\tvar prev_np = b_npeaks[PREV], prpeaks = b_peaks[PREV];\n\t\t\t\tvar prev_in_angs = b_in_angs[PREV], prev_peak_adeltas = b_peak_adeltas[PREV];\n\n\t\t\t\t// Calc new mags\n\t\t\t\tvar mags = b_mags[CUR];\n\t\t\t\tfor(var i=1;i<mags.length;i++) mags[i] = re[i] * re[i] + im[i] * im[i];\n\t\t\t\n\t\t\t\t// Find new peaks\n\t\t\t\tvar peaks = b_peaks[CUR];\n\t\t\t\tvar cur_np = b_npeaks[CUR] = find_rpeaks(mags,peaks);\n\n\t\t\t\t// Start adjusting angles\n\t\t\t\tvar cur_in_angs = b_in_angs[CUR], cur_peak_adeltas = b_peak_adeltas[CUR];\n\n\t\t\t\tif(frame_ind == 0 || cur_np == 0) { // If first frame (or no peaks)\n\n\t\t\t\t\t// Set out_ang = in_ang for all peaks\n\t\t\t\t\tfor(var ci=0;ci<cur_np;ci++) {\n\t\t\t\t\t\tvar pci = peaks[ci];\n\t\t\t\t\t\tprev_in_angs[ci] = prev_peak_adeltas[ci] = interpolate_phase(re,im,pci);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t    /*********************************************************\n\t\t    \t* Match old peaks with new ones\n\t\t    \t* Also find where pmag*mag is max for next step\n\t\t    \t*********************************************************/\n\n\t\t\t\tvar pi = 0;\n\t\t\t\tfor(var ci=0;ci<cur_np;ci++) {\n\t\t\t\t\tvar pci = peaks[ci];\n\n\t\t\t\t\t// Scroll so peaks[ci] is between prpeaks[pi] and prpeaks[pi+1]\n\t\t\t\t\twhile(peaks[ci] > prpeaks[pi] && pi != prev_np) ++pi;\n\n\t\t\t\t\tvar cpi = pi;\n\t\t\t\t\tif(pi > 0 && pci - prpeaks[pi - 1] < prpeaks[pi] - pci) cpi = pi - 1;\n\n\t\t\t\t\tvar peak_delta = pci * MAX_PEAK_JUMP;\n\t\t\t\t\tif(Math.abs(prpeaks[cpi] - pci) < peak_delta && \n\t\t\t\t\t\tprev_mags[Math.round(prpeaks[cpi])] > \n\t\t\t\t\t\t\tMATCH_MAG_THRESH * mags[Math.round(pci)]) {\n\n\t\t\t\t\t\t// Found a matching peak in previous frame, so predict based on the diff\n\t\t\t\t\t\tvar in_angle = interpolate_phase(re,im,pci);\n\t\t\t\t\t\tvar out_angle = prev_in_angs[cpi] + prev_peak_adeltas[cpi] +\n\t\t\t\t\t\t\t\testimate_phase_change(in_angle,pci,prev_in_angs[cpi],prpeaks[cpi],ratio);\n\n\t\t\t\t\t\tvar delta = out_angle - in_angle;\n\t\t\t\t\t\tcur_in_angs[ci] = in_angle; cur_peak_adeltas[ci] = delta;\n\t\t\t\t\t\tpeaks_re[ci] = Math.cos(delta);\tpeaks_im[ci] = Math.sin(delta);\n\t\t\t\t\t} else { // Not matched - use the same phase as input\n\t\t\t\t\t\tcur_in_angs[ci] = interpolate_phase(re,im,pci);\n\t\t\t\t\t\tcur_peak_adeltas[ci] = 0; peaks_re[ci] = 1.0;\tpeaks_im[ci] = 0.0;\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t    /********************************************************\n\t\t\t    * Adjust phase of all bins based on closest peak\n\t\t\t    *********************************************************/\n\n\t\t\t    // Add a \"dummy\" peak at the end of array\n\t\t\t\tpeaks[cur_np] = 2 * windowSize;\n\t\t\t\t\n\t\t\t\tvar cpi = 0, cp = peaks[cpi], cnp = peaks[cpi + 1];\n\t\t\t\tvar cre = peaks_re[cpi], cim = peaks_im[cpi];\n\n\t\t\t\tfor(var i=1;i<re.length-1;i++) {\n\t\t\t\t\tif(i >= cp && i - cp > cnp - i) {\n\t\t\t\t\t\t++cpi; cp = peaks[cpi];\tcnp = peaks[cpi + 1];\n\t\t\t\t\t\tcre = peaks_re[cpi]; cim = peaks_im[cpi];\n\t\t\t\t\t}\n\n\t\t\t\t\tvar nre = re[i] * cre - im[i] * cim;\n\t\t\t\t\tvar nim = re[i] * cim + im[i] * cre;\n\t\t\t\t\tre[i] = nre; im[i] = nim;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/***********************************\n\t\t\t* Perform two syn/ana steps \n\t\t\t*\t(using the two-for-one fft trick)\n\t\t  \t* Takes windowSize + ana_len samples from in_buffer\n\t\t  \t*   and shifts in_buffer back by 2*ana_len\n\t\t  \t* Outputs <retval> samples to out_buffer\n\t\t\t***********************************/\n\n\t\t\tvar two_steps = function() {\n\n\t\t\t\t// To better match the given ratio,\n\t\t    \t// occasionally tweak syn_len by 1 or 2\n\t\t\t\tsyn_drift += 2 * syn_drift_per_step;\n\t\t\t\tvar sdelta = syn_drift | 0;\n\t\t\t\tsyn_drift -= sdelta;\n\t\t\t\t\n\t\t\t\t// Pack two steps into fft object\n\t\t\t\tfor(var i=0;i<windowSize;i++) {\n\t\t\t\t\tfft.m_re[i] = win[i] * in_buffer[i];\n\t\t\t\t\tfft.m_im[i] = win[i] * in_buffer[ana_len + i];\n\t\t\t\t}\n\n\t\t\t\t// Shift in_buffer back by 2*ana_len\n\t\t\t\tVH.blit(in_buffer,2*ana_len,\n\t\t            in_buffer,0,windowSize-ana_len);\n\n\t\t\t\t// Run the fft\n\t\t\t\tfft.inplace(false);\n\t\t\t\tfft.unpack(re1,im1,re2,im2);\n\n\t\t\t\t// Step 1 - move by syn_len\n\t\t\t\tvar ratio1 = 1.0 * syn_len / ana_len;\n\t\t\t\tpshift_rigid(f_ind,re1,im1,pre2,pim2,ratio1);\n\n\t\t\t\t// Step 2 - move by syn_len+sdelta\n\t\t\t\tvar ratio2 = 1.0 * (syn_len + sdelta) / ana_len;\n\t\t\t\tpshift_rigid(f_ind + 1,re2,im2,re1,im1,ratio2);\n\n\t\t\t\t// Save (modified) re and im\n\t\t\t\tVH.blit(re2,0,pre2,0,hWS); VH.blit(im2,0,pim2,0,hWS);\n\n\t\t\t\t// Run ifft\n\t\t\t\tfft.repack(re1,im1,re2,im2);\n\t\t\t\tfft.inplace(true);\n\n\t\t\t\t// Shift out_buffer back by previous out_len;\n\t\t\t\tvar oblen = out_buffer.length;\n\t\t\t\tVH.blit(out_buffer,prev_out_len,\n\t\t            out_buffer,0,oblen-prev_out_len);\n\t\t\t\t\n\t\t\t\t// And shift in zeros at the end\n\t\t\t\tfor(var i=oblen-prev_out_len;i<oblen;i++) out_buffer[i] = 0.0;\n\t\t\t\t\n\t\t\t\t// Value overflow protection - scale the packet if max above a threshold\n\t\t\t    // The distortion this creates is insignificant compared to phase issues\n\t\t\t\tvar max = 0.0, gc = gain_comp;\n\t\t\t\tfor(var i=0;i<syn_len;i++)\n\t\t\t\t\tif(Math.abs(2 * fft.m_re[i]) > max)\n\t\t\t\t\t\tmax = Math.abs(2 * fft.m_re[i]);\n\t\t\t\tfor(var i=0;i<windowSize-syn_len;i++)\n\t\t\t\t\tif(Math.abs(fft.m_re[i + syn_len + sdelta] + fft.m_im[i]) > max)\n\t\t\t\t\t\tmax = Math.abs(fft.m_re[i + syn_len + sdelta] + fft.m_im[i]);\n\n\t\t\t\tfor(var i=windowSize-syn_len;i<windowSize;i++)\n\t\t\t\t\tif(Math.abs(2 * fft.m_im[i]) > max)\n\t\t\t\t\t\tmax = Math.abs(2 * fft.m_im[i]);\n\n\t\t\t\t// Find allowed ceiling of a two-step sum and lower gain if needed\n\t\t\t\tvar ceiling = 1.0 / Math.floor(1.0 * windowSize / (2 * syn_len));\n\t\t\t\tif(gc * max > ceiling) {\n\t\t\t\t\t//console.log(\"Gain overflow, lowering volume: \",ceiling / max,gc,max);\n\t\t\t\t\tgc = ceiling / max;\n\t\t\t\t}\n\n\t\t\t\t// Write results to out_buffer\n\t\t\t\tfor(var i=0;i<windowSize;i++) {\n\t\t\t\t\tout_buffer[i] += gc * fft.m_re[i];\n\t\t\t\t\tout_buffer[i + syn_len + sdelta] += gc * fft.m_im[i];\n\t\t\t\t}\n\n\t\t\t\tf_ind += 2;\tprev_out_len = 2 * syn_len + sdelta;\n\n\t\t\t\treturn prev_out_len;\n\t\t\t}\n\n\t\t\t// input: array of channels, each a float_array with unbounded amount of samples\n\t\t\t// output: same format\n\t\t\tobj['process'] = function(in_ar) {\n\n\t\t\t\tvar in_len = in_ar[0].length;\n\n\t\t\t\t// Mix channels together (if needed)\n\t\t\t\tvar mix = in_ar[0]; \n\t\t\t\tif (in_ar.length>1) {\n\t\t\t\t\tmix = VH.float_array(in_ar[0].length);\n\t\t\t\t\tvar mult = 1.0/in_ar.length;\n\t\t\t\t\tfor(var c=0;c<in_ar.length;c++)\n\t\t\t\t\t\tfor(var i=0;i<in_len;i++)\n\t\t\t\t\t\t\tmix[i] += mult*in_ar[c][i];\n\t\t\t\t}\n\n\t\t\t\t// Handle the special case of no tempo change\n\t\t\t\tif (chosen_tempo == 1.0) {\n\n\t\t\t\t\t// Empty out_buffer followed by in_buffer, if they are not empty\n\t\t\t\t\tif (unused_in_outbuf+inbuffer_contains>0) {\n\t\t\t\t\t\tvar n_len = unused_in_outbuf + inbuffer_contains + in_len;\n\t\t\t\t\t\tvar n_ar = [];\n\t\t\t\t\t\tfor(var c=0;c<in_ar.length;c++) { \n\t\t\t\t\t\t\tvar buf = VH.float_array(n_len);\n\t\t\t\t\t\t\tVH.blit(out_buffer,0,buf,0,unused_in_outbuf);\n\t\t\t\t\t\t\tVH.blit(in_buffer,0,buf,unused_in_outbuf,inbuffer_contains);\n\t\t\t\t\t\t\tVH.blit(in_ar[c],0,buf,unused_in_outbuf+inbuffer_contains,in_len);\n\t\t\t\t\t\t\tn_ar.push(buf);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tobj['flush'](0);\n\t\t\t\t\t\tin_len = n_len; in_ar = n_ar;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Move time pointers\n\t\t\t\t\tin_time += in_len/sampleRate; out_time += in_len/sampleRate;\n\n\t\t\t\t\t// Just return the same samples as were given as input\n\t\t\t\t\treturn in_ar;\n\t\t\t\t}\n\n\t\t\t\t// Calculate output length\n\t\t\t\t// Should underestimate, and by no more than 4, which can easily fit in the unused_in_outbuf\n\t\t\t\tvar consumable_samples = inbuffer_contains + in_len - (windowSize - ana_len);\n\t\t\t\tvar n_steps = 2*Math.floor(Math.max(0,consumable_samples)/(2*ana_len));\n\t\t\t\tvar out_len = unused_in_outbuf + syn_len*n_steps +\n\t\t\t\t\t\t\t\tMath.floor(syn_drift+syn_drift_per_step*n_steps);\n\n\t\t\t\tif (unused_in_outbuf>out_len) out_len = unused_in_outbuf;\n\n\t\t\t\t// Allocate output\n\t\t\t\tvar outp = VH.float_array(out_len);\n\n\t\t\t\t// Copy previously unused but ready values to output\n\t\t\t\tVH.blit(out_buffer,0,outp,0,unused_in_outbuf); \n\t\t\t\tvar ii = 0, oi = unused_in_outbuf;\n\t\t\t\t\n\t\t\t\tvar left_over = 0, res_len = 0;\n\t\t\t\twhile(true) {\n\n\t\t\t\t\t// Calculate how many new samples we need to call two_steps\n\t\t\t\t\tvar n_needed = windowSize + ana_len - inbuffer_contains;\n\t\t\t\t\t\n\t\t\t\t\tif (ii+n_needed>in_len) { // Not enough samples for next step\n\t\t\t\t\t\t// Copy whats left to inbuffer and break out of the loop\n\t\t\t\t\t\tVH.blit(mix,ii,in_buffer,inbuffer_contains,in_len-ii);\n\t\t\t\t\t\tinbuffer_contains += in_len-ii; ii = in_len;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (n_needed <= 0) // Already enough - can happen if tempo changed\n\t\t\t\t\t\tinbuffer_contains -= 2 * ana_len; \n\t\t\t\t\telse { // Main case - we have enough\n\t\t\t\t\t\t// Copy over this many samples from input\n\t\t\t\t\t\tVH.blit(mix,ii,in_buffer,inbuffer_contains,n_needed);\n\t\t\t\t\t\tii += n_needed;\t\t\t\t\t\n\t\t\t\t\t\tinbuffer_contains = windowSize - ana_len;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Invariant: left_over should be 0 here as it should break!\n\n\t\t\t\t\t// Run the vocoder\n\t\t\t\t\tres_len = two_steps();\n\n\t\t\t\t\t// Move time pointers\n\t\t\t\t\tin_time += 2*ana_len/sampleRate; out_time += res_len/sampleRate;\n\n\t\t\t\t\t// Calculate how many samples are left over (usually 0)\n\t\t\t\t\tleft_over = oi + res_len - out_len; if(left_over < 0) left_over = 0;\n\n\t\t\t\t\t// Copy fully ready samples out\n\t\t\t        VH.blit(out_buffer,0,outp,oi,res_len-left_over);\n\n\t\t\t\t\toi += res_len;\n\t\t\t\t}\n\n\t\t\t\t// Copy left over samples to the beginning of out_buffer\n\t  \t\t\tVH.blit(out_buffer,res_len-left_over,out_buffer,0,left_over);\n\t  \t\t\tunused_in_outbuf = left_over;\n\n\t  \t\t\t//////////////////////// DONE\n\n\t\t\t\t// Clone the result to match the number of input channels\n\t\t\t\tvar out_ar = [];\n\t\t\t\tfor(var c=0;c<in_ar.length;c++) out_ar.push(outp);\n\n\t\t\t\treturn out_ar;\n\t\t\t};\n\n\t\t\treturn obj;\n\t\t};\n\n\t\t/** @export */\n\t\tmodule.exports = AudioTempoChanger;\n\t})();\n\n\n\t/***/ }),\n\t/* 2 */\n\t/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\n\t/*\n\t * Performs an in-place complex FFT.\n\t * Adapted from FFT for ActionScript 3 written by Gerald T. Beauregard \n\t * (original ActionScript3 version, http://gerrybeauregard.wordpress.com/2010/08/03/an-even-faster-as3-fft/)\n\t *\n\t * Copyright (c) 2015-2019 Margus Niitsoo\n\t */\n\n\tvar VH = __webpack_require__(0);\n\n\tvar FFT = function(logN) {\n\n\t\t// Size of the buffer\n\t\tvar m_N = 1 << logN;\n\n\n\t\tvar obj = {\n\t\t\tm_logN : logN, m_N : m_N,\n\t\t\tm_invN : 1.0 / m_N,\n\t\t\tm_re : VH.float_array(m_N),\n\t\t\tm_im : VH.float_array(m_N),\n\t\t\tm_revTgt : new Array(m_N)\n\t\t}\n\n\t\t// Calculate bit reversals\n\t\tfor(var k = 0; k<m_N; k++) {\n\t\t\tvar x = k, y = 0;\n\t\t\tfor(var i=0;i<logN;i++) {\n\t\t\t\ty <<= 1;\n\t\t\t\ty |= x & 1;\n\t\t\t\tx >>= 1;\n\t\t\t}\n\t\t\tobj.m_revTgt[k] = y;\n\t\t}\n\n\t    // Compute a multiplier factor for the \"twiddle factors\".\n\t    // The twiddle factors are complex unit vectors spaced at\n\t    // regular angular intervals. The angle by which the twiddle\n\t    // factor advances depends on the FFT stage. In many FFT\n\t    // implementations the twiddle factors are cached.\n\n\t\tobj.twiddleRe = VH.float_array(obj.m_logN);\n\t\tobj.twiddleIm = VH.float_array(obj.m_logN);\n\n\t\tvar wIndexStep = 1;\n\t\tfor(var stage = 0; stage<obj.m_logN; stage++) {\n\t\t\tvar wAngleInc = 2.0 * wIndexStep * Math.PI * obj.m_invN;\n\t\t\tobj.twiddleRe[stage] = Math.cos(wAngleInc);\n\t\t\tobj.twiddleIm[stage] = Math.sin(wAngleInc);\n\t\t\twIndexStep <<= 1;\n\t\t}\n\n\t\t// In-place FFT function\n\t\tobj.inplace = function(inverse) {\n\n\t\t\tvar m_re = obj.m_re, m_im = obj.m_im;\n\t\t\tvar m_N = obj.m_N, m_logN = obj.m_logN;\n\n\t\t\tvar numFlies = m_N >> 1;\n\t\t\tvar span = m_N >> 1;\n\t\t\tvar spacing = m_N;\n\n\t\t\tif(inverse) {\n\t\t\t\tvar m_invN = 1.0/m_N;\n\t\t\t\tfor(var i=0; i<m_N; i++) {\n\t\t\t\t\tm_re[i] *= m_invN;\n\t\t\t\t\tm_im[i] *= m_invN;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// For each stage of the FFT\n\t\t\tfor(var stage=0; stage<m_logN; stage++) {\n\t\t\t\tvar wMulRe = obj.twiddleRe[stage];\n\t\t\t\tvar wMulIm = obj.twiddleIm[stage];\n\t\t\t\tif(!inverse) wMulIm *= -1;\n\n\t\t\t\tvar start = 0;\n\t\t\t\twhile(start < m_N) {\n\t\t\t\t\tvar iTop = start, iBot = start + span;\n\t\t\t\t\tvar wRe = 1.0, wIm = 0.0;\n\n\t\t\t\t\t// For each butterfly in this stage\n\t\t\t\t\tfor(var flyCount=0; flyCount<numFlies; flyCount++) {\n\t\t\t\t\t\t// Get the top & bottom values\n\t\t\t\t\t\tvar xTopRe = m_re[iTop];\n\t\t\t\t\t\tvar xTopIm = m_im[iTop];\n\t\t\t\t\t\tvar xBotRe = m_re[iBot];\n\t\t\t\t\t\tvar xBotIm = m_im[iBot];\n\n\t\t\t\t\t\t// Top branch of butterfly has addition\n\t\t\t\t\t\tm_re[iTop] = xTopRe + xBotRe;\n\t\t\t\t\t\tm_im[iTop] = xTopIm + xBotIm;\n\n\t\t\t\t\t\t// Bottom branch of butterly has subtraction,\n\t                    // followed by multiplication by twiddle factor\n\t\t\t\t\t\txBotRe = xTopRe - xBotRe;\n\t\t\t\t\t\txBotIm = xTopIm - xBotIm;\n\n\t\t\t\t\t\tm_re[iBot] = xBotRe * wRe - xBotIm * wIm;\n\t\t\t\t\t\tm_im[iBot] = xBotRe * wIm + xBotIm * wRe;\n\n\t\t\t\t\t\t// Advance butterfly to next top & bottom positions\n\t                    iTop++;\n\t                    iBot++;\n\n\t                    // Update the twiddle factor, via complex multiply\n\t                    // by unit vector with the appropriate angle\n\t                    // (wRe + j wIm) = (wRe + j wIm) x (wMulRe + j wMulIm)\n\t\t\t\t\t\tvar tRe = wRe;\n\t\t\t\t\t\twRe = wRe * wMulRe - wIm * wMulIm;\n\t\t\t\t\t\twIm = tRe * wMulIm + wIm * wMulRe;\n\t\t\t\t\t}\n\t\t\t\t\tstart += spacing;\n\t\t\t\t}\n\t\t\t\tnumFlies >>= 1;\n\t\t\t\tspan >>= 1;\n\t\t\t\tspacing >>= 1;\n\t\t\t}\n\n\t\t\tvar revI, buf, m_revTgt = obj.m_revTgt;\n\t\t\tfor(var i1=0; i1<m_N; i1++)\n\t\t\t\tif(m_revTgt[i1] > i1) {\n\t                // Bit-Reversal is an involution i.e.\n\t                // x.revTgt.revTgt==x\n\t                // So switching values around\n\t                // restores the original order\n\t\t\t\t\trevI = m_revTgt[i1];\n\t\t\t\t\tbuf = m_re[revI];\n\t\t\t\t\tm_re[revI] = m_re[i1];\n\t\t\t\t\tm_re[i1] = buf;\n\t\t\t\t\tbuf = m_im[revI];\n\t\t\t\t\tm_im[revI] = m_im[i1];\n\t\t\t\t\tm_im[i1] = buf;\n\t\t\t\t}\n\t\t}\n\n\t\tvar m_N2 = m_N >> 1; // m_N/2 needed in un/repack below\n\n\t\t// Two-for-one trick for real-valued FFT:\n\t\t// Put one series in re, other in im, run \"inplace\",\n\t\t// then call this \"unpack\" function\n\t\tobj.unpack = function(rre,rim,ire,iim) {\n\t\t\trre[0] = obj.m_re[0]; ire[0] = obj.m_im[0];\n\t\t\trim[0] = iim[0] = 0;\n\t\t\trre[m_N2] = obj.m_re[m_N2];\n\t\t\tire[m_N2] = obj.m_im[m_N2];\n\t\t\trim[m_N2] = iim[m_N2] = 0;\n\t\t\tfor(var i = 1;i<m_N2;i++) {\n\t\t\t\trre[i] = (obj.m_re[i] + obj.m_re[m_N - i]) / 2;\n\t\t\t\trim[i] = (obj.m_im[i] - obj.m_im[m_N - i]) / 2;\n\t\t\t\tire[i] = (obj.m_im[i] + obj.m_im[m_N - i]) / 2;\n\t\t\t\tiim[i] = (-obj.m_re[i] + obj.m_re[m_N - i]) / 2;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// The two-for-one trick if you know results are real-valued\n\t\t// Call \"repack\", then fft.inplace(true) and you have\n\t\t// First fft in re and second in im\n\t\tobj.repack = function(rre,rim,ire,iim) {\n\t\t\tobj.m_re[0] = rre[0]; obj.m_im[0] = ire[0];\n\t\t\tobj.m_re[m_N2] = rre[m_N2]; obj.m_im[m_N2] = ire[m_N2];\n\t\t\tfor(var i = 1;i<m_N2;i++) {\n\t\t\t\tobj.m_re[i] = rre[i] - iim[i];\n\t\t\t\tobj.m_im[i] = rim[i] + ire[i];\n\t\t\t\tobj.m_re[m_N - i] = rre[i] + iim[i];\n\t\t\t\tobj.m_im[m_N - i] = -rim[i] + ire[i];\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t};\n\n\tmodule.exports = FFT;\n\n\t/***/ })\n\t/******/ ]);\n\t});\n\t//# sourceMappingURL=AudioTempoChanger.js.map\n\n/***/ })\n/******/ ])\n});\n;\n\n//# sourceURL=webpack://ogvjs/./node_modules/audio-feeder/dist/AudioFeeder.js?");

/***/ }),

/***/ "./node_modules/audio-feeder/dist/dynamicaudio.swf":
/*!*********************************************************!*\
  !*** ./node_modules/audio-feeder/dist/dynamicaudio.swf ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"dynamicaudio.swf?version=2c1ce3bfb7e6fa65c26d726a00017a94\";\n\n//# sourceURL=webpack://ogvjs/./node_modules/audio-feeder/dist/dynamicaudio.swf?");

/***/ }),

/***/ "./node_modules/es6-promise/dist/es6-promise.js":
/*!******************************************************!*\
  !*** ./node_modules/es6-promise/dist/es6-promise.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process, global) {/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE\n * @version   v4.2.5+7f2b526d\n */\n\n(function (global, factory) {\n\t true ? module.exports = factory() :\n\tundefined;\n}(this, (function () { 'use strict';\n\nfunction objectOrFunction(x) {\n  var type = typeof x;\n  return x !== null && (type === 'object' || type === 'function');\n}\n\nfunction isFunction(x) {\n  return typeof x === 'function';\n}\n\n\n\nvar _isArray = void 0;\nif (Array.isArray) {\n  _isArray = Array.isArray;\n} else {\n  _isArray = function (x) {\n    return Object.prototype.toString.call(x) === '[object Array]';\n  };\n}\n\nvar isArray = _isArray;\n\nvar len = 0;\nvar vertxNext = void 0;\nvar customSchedulerFn = void 0;\n\nvar asap = function asap(callback, arg) {\n  queue[len] = callback;\n  queue[len + 1] = arg;\n  len += 2;\n  if (len === 2) {\n    // If len is 2, that means that we need to schedule an async flush.\n    // If additional callbacks are queued before the queue is flushed, they\n    // will be processed by this flush that we are scheduling.\n    if (customSchedulerFn) {\n      customSchedulerFn(flush);\n    } else {\n      scheduleFlush();\n    }\n  }\n};\n\nfunction setScheduler(scheduleFn) {\n  customSchedulerFn = scheduleFn;\n}\n\nfunction setAsap(asapFn) {\n  asap = asapFn;\n}\n\nvar browserWindow = typeof window !== 'undefined' ? window : undefined;\nvar browserGlobal = browserWindow || {};\nvar BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\nvar isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\n// test for web worker but not in IE10\nvar isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';\n\n// node\nfunction useNextTick() {\n  // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n  // see https://github.com/cujojs/when/issues/410 for details\n  return function () {\n    return process.nextTick(flush);\n  };\n}\n\n// vertx\nfunction useVertxTimer() {\n  if (typeof vertxNext !== 'undefined') {\n    return function () {\n      vertxNext(flush);\n    };\n  }\n\n  return useSetTimeout();\n}\n\nfunction useMutationObserver() {\n  var iterations = 0;\n  var observer = new BrowserMutationObserver(flush);\n  var node = document.createTextNode('');\n  observer.observe(node, { characterData: true });\n\n  return function () {\n    node.data = iterations = ++iterations % 2;\n  };\n}\n\n// web worker\nfunction useMessageChannel() {\n  var channel = new MessageChannel();\n  channel.port1.onmessage = flush;\n  return function () {\n    return channel.port2.postMessage(0);\n  };\n}\n\nfunction useSetTimeout() {\n  // Store setTimeout reference so es6-promise will be unaffected by\n  // other code modifying setTimeout (like sinon.useFakeTimers())\n  var globalSetTimeout = setTimeout;\n  return function () {\n    return globalSetTimeout(flush, 1);\n  };\n}\n\nvar queue = new Array(1000);\nfunction flush() {\n  for (var i = 0; i < len; i += 2) {\n    var callback = queue[i];\n    var arg = queue[i + 1];\n\n    callback(arg);\n\n    queue[i] = undefined;\n    queue[i + 1] = undefined;\n  }\n\n  len = 0;\n}\n\nfunction attemptVertx() {\n  try {\n    var vertx = Function('return this')().require('vertx');\n    vertxNext = vertx.runOnLoop || vertx.runOnContext;\n    return useVertxTimer();\n  } catch (e) {\n    return useSetTimeout();\n  }\n}\n\nvar scheduleFlush = void 0;\n// Decide what async method to use to triggering processing of queued callbacks:\nif (isNode) {\n  scheduleFlush = useNextTick();\n} else if (BrowserMutationObserver) {\n  scheduleFlush = useMutationObserver();\n} else if (isWorker) {\n  scheduleFlush = useMessageChannel();\n} else if (browserWindow === undefined && \"function\" === 'function') {\n  scheduleFlush = attemptVertx();\n} else {\n  scheduleFlush = useSetTimeout();\n}\n\nfunction then(onFulfillment, onRejection) {\n  var parent = this;\n\n  var child = new this.constructor(noop);\n\n  if (child[PROMISE_ID] === undefined) {\n    makePromise(child);\n  }\n\n  var _state = parent._state;\n\n\n  if (_state) {\n    var callback = arguments[_state - 1];\n    asap(function () {\n      return invokeCallback(_state, child, callback, parent._result);\n    });\n  } else {\n    subscribe(parent, child, onFulfillment, onRejection);\n  }\n\n  return child;\n}\n\n/**\n  `Promise.resolve` returns a promise that will become resolved with the\n  passed `value`. It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    resolve(1);\n  });\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.resolve(1);\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  @method resolve\n  @static\n  @param {Any} value value that the returned promise will be resolved with\n  Useful for tooling.\n  @return {Promise} a promise that will become fulfilled with the given\n  `value`\n*/\nfunction resolve$1(object) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (object && typeof object === 'object' && object.constructor === Constructor) {\n    return object;\n  }\n\n  var promise = new Constructor(noop);\n  resolve(promise, object);\n  return promise;\n}\n\nvar PROMISE_ID = Math.random().toString(36).substring(2);\n\nfunction noop() {}\n\nvar PENDING = void 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\n\nvar TRY_CATCH_ERROR = { error: null };\n\nfunction selfFulfillment() {\n  return new TypeError(\"You cannot resolve a promise with itself\");\n}\n\nfunction cannotReturnOwn() {\n  return new TypeError('A promises callback cannot return that same promise.');\n}\n\nfunction getThen(promise) {\n  try {\n    return promise.then;\n  } catch (error) {\n    TRY_CATCH_ERROR.error = error;\n    return TRY_CATCH_ERROR;\n  }\n}\n\nfunction tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {\n  try {\n    then$$1.call(value, fulfillmentHandler, rejectionHandler);\n  } catch (e) {\n    return e;\n  }\n}\n\nfunction handleForeignThenable(promise, thenable, then$$1) {\n  asap(function (promise) {\n    var sealed = false;\n    var error = tryThen(then$$1, thenable, function (value) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n      if (thenable !== value) {\n        resolve(promise, value);\n      } else {\n        fulfill(promise, value);\n      }\n    }, function (reason) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n\n      reject(promise, reason);\n    }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n    if (!sealed && error) {\n      sealed = true;\n      reject(promise, error);\n    }\n  }, promise);\n}\n\nfunction handleOwnThenable(promise, thenable) {\n  if (thenable._state === FULFILLED) {\n    fulfill(promise, thenable._result);\n  } else if (thenable._state === REJECTED) {\n    reject(promise, thenable._result);\n  } else {\n    subscribe(thenable, undefined, function (value) {\n      return resolve(promise, value);\n    }, function (reason) {\n      return reject(promise, reason);\n    });\n  }\n}\n\nfunction handleMaybeThenable(promise, maybeThenable, then$$1) {\n  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {\n    handleOwnThenable(promise, maybeThenable);\n  } else {\n    if (then$$1 === TRY_CATCH_ERROR) {\n      reject(promise, TRY_CATCH_ERROR.error);\n      TRY_CATCH_ERROR.error = null;\n    } else if (then$$1 === undefined) {\n      fulfill(promise, maybeThenable);\n    } else if (isFunction(then$$1)) {\n      handleForeignThenable(promise, maybeThenable, then$$1);\n    } else {\n      fulfill(promise, maybeThenable);\n    }\n  }\n}\n\nfunction resolve(promise, value) {\n  if (promise === value) {\n    reject(promise, selfFulfillment());\n  } else if (objectOrFunction(value)) {\n    handleMaybeThenable(promise, value, getThen(value));\n  } else {\n    fulfill(promise, value);\n  }\n}\n\nfunction publishRejection(promise) {\n  if (promise._onerror) {\n    promise._onerror(promise._result);\n  }\n\n  publish(promise);\n}\n\nfunction fulfill(promise, value) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n\n  promise._result = value;\n  promise._state = FULFILLED;\n\n  if (promise._subscribers.length !== 0) {\n    asap(publish, promise);\n  }\n}\n\nfunction reject(promise, reason) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n  promise._state = REJECTED;\n  promise._result = reason;\n\n  asap(publishRejection, promise);\n}\n\nfunction subscribe(parent, child, onFulfillment, onRejection) {\n  var _subscribers = parent._subscribers;\n  var length = _subscribers.length;\n\n\n  parent._onerror = null;\n\n  _subscribers[length] = child;\n  _subscribers[length + FULFILLED] = onFulfillment;\n  _subscribers[length + REJECTED] = onRejection;\n\n  if (length === 0 && parent._state) {\n    asap(publish, parent);\n  }\n}\n\nfunction publish(promise) {\n  var subscribers = promise._subscribers;\n  var settled = promise._state;\n\n  if (subscribers.length === 0) {\n    return;\n  }\n\n  var child = void 0,\n      callback = void 0,\n      detail = promise._result;\n\n  for (var i = 0; i < subscribers.length; i += 3) {\n    child = subscribers[i];\n    callback = subscribers[i + settled];\n\n    if (child) {\n      invokeCallback(settled, child, callback, detail);\n    } else {\n      callback(detail);\n    }\n  }\n\n  promise._subscribers.length = 0;\n}\n\nfunction tryCatch(callback, detail) {\n  try {\n    return callback(detail);\n  } catch (e) {\n    TRY_CATCH_ERROR.error = e;\n    return TRY_CATCH_ERROR;\n  }\n}\n\nfunction invokeCallback(settled, promise, callback, detail) {\n  var hasCallback = isFunction(callback),\n      value = void 0,\n      error = void 0,\n      succeeded = void 0,\n      failed = void 0;\n\n  if (hasCallback) {\n    value = tryCatch(callback, detail);\n\n    if (value === TRY_CATCH_ERROR) {\n      failed = true;\n      error = value.error;\n      value.error = null;\n    } else {\n      succeeded = true;\n    }\n\n    if (promise === value) {\n      reject(promise, cannotReturnOwn());\n      return;\n    }\n  } else {\n    value = detail;\n    succeeded = true;\n  }\n\n  if (promise._state !== PENDING) {\n    // noop\n  } else if (hasCallback && succeeded) {\n    resolve(promise, value);\n  } else if (failed) {\n    reject(promise, error);\n  } else if (settled === FULFILLED) {\n    fulfill(promise, value);\n  } else if (settled === REJECTED) {\n    reject(promise, value);\n  }\n}\n\nfunction initializePromise(promise, resolver) {\n  try {\n    resolver(function resolvePromise(value) {\n      resolve(promise, value);\n    }, function rejectPromise(reason) {\n      reject(promise, reason);\n    });\n  } catch (e) {\n    reject(promise, e);\n  }\n}\n\nvar id = 0;\nfunction nextId() {\n  return id++;\n}\n\nfunction makePromise(promise) {\n  promise[PROMISE_ID] = id++;\n  promise._state = undefined;\n  promise._result = undefined;\n  promise._subscribers = [];\n}\n\nfunction validationError() {\n  return new Error('Array Methods must be provided an Array');\n}\n\nvar Enumerator = function () {\n  function Enumerator(Constructor, input) {\n    this._instanceConstructor = Constructor;\n    this.promise = new Constructor(noop);\n\n    if (!this.promise[PROMISE_ID]) {\n      makePromise(this.promise);\n    }\n\n    if (isArray(input)) {\n      this.length = input.length;\n      this._remaining = input.length;\n\n      this._result = new Array(this.length);\n\n      if (this.length === 0) {\n        fulfill(this.promise, this._result);\n      } else {\n        this.length = this.length || 0;\n        this._enumerate(input);\n        if (this._remaining === 0) {\n          fulfill(this.promise, this._result);\n        }\n      }\n    } else {\n      reject(this.promise, validationError());\n    }\n  }\n\n  Enumerator.prototype._enumerate = function _enumerate(input) {\n    for (var i = 0; this._state === PENDING && i < input.length; i++) {\n      this._eachEntry(input[i], i);\n    }\n  };\n\n  Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {\n    var c = this._instanceConstructor;\n    var resolve$$1 = c.resolve;\n\n\n    if (resolve$$1 === resolve$1) {\n      var _then = getThen(entry);\n\n      if (_then === then && entry._state !== PENDING) {\n        this._settledAt(entry._state, i, entry._result);\n      } else if (typeof _then !== 'function') {\n        this._remaining--;\n        this._result[i] = entry;\n      } else if (c === Promise$1) {\n        var promise = new c(noop);\n        handleMaybeThenable(promise, entry, _then);\n        this._willSettleAt(promise, i);\n      } else {\n        this._willSettleAt(new c(function (resolve$$1) {\n          return resolve$$1(entry);\n        }), i);\n      }\n    } else {\n      this._willSettleAt(resolve$$1(entry), i);\n    }\n  };\n\n  Enumerator.prototype._settledAt = function _settledAt(state, i, value) {\n    var promise = this.promise;\n\n\n    if (promise._state === PENDING) {\n      this._remaining--;\n\n      if (state === REJECTED) {\n        reject(promise, value);\n      } else {\n        this._result[i] = value;\n      }\n    }\n\n    if (this._remaining === 0) {\n      fulfill(promise, this._result);\n    }\n  };\n\n  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {\n    var enumerator = this;\n\n    subscribe(promise, undefined, function (value) {\n      return enumerator._settledAt(FULFILLED, i, value);\n    }, function (reason) {\n      return enumerator._settledAt(REJECTED, i, reason);\n    });\n  };\n\n  return Enumerator;\n}();\n\n/**\n  `Promise.all` accepts an array of promises, and returns a new promise which\n  is fulfilled with an array of fulfillment values for the passed promises, or\n  rejected with the reason of the first passed promise to be rejected. It casts all\n  elements of the passed iterable to promises as it runs this algorithm.\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = resolve(2);\n  let promise3 = resolve(3);\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // The array here would be [ 1, 2, 3 ];\n  });\n  ```\n\n  If any of the `promises` given to `all` are rejected, the first promise\n  that is rejected will be given as an argument to the returned promises's\n  rejection handler. For example:\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = reject(new Error(\"2\"));\n  let promise3 = reject(new Error(\"3\"));\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // Code here never runs because there are rejected promises!\n  }, function(error) {\n    // error.message === \"2\"\n  });\n  ```\n\n  @method all\n  @static\n  @param {Array} entries array of promises\n  @param {String} label optional string for labeling the promise.\n  Useful for tooling.\n  @return {Promise} promise that is fulfilled when all `promises` have been\n  fulfilled, or rejected if any of them become rejected.\n  @static\n*/\nfunction all(entries) {\n  return new Enumerator(this, entries).promise;\n}\n\n/**\n  `Promise.race` returns a new promise which is settled in the same way as the\n  first passed promise to settle.\n\n  Example:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 2');\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // result === 'promise 2' because it was resolved before promise1\n    // was resolved.\n  });\n  ```\n\n  `Promise.race` is deterministic in that only the state of the first\n  settled promise matters. For example, even if other promises given to the\n  `promises` array argument are resolved, but the first settled promise has\n  become rejected before the other promises became fulfilled, the returned\n  promise will become rejected:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      reject(new Error('promise 2'));\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // Code here never runs\n  }, function(reason){\n    // reason.message === 'promise 2' because promise 2 became rejected before\n    // promise 1 became fulfilled\n  });\n  ```\n\n  An example real-world use case is implementing timeouts:\n\n  ```javascript\n  Promise.race([ajax('foo.json'), timeout(5000)])\n  ```\n\n  @method race\n  @static\n  @param {Array} promises array of promises to observe\n  Useful for tooling.\n  @return {Promise} a promise which settles in the same way as the first passed\n  promise to settle.\n*/\nfunction race(entries) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (!isArray(entries)) {\n    return new Constructor(function (_, reject) {\n      return reject(new TypeError('You must pass an array to race.'));\n    });\n  } else {\n    return new Constructor(function (resolve, reject) {\n      var length = entries.length;\n      for (var i = 0; i < length; i++) {\n        Constructor.resolve(entries[i]).then(resolve, reject);\n      }\n    });\n  }\n}\n\n/**\n  `Promise.reject` returns a promise rejected with the passed `reason`.\n  It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    reject(new Error('WHOOPS'));\n  });\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.reject(new Error('WHOOPS'));\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  @method reject\n  @static\n  @param {Any} reason value that the returned promise will be rejected with.\n  Useful for tooling.\n  @return {Promise} a promise rejected with the given `reason`.\n*/\nfunction reject$1(reason) {\n  /*jshint validthis:true */\n  var Constructor = this;\n  var promise = new Constructor(noop);\n  reject(promise, reason);\n  return promise;\n}\n\nfunction needsResolver() {\n  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n}\n\nfunction needsNew() {\n  throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n}\n\n/**\n  Promise objects represent the eventual result of an asynchronous operation. The\n  primary way of interacting with a promise is through its `then` method, which\n  registers callbacks to receive either a promise's eventual value or the reason\n  why the promise cannot be fulfilled.\n\n  Terminology\n  -----------\n\n  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n  - `thenable` is an object or function that defines a `then` method.\n  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n  - `exception` is a value that is thrown using the throw statement.\n  - `reason` is a value that indicates why a promise was rejected.\n  - `settled` the final resting state of a promise, fulfilled or rejected.\n\n  A promise can be in one of three states: pending, fulfilled, or rejected.\n\n  Promises that are fulfilled have a fulfillment value and are in the fulfilled\n  state.  Promises that are rejected have a rejection reason and are in the\n  rejected state.  A fulfillment value is never a thenable.\n\n  Promises can also be said to *resolve* a value.  If this value is also a\n  promise, then the original promise's settled state will match the value's\n  settled state.  So a promise that *resolves* a promise that rejects will\n  itself reject, and a promise that *resolves* a promise that fulfills will\n  itself fulfill.\n\n\n  Basic Usage:\n  ------------\n\n  ```js\n  let promise = new Promise(function(resolve, reject) {\n    // on success\n    resolve(value);\n\n    // on failure\n    reject(reason);\n  });\n\n  promise.then(function(value) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Advanced Usage:\n  ---------------\n\n  Promises shine when abstracting away asynchronous interactions such as\n  `XMLHttpRequest`s.\n\n  ```js\n  function getJSON(url) {\n    return new Promise(function(resolve, reject){\n      let xhr = new XMLHttpRequest();\n\n      xhr.open('GET', url);\n      xhr.onreadystatechange = handler;\n      xhr.responseType = 'json';\n      xhr.setRequestHeader('Accept', 'application/json');\n      xhr.send();\n\n      function handler() {\n        if (this.readyState === this.DONE) {\n          if (this.status === 200) {\n            resolve(this.response);\n          } else {\n            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n          }\n        }\n      };\n    });\n  }\n\n  getJSON('/posts.json').then(function(json) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Unlike callbacks, promises are great composable primitives.\n\n  ```js\n  Promise.all([\n    getJSON('/posts'),\n    getJSON('/comments')\n  ]).then(function(values){\n    values[0] // => postsJSON\n    values[1] // => commentsJSON\n\n    return values;\n  });\n  ```\n\n  @class Promise\n  @param {Function} resolver\n  Useful for tooling.\n  @constructor\n*/\n\nvar Promise$1 = function () {\n  function Promise(resolver) {\n    this[PROMISE_ID] = nextId();\n    this._result = this._state = undefined;\n    this._subscribers = [];\n\n    if (noop !== resolver) {\n      typeof resolver !== 'function' && needsResolver();\n      this instanceof Promise ? initializePromise(this, resolver) : needsNew();\n    }\n  }\n\n  /**\n  The primary way of interacting with a promise is through its `then` method,\n  which registers callbacks to receive either a promise's eventual value or the\n  reason why the promise cannot be fulfilled.\n   ```js\n  findUser().then(function(user){\n    // user is available\n  }, function(reason){\n    // user is unavailable, and you are given the reason why\n  });\n  ```\n   Chaining\n  --------\n   The return value of `then` is itself a promise.  This second, 'downstream'\n  promise is resolved with the return value of the first promise's fulfillment\n  or rejection handler, or rejected if the handler throws an exception.\n   ```js\n  findUser().then(function (user) {\n    return user.name;\n  }, function (reason) {\n    return 'default name';\n  }).then(function (userName) {\n    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n    // will be `'default name'`\n  });\n   findUser().then(function (user) {\n    throw new Error('Found user, but still unhappy');\n  }, function (reason) {\n    throw new Error('`findUser` rejected and we're unhappy');\n  }).then(function (value) {\n    // never reached\n  }, function (reason) {\n    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n  });\n  ```\n  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n   ```js\n  findUser().then(function (user) {\n    throw new PedagogicalException('Upstream error');\n  }).then(function (value) {\n    // never reached\n  }).then(function (value) {\n    // never reached\n  }, function (reason) {\n    // The `PedgagocialException` is propagated all the way down to here\n  });\n  ```\n   Assimilation\n  ------------\n   Sometimes the value you want to propagate to a downstream promise can only be\n  retrieved asynchronously. This can be achieved by returning a promise in the\n  fulfillment or rejection handler. The downstream promise will then be pending\n  until the returned promise is settled. This is called *assimilation*.\n   ```js\n  findUser().then(function (user) {\n    return findCommentsByAuthor(user);\n  }).then(function (comments) {\n    // The user's comments are now available\n  });\n  ```\n   If the assimliated promise rejects, then the downstream promise will also reject.\n   ```js\n  findUser().then(function (user) {\n    return findCommentsByAuthor(user);\n  }).then(function (comments) {\n    // If `findCommentsByAuthor` fulfills, we'll have the value here\n  }, function (reason) {\n    // If `findCommentsByAuthor` rejects, we'll have the reason here\n  });\n  ```\n   Simple Example\n  --------------\n   Synchronous Example\n   ```javascript\n  let result;\n   try {\n    result = findResult();\n    // success\n  } catch(reason) {\n    // failure\n  }\n  ```\n   Errback Example\n   ```js\n  findResult(function(result, err){\n    if (err) {\n      // failure\n    } else {\n      // success\n    }\n  });\n  ```\n   Promise Example;\n   ```javascript\n  findResult().then(function(result){\n    // success\n  }, function(reason){\n    // failure\n  });\n  ```\n   Advanced Example\n  --------------\n   Synchronous Example\n   ```javascript\n  let author, books;\n   try {\n    author = findAuthor();\n    books  = findBooksByAuthor(author);\n    // success\n  } catch(reason) {\n    // failure\n  }\n  ```\n   Errback Example\n   ```js\n   function foundBooks(books) {\n   }\n   function failure(reason) {\n   }\n   findAuthor(function(author, err){\n    if (err) {\n      failure(err);\n      // failure\n    } else {\n      try {\n        findBoooksByAuthor(author, function(books, err) {\n          if (err) {\n            failure(err);\n          } else {\n            try {\n              foundBooks(books);\n            } catch(reason) {\n              failure(reason);\n            }\n          }\n        });\n      } catch(error) {\n        failure(err);\n      }\n      // success\n    }\n  });\n  ```\n   Promise Example;\n   ```javascript\n  findAuthor().\n    then(findBooksByAuthor).\n    then(function(books){\n      // found books\n  }).catch(function(reason){\n    // something went wrong\n  });\n  ```\n   @method then\n  @param {Function} onFulfilled\n  @param {Function} onRejected\n  Useful for tooling.\n  @return {Promise}\n  */\n\n  /**\n  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n  as the catch block of a try/catch statement.\n  ```js\n  function findAuthor(){\n  throw new Error('couldn't find that author');\n  }\n  // synchronous\n  try {\n  findAuthor();\n  } catch(reason) {\n  // something went wrong\n  }\n  // async with promises\n  findAuthor().catch(function(reason){\n  // something went wrong\n  });\n  ```\n  @method catch\n  @param {Function} onRejection\n  Useful for tooling.\n  @return {Promise}\n  */\n\n\n  Promise.prototype.catch = function _catch(onRejection) {\n    return this.then(null, onRejection);\n  };\n\n  /**\n    `finally` will be invoked regardless of the promise's fate just as native\n    try/catch/finally behaves\n  \n    Synchronous example:\n  \n    ```js\n    findAuthor() {\n      if (Math.random() > 0.5) {\n        throw new Error();\n      }\n      return new Author();\n    }\n  \n    try {\n      return findAuthor(); // succeed or fail\n    } catch(error) {\n      return findOtherAuther();\n    } finally {\n      // always runs\n      // doesn't affect the return value\n    }\n    ```\n  \n    Asynchronous example:\n  \n    ```js\n    findAuthor().catch(function(reason){\n      return findOtherAuther();\n    }).finally(function(){\n      // author was either found, or not\n    });\n    ```\n  \n    @method finally\n    @param {Function} callback\n    @return {Promise}\n  */\n\n\n  Promise.prototype.finally = function _finally(callback) {\n    var promise = this;\n    var constructor = promise.constructor;\n\n    if (isFunction(callback)) {\n      return promise.then(function (value) {\n        return constructor.resolve(callback()).then(function () {\n          return value;\n        });\n      }, function (reason) {\n        return constructor.resolve(callback()).then(function () {\n          throw reason;\n        });\n      });\n    }\n\n    return promise.then(callback, callback);\n  };\n\n  return Promise;\n}();\n\nPromise$1.prototype.then = then;\nPromise$1.all = all;\nPromise$1.race = race;\nPromise$1.resolve = resolve$1;\nPromise$1.reject = reject$1;\nPromise$1._setScheduler = setScheduler;\nPromise$1._setAsap = setAsap;\nPromise$1._asap = asap;\n\n/*global self*/\nfunction polyfill() {\n  var local = void 0;\n\n  if (typeof global !== 'undefined') {\n    local = global;\n  } else if (typeof self !== 'undefined') {\n    local = self;\n  } else {\n    try {\n      local = Function('return this')();\n    } catch (e) {\n      throw new Error('polyfill failed because global object is unavailable in this environment');\n    }\n  }\n\n  var P = local.Promise;\n\n  if (P) {\n    var promiseToString = null;\n    try {\n      promiseToString = Object.prototype.toString.call(P.resolve());\n    } catch (e) {\n      // silently ignored\n    }\n\n    if (promiseToString === '[object Promise]' && !P.cast) {\n      return;\n    }\n  }\n\n  local.Promise = Promise$1;\n}\n\n// Strange compat..\nPromise$1.polyfill = polyfill;\nPromise$1.Promise = Promise$1;\n\nreturn Promise$1;\n\n})));\n\n\n\n//# sourceMappingURL=es6-promise.map\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\"), __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://ogvjs/./node_modules/es6-promise/dist/es6-promise.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack://ogvjs/./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://ogvjs/./node_modules/setimmediate/setImmediate.js?");

/***/ }),

/***/ "./node_modules/stream-file/lib/backend/arraybuffer-backend.js":
/*!*********************************************************************!*\
  !*** ./node_modules/stream-file/lib/backend/arraybuffer-backend.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar DownloadBackend = __webpack_require__(/*! ./download-backend.js */ \"./node_modules/stream-file/lib/backend/download-backend.js\");\n\nvar type = 'arraybuffer';\n\nvar ArrayBufferBackend = function (_DownloadBackend) {\n  _inherits(ArrayBufferBackend, _DownloadBackend);\n\n  function ArrayBufferBackend() {\n    _classCallCheck(this, ArrayBufferBackend);\n\n    return _possibleConstructorReturn(this, (ArrayBufferBackend.__proto__ || Object.getPrototypeOf(ArrayBufferBackend)).apply(this, arguments));\n  }\n\n  _createClass(ArrayBufferBackend, [{\n    key: 'initXHR',\n    value: function initXHR() {\n      _get(ArrayBufferBackend.prototype.__proto__ || Object.getPrototypeOf(ArrayBufferBackend.prototype), 'initXHR', this).call(this);\n      this.xhr.responseType = type;\n    }\n  }, {\n    key: 'onXHRProgress',\n    value: function onXHRProgress() {\n      // no progressive download available. wait until the end.\n    }\n  }, {\n    key: 'onXHRLoad',\n    value: function onXHRLoad() {\n      var buf = this.xhr.response;\n      this.bytesRead += buf.byteLength;\n      this.emit('buffer', buf);\n\n      _get(ArrayBufferBackend.prototype.__proto__ || Object.getPrototypeOf(ArrayBufferBackend.prototype), 'onXHRLoad', this).call(this);\n    }\n  }]);\n\n  return ArrayBufferBackend;\n}(DownloadBackend);\n\nArrayBufferBackend.supported = function () {\n  try {\n    var xhr = new XMLHttpRequest();\n    xhr.responseType = type;\n    return xhr.responseType === type;\n  } catch (e) {\n    return false;\n  }\n};\n\nmodule.exports = ArrayBufferBackend;\n\n\n//# sourceURL=webpack://ogvjs/./node_modules/stream-file/lib/backend/arraybuffer-backend.js?");

/***/ }),

/***/ "./node_modules/stream-file/lib/backend/backend.js":
/*!*********************************************************!*\
  !*** ./node_modules/stream-file/lib/backend/backend.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar TinyEvents = __webpack_require__(/*! ../events */ \"./node_modules/stream-file/lib/events/index.js\");\n\n/**\n * Extract the file's total length from the XHR returned headers.\n * @returns {number} - byte length or -1\n * @access private\n */\nfunction getXHRLength(xhr) {\n  if (xhr.status == 206) {\n    return getXHRRangeTotal(xhr);\n  } else {\n    var contentLength = xhr.getResponseHeader('Content-Length');\n    if (contentLength === null || contentLength === '') {\n      // Unknown file length... maybe streaming live?\n      return -1;\n    } else {\n      return parseInt(contentLength, 10);\n    }\n  }\n}\n\n/**\n * Extract the range chunk info from the XHR returned headers.\n * @returns {Array} - byte length or -1\n * @access private\n */\nfunction getXHRRangeMatches(xhr) {\n  // Note Content-Range must be whitelisted for CORS requests\n  var contentRange = xhr.getResponseHeader('Content-Range');\n  return contentRange && contentRange.match(/^bytes (\\d+)-(\\d+)\\/(\\d+)/);\n}\n\n/**\n * Extract the chunk start position from the XHR returned headers.\n * @returns {number} - byte position or 0\n * @access private\n */\nfunction getXHRRangeStart(xhr) {\n  var matches = getXHRRangeMatches(xhr);\n  if (matches) {\n    return parseInt(matches[1], 10);\n  } else {\n    return 0;\n  }\n}\n\n/**\n * Extract the file's total length from the XHR returned headers.\n * @returns {number} - byte length or -1\n * @access private\n */\nfunction getXHRRangeTotal(xhr) {\n  var matches = getXHRRangeMatches(xhr);\n  if (matches) {\n    return parseInt(matches[3], 10);\n  } else {\n    return -1;\n  }\n}\n\n/**\n * Record the HTTP headers from the initial request, in case some are useful.\n * @returns {Object} map of headers\n * @access private\n */\nfunction getXHRHeaders(xhr) {\n  var headers = {};\n  var headerLines = xhr.getAllResponseHeaders().split(/\\r?\\n/);\n  headerLines.forEach(function (line) {\n    var bits = line.split(/:\\s*/, 2);\n    if (bits.length > 1) {\n      headers[bits[0].toLowerCase()] = bits[1];\n    }\n  });\n  return headers;\n}\n\n/**\n * Represents a single HTTP request pass through part of a URL.\n *\n * Subclasses handle details of chunking/strings/streams and provide\n * a unified internal API.\n *\n * Events sent:\n * - 'open' - called when file metadata ready\n * - 'buffer' - passes a BufferSegment in with some new data\n * - 'done' - called at end of file\n * - 'error' - called in case of error\n * - 'cachever' - triggered when old Safari caching bug found\n */\n\nvar Backend = function (_TinyEvents) {\n  _inherits(Backend, _TinyEvents);\n\n  function Backend(_ref) {\n    var url = _ref.url;\n    var offset = _ref.offset;\n    var length = _ref.length;\n    var _ref$cachever = _ref.cachever;\n    var cachever = _ref$cachever === undefined ? 0 : _ref$cachever;\n\n    _classCallCheck(this, Backend);\n\n    var _this = _possibleConstructorReturn(this, (Backend.__proto__ || Object.getPrototypeOf(Backend)).call(this));\n\n    _this.url = url;\n    _this.offset = offset;\n    _this.length = length;\n    _this.cachever = cachever;\n\n    _this.loaded = false;\n    _this.seekable = false;\n    _this.headers = {};\n    _this.eof = false;\n    _this.bytesRead = 0;\n    _this.xhr = new XMLHttpRequest();\n    return _this;\n  }\n\n  _createClass(Backend, [{\n    key: 'load',\n    value: function load() {\n      var _this2 = this;\n\n      return new Promise(function (resolve, reject) {\n        var oncomplete = null;\n        _this2._onAbort = function (err) {\n          oncomplete();\n          reject(err);\n        };\n        var checkOpen = function checkOpen() {\n          // There doesn't seem to be a good match for readyState 2 on the XHR2 events model.\n          if (_this2.xhr.readyState == 2) {\n            if (_this2.xhr.status == 206) {\n              // Partial content -- we are streamable\n              var foundPosition = getXHRRangeStart(_this2.xhr);\n              if (_this2.offset != foundPosition) {\n                //\n                // Safari sometimes messes up and gives us the wrong chunk.\n                // Seems to be a general problem with Safari and cached XHR ranges.\n                //\n                // Interestingly, it allows you to request _later_ ranges successfully,\n                // but when requesting _earlier_ ranges it returns the latest one retrieved.\n                // So we only need to update the cache-buster when we rewind and actually\n                // get an incorrect range.\n                //\n                // https://bugs.webkit.org/show_bug.cgi?id=82672\n                //\n                console.log('Expected start at ' + _this2.offset + ' but got ' + foundPosition + '; working around Safari range caching bug: https://bugs.webkit.org/show_bug.cgi?id=82672');\n                _this2.cachever++;\n                _this2.emit('cachever');\n                _this2.abort();\n                oncomplete();\n                _this2.load().then(resolve).catch(reject);\n                return;\n              }\n              _this2.seekable = true;\n            }\n            if (_this2.xhr.status >= 200 && _this2.xhr.status < 300) {\n              _this2.length = getXHRLength(_this2.xhr);\n              _this2.headers = getXHRHeaders(_this2.xhr);\n              _this2.onXHRStart();\n            } else {\n              oncomplete();\n              reject(new Error('HTTP error ' + _this2.xhr.status));\n            }\n          }\n        };\n        var checkError = function checkError() {\n          oncomplete();\n          reject(new Error('network error'));\n        };\n        var checkBackendOpen = function checkBackendOpen() {\n          oncomplete();\n          resolve();\n        };\n        oncomplete = function oncomplete() {\n          _this2.xhr.removeEventListener('readystatechange', checkOpen);\n          _this2.xhr.removeEventListener('error', checkError);\n          _this2.off('open', checkBackendOpen);\n          _this2._onAbort = null;\n        };\n\n        _this2.initXHR();\n\n        // Events for the open promise\n        _this2.xhr.addEventListener('readystatechange', checkOpen);\n        _this2.xhr.addEventListener('error', checkError);\n        _this2.on('open', checkBackendOpen);\n\n        _this2.xhr.send();\n      });\n    }\n\n    /**\n     * Wait until we download up to the given offset, reach eof, or error out.\n     * Actual data will be returned via 'buffer' events in the meantime.\n     *\n     * Note that MSStream backend will need this to be called explicitly,\n     * while the other backends download progressively even without a call.\n     */\n\n  }, {\n    key: 'bufferToOffset',\n    value: function bufferToOffset(end) {\n      return Promise.reject(new Error('abstract'));\n    }\n  }, {\n    key: 'abort',\n    value: function abort() {\n      this.xhr.abort();\n\n      if (this._onAbort) {\n        var onAbort = this._onAbort;\n        this._onAbort = null;\n\n        var err = new Error('Aborted');\n        err.name = 'AbortError';\n\n        onAbort(err);\n      }\n    }\n\n    // ---------------\n    // Private methods\n    // ---------------\n\n  }, {\n    key: 'initXHR',\n    value: function initXHR() {\n      var getUrl = this.url;\n      if (this.cachever) {\n        //\n        // Safari sometimes messes up and gives us the wrong chunk.\n        // Seems to be a general problem with Safari and cached XHR ranges.\n        //\n        // Interestingly, it allows you to request _later_ ranges successfully,\n        // but when requesting _earlier_ ranges it returns the latest one retrieved.\n        // So we only need to update the cache-buster when we rewind.\n        //\n        // https://bugs.webkit.org/show_bug.cgi?id=82672\n        //\n        getUrl += '?buggy_cachever=' + this.cachever;\n      }\n\n      this.xhr.open(\"GET\", getUrl);\n\n      var range = null;\n      if (this.offset || this.length) {\n        range = 'bytes=' + this.offset + '-';\n      }\n      if (this.length) {\n        range += this.offset + this.length - 1;\n      }\n      if (range !== null) {\n        this.xhr.setRequestHeader('Range', range);\n      }\n    }\n  }, {\n    key: 'onXHRStart',\n    value: function onXHRStart() {\n      throw new Error('abstract');\n    }\n  }]);\n\n  return Backend;\n}(TinyEvents);\n\nmodule.exports = Backend;\n\n\n//# sourceURL=webpack://ogvjs/./node_modules/stream-file/lib/backend/backend.js?");

/***/ }),

/***/ "./node_modules/stream-file/lib/backend/binary-string-backend.js":
/*!***********************************************************************!*\
  !*** ./node_modules/stream-file/lib/backend/binary-string-backend.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar DownloadBackend = __webpack_require__(/*! ./download-backend.js */ \"./node_modules/stream-file/lib/backend/download-backend.js\");\n\nvar BinaryStringBackend = function (_DownloadBackend) {\n  _inherits(BinaryStringBackend, _DownloadBackend);\n\n  function BinaryStringBackend() {\n    _classCallCheck(this, BinaryStringBackend);\n\n    return _possibleConstructorReturn(this, (BinaryStringBackend.__proto__ || Object.getPrototypeOf(BinaryStringBackend)).apply(this, arguments));\n  }\n\n  _createClass(BinaryStringBackend, [{\n    key: \"initXHR\",\n    value: function initXHR() {\n      _get(BinaryStringBackend.prototype.__proto__ || Object.getPrototypeOf(BinaryStringBackend.prototype), \"initXHR\", this).call(this);\n      this.xhr.responseType = \"text\";\n      this.xhr.overrideMimeType('text/plain; charset=x-user-defined');\n    }\n  }, {\n    key: \"onXHRProgress\",\n    value: function onXHRProgress() {\n      var slice = this.xhr.responseText.slice(this.bytesRead);\n      if (slice.length > 0) {\n        this.bytesRead += slice.length;\n        this.emit('buffer', slice);\n      }\n    }\n  }, {\n    key: \"onXHRLoad\",\n    value: function onXHRLoad() {\n      // We may or may not get that final event\n      this.onXHRProgress();\n      _get(BinaryStringBackend.prototype.__proto__ || Object.getPrototypeOf(BinaryStringBackend.prototype), \"onXHRLoad\", this).call(this);\n    }\n  }]);\n\n  return BinaryStringBackend;\n}(DownloadBackend);\n\nBinaryStringBackend.supported = function () {\n  try {\n    var xhr = new XMLHttpRequest();\n    return !!xhr.overrideMimeType;\n  } catch (e) {\n    return false;\n  }\n};\n\nmodule.exports = BinaryStringBackend;\n\n\n//# sourceURL=webpack://ogvjs/./node_modules/stream-file/lib/backend/binary-string-backend.js?");

/***/ }),

/***/ "./node_modules/stream-file/lib/backend/download-backend.js":
/*!******************************************************************!*\
  !*** ./node_modules/stream-file/lib/backend/download-backend.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Backend = __webpack_require__(/*! ./backend.js */ \"./node_modules/stream-file/lib/backend/backend.js\");\n\n/**\n * Backend for progressive downloading.\n * Subclasses handle details of strings/buffers.\n */\n\nvar DownloadBackend = function (_Backend) {\n  _inherits(DownloadBackend, _Backend);\n\n  function DownloadBackend() {\n    _classCallCheck(this, DownloadBackend);\n\n    return _possibleConstructorReturn(this, (DownloadBackend.__proto__ || Object.getPrototypeOf(DownloadBackend)).apply(this, arguments));\n  }\n\n  _createClass(DownloadBackend, [{\n    key: 'bufferToOffset',\n    value: function bufferToOffset(end) {\n      var _this2 = this;\n\n      return new Promise(function (resolve, reject) {\n        if (_this2.eof || _this2.offset >= end) {\n          resolve();\n        } else {\n          (function () {\n            var oncomplete = null;\n            _this2._onAbort = function (err) {\n              oncomplete();\n              reject(err);\n            };\n\n            var checkBuffer = function checkBuffer() {\n              if (_this2.offset >= end && !_this2.eof) {\n                oncomplete();\n                resolve();\n              }\n            };\n            var checkDone = function checkDone() {\n              oncomplete();\n              resolve();\n            };\n            var checkError = function checkError() {\n              oncomplete();\n              reject(new Error('error streaming'));\n            };\n\n            oncomplete = function oncomplete() {\n              _this2.buffering = false;\n              _this2.off('buffer', checkBuffer);\n              _this2.off('done', checkDone);\n              _this2.off('error', checkError);\n              _this2._onAbort = null;\n            };\n\n            _this2.buffering = true;\n            _this2.on('buffer', checkBuffer);\n            _this2.on('done', checkDone);\n            _this2.on('error', checkError);\n          })();\n        }\n      });\n    }\n  }, {\n    key: 'initXHR',\n    value: function initXHR() {\n      _get(DownloadBackend.prototype.__proto__ || Object.getPrototypeOf(DownloadBackend.prototype), 'initXHR', this).call(this);\n    }\n  }, {\n    key: 'onXHRStart',\n    value: function onXHRStart() {\n      var _this3 = this;\n\n      // Event handlers to drive output\n      this.xhr.addEventListener('progress', function () {\n        return _this3.onXHRProgress();\n      });\n      this.xhr.addEventListener('error', function () {\n        return _this3.onXHRError();\n      });\n      this.xhr.addEventListener('load', function () {\n        return _this3.onXHRLoad();\n      });\n\n      this.emit('open');\n    }\n  }, {\n    key: 'onXHRProgress',\n    value: function onXHRProgress() {\n      throw new Error('abstract');\n    }\n  }, {\n    key: 'onXHRError',\n    value: function onXHRError() {\n      this.emit('error');\n    }\n  }, {\n    key: 'onXHRLoad',\n    value: function onXHRLoad() {\n      this.eof = true;\n      this.emit('done');\n    }\n  }]);\n\n  return DownloadBackend;\n}(Backend);\n\nmodule.exports = DownloadBackend;\n\n\n//# sourceURL=webpack://ogvjs/./node_modules/stream-file/lib/backend/download-backend.js?");

/***/ }),

/***/ "./node_modules/stream-file/lib/backend/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/stream-file/lib/backend/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar MozChunkedBackend = __webpack_require__(/*! ./moz-chunked-backend.js */ \"./node_modules/stream-file/lib/backend/moz-chunked-backend.js\");\nvar MSStreamBackend = __webpack_require__(/*! ./msstream-backend.js */ \"./node_modules/stream-file/lib/backend/msstream-backend.js\");\nvar BinaryStringBackend = __webpack_require__(/*! ./binary-string-backend.js */ \"./node_modules/stream-file/lib/backend/binary-string-backend.js\");\nvar ArrayBufferBackend = __webpack_require__(/*! ./arraybuffer-backend.js */ \"./node_modules/stream-file/lib/backend/arraybuffer-backend.js\");\n\nfunction autoselect() {\n  // Only include progressive-capable for now\n  if (MozChunkedBackend.supported()) {\n    return MozChunkedBackend;\n  } else if (BinaryStringBackend.supported()) {\n    return BinaryStringBackend;\n  } else if (MSStreamBackend.supported()) {\n    return MSStreamBackend;\n  } else {\n    return null;\n  }\n}\n\nvar backendClass = null;\n\nfunction instantiate(options) {\n  if (options.progressive === false) {\n    return new ArrayBufferBackend(options);\n  }\n  if (!backendClass) {\n    backendClass = autoselect();\n  }\n  if (!backendClass) {\n    throw new Error('No supported backend class');\n  }\n  return new backendClass(options);\n}\n\nmodule.exports = instantiate;\n\n\n//# sourceURL=webpack://ogvjs/./node_modules/stream-file/lib/backend/index.js?");

/***/ }),

/***/ "./node_modules/stream-file/lib/backend/moz-chunked-backend.js":
/*!*********************************************************************!*\
  !*** ./node_modules/stream-file/lib/backend/moz-chunked-backend.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar DownloadBackend = __webpack_require__(/*! ./download-backend.js */ \"./node_modules/stream-file/lib/backend/download-backend.js\");\n\nvar type = 'moz-chunked-arraybuffer';\n\nvar MozChunkedBackend = function (_DownloadBackend) {\n  _inherits(MozChunkedBackend, _DownloadBackend);\n\n  function MozChunkedBackend() {\n    _classCallCheck(this, MozChunkedBackend);\n\n    return _possibleConstructorReturn(this, (MozChunkedBackend.__proto__ || Object.getPrototypeOf(MozChunkedBackend)).apply(this, arguments));\n  }\n\n  _createClass(MozChunkedBackend, [{\n    key: 'initXHR',\n    value: function initXHR() {\n      _get(MozChunkedBackend.prototype.__proto__ || Object.getPrototypeOf(MozChunkedBackend.prototype), 'initXHR', this).call(this);\n      this.xhr.responseType = type;\n    }\n  }, {\n    key: 'onXHRProgress',\n    value: function onXHRProgress() {\n      var buffer = this.xhr.response;\n      this.bytesRead += buffer.byteLength;\n      this.emit('buffer', buffer);\n    }\n  }]);\n\n  return MozChunkedBackend;\n}(DownloadBackend);\n\nMozChunkedBackend.supported = function () {\n  try {\n    var xhr = new XMLHttpRequest();\n    xhr.responseType = type;\n    return xhr.responseType === type;\n  } catch (e) {\n    return false;\n  }\n};\n\nmodule.exports = MozChunkedBackend;\n\n\n//# sourceURL=webpack://ogvjs/./node_modules/stream-file/lib/backend/moz-chunked-backend.js?");

/***/ }),

/***/ "./node_modules/stream-file/lib/backend/msstream-backend.js":
/*!******************************************************************!*\
  !*** ./node_modules/stream-file/lib/backend/msstream-backend.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Backend = __webpack_require__(/*! ./backend.js */ \"./node_modules/stream-file/lib/backend/backend.js\");\n\nvar type = 'ms-stream';\n\nvar MSStreamBackend = function (_Backend) {\n  _inherits(MSStreamBackend, _Backend);\n\n  function MSStreamBackend(options) {\n    _classCallCheck(this, MSStreamBackend);\n\n    var _this = _possibleConstructorReturn(this, (MSStreamBackend.__proto__ || Object.getPrototypeOf(MSStreamBackend)).call(this, options));\n\n    _this.stream = null;\n    _this.streamReader = null;\n    return _this;\n  }\n\n  _createClass(MSStreamBackend, [{\n    key: 'initXHR',\n    value: function initXHR() {\n      _get(MSStreamBackend.prototype.__proto__ || Object.getPrototypeOf(MSStreamBackend.prototype), 'initXHR', this).call(this);\n      this.xhr.responseType = type;\n    }\n  }, {\n    key: 'onXHRStart',\n    value: function onXHRStart() {\n      var _this2 = this;\n\n      var checkProgress = function checkProgress() {\n        if (_this2.xhr.readyState === 3) {\n          // We don't get the stream until readyState 3, and it's gone after load.\n          _this2.stream = _this2.xhr.response;\n          _this2.xhr.removeEventListener('readystatechange', checkProgress);\n          _this2.emit('open');\n        }\n      };\n      this.xhr.addEventListener('readystatechange', checkProgress);\n    }\n  }, {\n    key: 'waitForStream',\n    value: function waitForStream() {\n      var _this3 = this;\n\n      return new Promise(function (resolve, reject) {\n        if (_this3.stream) {\n          resolve(_this3.stream);\n        } else {\n          (function () {\n            var oncomplete = null;\n            _this3._onAbort = function (err) {\n              oncomplete();\n              reject(err);\n            };\n            var checkStart = function checkStart() {\n              resolve(_this3.stream);\n            };\n            oncomplete = function oncomplete() {\n              _this3.off('open', checkStart);\n              _this3._onAbort = null;\n            };\n            _this3.on('open', checkStart);\n          })();\n        }\n      });\n    }\n\n    /**\n     * Trigger further download of bytes\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'bufferToOffset',\n    value: function bufferToOffset(end) {\n      var _this4 = this;\n\n      return this.waitForStream().then(function (stream) {\n        return new Promise(function (resolve, reject) {\n          if (_this4.streamReader) {\n            throw new Error('cannot trigger read when reading');\n          }\n          if (_this4.offset >= end || _this4.eof) {\n            resolve();\n          } else {\n            var nbytes = end - _this4.offset;\n            _this4.streamReader = new MSStreamReader();\n            _this4.streamReader.onload = function (event) {\n              _this4.streamReader = null;\n              var buffer = event.target.result;\n              if (buffer.byteLength > 0) {\n                _this4.bytesRead += buffer.byteLength;\n                _this4.emit('buffer', buffer);\n              } else {\n                // Zero length means end of stream.\n                _this4.eof = true;\n                _this4.emit('done');\n              }\n              resolve();\n            };\n            _this4.streamReader.onerror = function () {\n              _this4.streamReader = null;\n              _this4.stream = null;\n              _this4.emit('error');\n              reject(new Error('mystery error streaming'));\n            };\n            _this4._onAbort = function (err) {\n              _this4.streamReader.abort();\n              _this4.streamReader = null;\n              _this4.stream = null;\n              _this4.emit('error');\n              reject(err);\n            };\n            _this4.streamReader.readAsArrayBuffer(stream, nbytes);\n          }\n        });\n      });\n    }\n  }, {\n    key: 'abort',\n    value: function abort() {\n      if (this.streamReader) {\n        this.streamReader.abort();\n        this.streamReader = null;\n      }\n      if (this.stream) {\n        this.stream.msClose();\n        this.stream = null;\n      }\n      _get(MSStreamBackend.prototype.__proto__ || Object.getPrototypeOf(MSStreamBackend.prototype), 'abort', this).call(this);\n    }\n  }]);\n\n  return MSStreamBackend;\n}(Backend);\n\nMSStreamBackend.supported = function () {\n  try {\n    var xhr = new XMLHttpRequest();\n    // IE demands that open() be called before we can set xhr.responseType\n    xhr.open(\"GET\", \"/robots.txt\");\n    xhr.responseType = type;\n    return xhr.responseType === type;\n  } catch (e) {\n    return false;\n  }\n};\n\nmodule.exports = MSStreamBackend;\n\n\n//# sourceURL=webpack://ogvjs/./node_modules/stream-file/lib/backend/msstream-backend.js?");

/***/ }),

/***/ "./node_modules/stream-file/lib/cache/cache-item.js":
/*!**********************************************************!*\
  !*** ./node_modules/stream-file/lib/cache/cache-item.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Double-linked list cache items\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar CacheItem = function () {\n  function CacheItem() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _ref$buffer = _ref.buffer;\n    var buffer = _ref$buffer === undefined ? undefined : _ref$buffer;\n    var _ref$string = _ref.string;\n    var string = _ref$string === undefined ? undefined : _ref$string;\n    var _ref$start = _ref.start;\n    var start = _ref$start === undefined ? 0 : _ref$start;\n    var _ref$end = _ref.end;\n    var end = _ref$end === undefined ? start + (buffer ? buffer.byteLength : string ? string.length : 0) : _ref$end;\n    var _ref$prev = _ref.prev;\n    var prev = _ref$prev === undefined ? null : _ref$prev;\n    var _ref$next = _ref.next;\n    var next = _ref$next === undefined ? null : _ref$next;\n    var _ref$eof = _ref.eof;\n    var eof = _ref$eof === undefined ? false : _ref$eof;\n    var _ref$empty = _ref.empty;\n    var empty = _ref$empty === undefined ? !(buffer || string) : _ref$empty;\n    var _ref$timestamp = _ref.timestamp;\n    var timestamp = _ref$timestamp === undefined ? Date.now() : _ref$timestamp;\n\n    _classCallCheck(this, CacheItem);\n\n    this.start = start;\n    this.end = end;\n    this.prev = prev;\n    this.next = next;\n    this.eof = eof;\n    this.empty = empty;\n    this.timestamp = timestamp;\n    this.buffer = buffer;\n    this.string = string;\n    Object.defineProperty(this, 'length', {\n      get: function get() {\n        return this.end - this.start;\n      }\n    });\n  }\n\n  /**\n   * True if this cache item contains the given byte offset.\n   * False if outside.\n   */\n\n\n  _createClass(CacheItem, [{\n    key: 'contains',\n    value: function contains(offset) {\n      return offset >= this.start && (offset < this.end || this.eof);\n    }\n  }, {\n    key: 'readBytes',\n    value: function readBytes(dest, start, end) {\n      var readHead = start - this.start;\n      var len = end - start;\n      if (this.buffer) {\n        var sourceBytes = new Uint8Array(this.buffer, readHead, len);\n        dest.set(sourceBytes);\n      } else if (this.string) {\n        var chunk = this.string;\n        for (var i = 0; i < len; i++) {\n          dest[i] = chunk.charCodeAt(readHead + i);\n        }\n      } else {\n        throw new Error('invalid state');\n      }\n      this.timestamp = Date.now();\n    }\n  }, {\n    key: 'split',\n    value: function split(offset) {\n      if (!this.empty || !this.contains(offset)) {\n        throw new Error('invalid split');\n      }\n      var a = new CacheItem({\n        start: this.start,\n        end: offset\n      });\n      var b = new CacheItem({\n        start: offset,\n        end: this.eof ? offset : this.end,\n        eof: this.eof\n      });\n      a.next = b;\n      b.prev = a;\n      return [a, b];\n    }\n\n    /**\n     * Iterate forwards, returning the first element matching the callback.\n     * @param {function} callback - return true for a match on item\n     * @returns {CacheItem|null} - matching item or null if none found\n     */\n\n  }, {\n    key: 'first',\n    value: function first(callback) {\n      for (var item = this; item; item = item.next) {\n        if (callback(item)) {\n          return item;\n        }\n      }\n      return null;\n    }\n\n    /**\n     * Iterate forwards, returning the last element matching the callback before\n     * reaching one that doesn't match or we find the end.\n     * @param {function} callback - return true for a match on item\n     * @returns {CacheItem|null} - matching item or null if none found\n     */\n\n  }, {\n    key: 'last',\n    value: function last(callback) {\n      var last = null;\n      for (var item = this; item; item = item.next) {\n        if (!callback(item)) {\n          break;\n        }\n        last = item;\n      }\n      return last;\n    }\n  }]);\n\n  return CacheItem;\n}();\n\nmodule.exports = CacheItem;\n\n\n//# sourceURL=webpack://ogvjs/./node_modules/stream-file/lib/cache/cache-item.js?");

/***/ }),

/***/ "./node_modules/stream-file/lib/cache/cache-pool.js":
/*!**********************************************************!*\
  !*** ./node_modules/stream-file/lib/cache/cache-pool.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar CacheItem = __webpack_require__(/*! ./cache-item.js */ \"./node_modules/stream-file/lib/cache/cache-item.js\");\n\n/**\n * Seekable, readable, writable buffer cache to represent a file.\n * @todo add max cache size and LRU cache expiration\n *\n * Internally, will always contain entries from 0 to some given out point.\n * Each item may either contain data, or be empty.\n * Empty ranges cannot be copied out via read(), non-empty ranges can.\n * Empty ranges can be filled up with write(), non-empty ranges cannot.\n *\n * Internal invariants:\n * - head and tail are always present, may be same for empty\n * - tail item is always empty/eof\n * - non-empty items are never 0 bytes\n * - adjacent list items are always continguous\n * - empty items are never adjacent to each other\n */\n\nvar CachePool = function () {\n  function CachePool() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _ref$cacheSize = _ref.cacheSize;\n    var cacheSize = _ref$cacheSize === undefined ? 0 : _ref$cacheSize;\n\n    _classCallCheck(this, CachePool);\n\n    var eof = new CacheItem({ eof: true });\n    this.head = eof;\n    this.tail = eof;\n    this.readOffset = 0;\n    this.readCursor = eof;\n    this.writeOffset = 0;\n    this.writeCursor = eof;\n    this.cacheSize = cacheSize;\n  }\n\n  /**\n   * Is the read cursor at the end of the file?\n   */\n\n\n  _createClass(CachePool, [{\n    key: 'bytesReadable',\n\n\n    /**\n     * Count how many bytes are available from the given offset.\n     * @param {number} max - optional maximum to read\n     * @returns {number} 0 or more\n     */\n    value: function bytesReadable() {\n      var max = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Infinity;\n\n      var offset = this.readOffset;\n      var cursor = this.readCursor;\n      var last = cursor.last(function (item) {\n        return !item.empty && item.start <= offset + max;\n      });\n      if (last) {\n        return Math.min(max, last.end - offset);\n      }\n      return 0;\n    }\n\n    /**\n     * Count how many bytes are available to write.\n     * @param {number} max - optional maximum to write\n     * @returns {number} 0 or more, or +Infinity\n     */\n\n  }, {\n    key: 'bytesWritable',\n    value: function bytesWritable() {\n      var max = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Infinity;\n\n      var offset = this.writeOffset;\n      var cursor = this.writeCursor;\n      if (cursor.eof) {\n        return max;\n      }\n      var last = cursor.last(function (item) {\n        return item.empty && item.start <= offset + max;\n      });\n      if (last) {\n        return Math.min(max, last.end - offset);\n      }\n      return 0;\n    }\n\n    /**\n     * Move the read head to a given offset. The read head can move beyond the\n     * currently known end of the file, but cannot move before 0.\n     * @param {number} offset - bytes from beginning of virtual file to read from\n     */\n\n  }, {\n    key: 'seekRead',\n    value: function seekRead(offset) {\n      var target = this.head.first(function (item) {\n        return item.contains(offset);\n      });\n      if (!target) {\n        throw new Error('read seek out of range');\n      }\n      this.readOffset = offset;\n      this.readCursor = target;\n    }\n\n    /**\n     * Move the write head to a given offset. The write head can move beyond the\n     * currently known end of the file, but cannot move before 0.\n     * @param {number} offset - bytes from beginning of virtual file to write to\n     */\n\n  }, {\n    key: 'seekWrite',\n    value: function seekWrite(offset) {\n      var target = this.head.first(function (item) {\n        return item.contains(offset);\n      });\n      if (!target) {\n        throw new Error('write seek out of range');\n      }\n      this.writeOffset = offset;\n      this.writeCursor = target;\n    }\n\n    /**\n     * Read up to the requested number of bytes, or however much is available\n     * in the buffer until the next empty segment, and advance the read head.\n     *\n     * Returns immediately.\n     *\n     * @param {Uint8Array} dest - destination array to read to\n     * @returns {number} - count of bytes actually read\n     */\n\n  }, {\n    key: 'readBytes',\n    value: function readBytes(dest) {\n      var nbytes = dest.byteLength;\n      var len = this.bytesReadable(nbytes);\n      var start = this.readOffset;\n      var end = start + len;\n\n      var readHead = start;\n      var writeHead = 0;\n      for (var item = this.readCursor; item; item = item.next) {\n        if (item.empty) {\n          break;\n        }\n        if (item.start >= end) {\n          break;\n        }\n        var readTail = Math.min(end, item.end);\n        var chunk = dest.subarray(readHead - start, readTail - start);\n        item.readBytes(chunk, readHead, readTail);\n        readHead = readTail;\n      }\n      this.readOffset = readHead;\n      this.readCursor = this.readCursor.first(function (item) {\n        return item.contains(readHead);\n      });\n\n      return len;\n    }\n\n    /**\n     * Write a data buffer at the write head and advance the write head.\n     * The data must fit in the available empty space in the buffer cache.\n     * @param {ArrayBuffer|String} buffer\n     */\n\n  }, {\n    key: 'write',\n    value: function write(buffer) {\n      var item = this.bufferItem(buffer);\n      var cursor = this.writeCursor;\n\n      if (!cursor.empty) {\n        throw new Error('write cursor not empty');\n      }\n      if (!cursor.contains(item.end) && cursor.end !== item.end) {\n        throw new Error('write cursor too small');\n      }\n\n      if (cursor.start < item.start) {\n        this.split(cursor, item.start);\n        cursor = this.writeCursor;\n      }\n\n      if (item.end < cursor.end || cursor.eof) {\n        this.split(cursor, item.end);\n        cursor = this.writeCursor;\n      }\n\n      this.splice(cursor, cursor, item, item);\n      this.writeOffset = item.end;\n      this.writeCursor = item.next;\n\n      this.gc();\n    }\n  }, {\n    key: 'bufferItem',\n    value: function bufferItem(buffer) {\n      if (buffer instanceof ArrayBuffer) {\n        return new CacheItem({\n          start: this.writeOffset,\n          end: this.writeOffset + buffer.byteLength,\n          buffer: buffer\n        });\n      } else if (typeof buffer === 'string') {\n        return new CacheItem({\n          start: this.writeOffset,\n          end: this.writeOffset + buffer.length,\n          string: buffer\n        });\n      } else {\n        throw new Error('invalid input to write');\n      }\n    }\n  }, {\n    key: 'split',\n    value: function split(oldItem, offset) {\n      var items = oldItem.split(offset);\n      this.splice(oldItem, oldItem, items[0], items[1]);\n    }\n\n    /**\n     * Return an array of arrays of consolidated cached ranges\n     */\n\n  }, {\n    key: 'ranges',\n    value: function ranges() {\n      var ranges = [];\n\n      for (var item = this.head; item; item = item.next) {\n        if (item.empty) {\n          continue;\n        }\n        var start = item;\n        item = item.last(function (i) {\n          return !i.empty;\n        });\n        ranges.push([start.start, item.end]);\n      }\n\n      return ranges;\n    }\n  }, {\n    key: 'gc',\n    value: function gc() {\n      // Simple gc: look at anything not between read head and write head,\n      // and discard the oldest items until we have room\n      var cachedBytes = 0;\n      var candidates = [];\n      for (var item = this.head; item; item = item.next) {\n        if (!item.empty) {\n          cachedBytes += item.length;\n          if (item.end < this.readOffset || item.start > this.readOffset + this.chunkSize) {\n            // Not in the 'hot' readahead range\n            candidates.push(item);\n          }\n        }\n      }\n      if (cachedBytes > this.cacheSize) {\n        candidates.sort(function (a, b) {\n          return a.timestamp - b.timestamp;\n        });\n\n        for (var i = 0; i < candidates.length; i++) {\n          var _item = candidates[i];\n          if (cachedBytes <= this.cacheSize) {\n            break;\n          }\n          this.remove(_item);\n          cachedBytes -= _item.length;\n        }\n      }\n    }\n  }, {\n    key: 'remove',\n    value: function remove(item) {\n      var replacement = new CacheItem({\n        start: item.start,\n        end: item.end\n      });\n      this.splice(item, item, replacement, replacement);\n      item = replacement;\n\n      // Consolidate adjacent ranges\n      if (item.prev && item.prev.empty) {\n        item = this.consolidate(item.prev);\n      }\n      if (item.next && item.next.empty && !item.next.eof) {\n        item = this.consolidate(item);\n      }\n      if (item.start === 0) {\n        this.head = item;\n      }\n    }\n  }, {\n    key: 'consolidate',\n    value: function consolidate(first) {\n      var last = first.last(function (item) {\n        return item.empty && !item.eof;\n      });\n      var replacement = new CacheItem({\n        start: first.start,\n        end: last.end\n      });\n      this.splice(first, last, replacement, replacement);\n      return replacement;\n    }\n  }, {\n    key: 'splice',\n    value: function splice(oldHead, oldTail, newHead, newTail) {\n      var _this = this;\n\n      if (oldHead.start !== newHead.start) {\n        throw new Error('invalid splice head');\n      }\n      if (oldTail.end !== newTail.end) {\n        if (oldTail.eof && newTail.eof) {\n          // only eof is expandable\n        } else {\n          throw new Error('invalid splice tail');\n        }\n      }\n      var prev = oldHead.prev;\n      var next = oldTail.next;\n\n      oldHead.prev = null;\n      oldTail.next = null;\n\n      if (prev) {\n        prev.next = newHead;\n        newHead.prev = prev;\n      }\n      if (next) {\n        next.prev = newTail;\n        newTail.next = next;\n      }\n\n      if (oldHead === this.head) {\n        this.head = newHead;\n      }\n      if (oldTail === this.tail) {\n        this.tail = newTail;\n      }\n      this.readCursor = this.head.first(function (item) {\n        return item.contains(_this.readOffset);\n      });\n      this.writeCursor = this.head.first(function (item) {\n        return item.contains(_this.writeOffset);\n      });\n    }\n  }, {\n    key: 'eof',\n    get: function get() {\n      return this.readCursor.eof;\n    }\n  }]);\n\n  return CachePool;\n}();\n\nmodule.exports = CachePool;\n\n\n//# sourceURL=webpack://ogvjs/./node_modules/stream-file/lib/cache/cache-pool.js?");

/***/ }),

/***/ "./node_modules/stream-file/lib/cache/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/stream-file/lib/cache/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = __webpack_require__(/*! ./cache-pool.js */ \"./node_modules/stream-file/lib/cache/cache-pool.js\");\n\n\n//# sourceURL=webpack://ogvjs/./node_modules/stream-file/lib/cache/index.js?");

/***/ }),

/***/ "./node_modules/stream-file/lib/events/index.js":
/*!******************************************************!*\
  !*** ./node_modules/stream-file/lib/events/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// just the bits we need\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TinyEvents = function () {\n  function TinyEvents() {\n    _classCallCheck(this, TinyEvents);\n\n    this._e = {};\n  }\n\n  _createClass(TinyEvents, [{\n    key: \"on\",\n    value: function on(name, handler) {\n      (this._e[name] || (this._e[name] = [])).push(handler);\n    }\n  }, {\n    key: \"off\",\n    value: function off(name, handler) {\n      var l = this._e[name] || [];\n      var i = l.indexOf(handler);\n      if (handler >= 0) {\n        l.splice(i, 1);\n      }\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(name, arg) {\n      (this._e[name] || []).slice().forEach(function (f) {\n        return f(arg);\n      });\n    }\n  }]);\n\n  return TinyEvents;\n}();\n\nmodule.exports = TinyEvents;\n\n\n//# sourceURL=webpack://ogvjs/./node_modules/stream-file/lib/events/index.js?");

/***/ }),

/***/ "./node_modules/stream-file/lib/stream-file.js":
/*!*****************************************************!*\
  !*** ./node_modules/stream-file/lib/stream-file.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar EventEmitter = __webpack_require__(/*! ./events */ \"./node_modules/stream-file/lib/events/index.js\");\nvar CachePool = __webpack_require__(/*! ./cache */ \"./node_modules/stream-file/lib/cache/index.js\");\nvar Backend = __webpack_require__(/*! ./backend */ \"./node_modules/stream-file/lib/backend/index.js\");\n\n/**\n * @typedef {Object} StreamFileOptions\n * @property {string} url - the URL to fetch\n * @property {number} chunkSize - max size of each chunked HTTP request / readahead target\n * @property {number} cacheSize - max amount of data to keep buffered in memory for seeks\n */\n\n/**\n * Utility class for chunked streaming of large files via XMLHttpRequest.\n * Provides an abstraction of a seekable input stream, backed by in-memory\n * caching, and some convenient promise-based i/o methods.\n * @param {StreamFileOptions} options\n * @constructor\n */\n\nvar StreamFile = function () {\n  function StreamFile(_ref) {\n    var _ref$url = _ref.url;\n    var url = _ref$url === undefined ? '' : _ref$url;\n    var _ref$chunkSize = _ref.chunkSize;\n    var chunkSize = _ref$chunkSize === undefined ? 1 * 1024 * 1024 : _ref$chunkSize;\n    var _ref$cacheSize = _ref.cacheSize;\n    var cacheSize = _ref$cacheSize === undefined ? 0 : _ref$cacheSize;\n    var _ref$progressive = _ref.progressive;\n    var progressive = _ref$progressive === undefined ? true : _ref$progressive;\n\n    _classCallCheck(this, StreamFile);\n\n    // InputStream public API\n    this.length = -1;\n    this.loaded = false;\n    this.loading = false;\n    this.seekable = false;\n    this.buffering = false;\n    this.seeking = false;\n    this.progressive = progressive;\n\n    Object.defineProperties(this, {\n      /**\n       * Byte offset of the read head\n       */\n      offset: {\n        get: function get() {\n          return this._cache.readOffset;\n        }\n      },\n\n      /**\n       * Is the read head at the end of the file?\n       */\n      eof: {\n        get: function get() {\n          return this.length === this._cache.readOffset;\n        }\n      }\n    });\n\n    // StreamFile public API\n    this.url = url;\n    this.headers = {};\n\n    // Private\n    this._cache = new CachePool({\n      cacheSize: cacheSize\n    });\n\n    this._backend = null;\n    this._cachever = 0;\n    this._chunkSize = chunkSize;\n  }\n\n  /**\n   * Open the file, get metadata, and start buffering some data.\n   * On success, loaded will become true, headers may be filled out,\n   * and length may be available.\n   *\n   * @returns {Promise}\n   */\n\n\n  _createClass(StreamFile, [{\n    key: 'load',\n    value: function load() {\n      var _this = this;\n\n      return new Promise(function (resolve, reject) {\n        if (_this.loading) {\n          throw new Error('cannot load when loading');\n        }\n        if (_this.loaded) {\n          throw new Error('cannot load when loaded');\n        }\n        _this.loading = true;\n        _this._openBackend().then(function (backend) {\n          // Save metadata from the first set...\n          // Beware this._backend may be null already,\n          // if the first segment was very short!\n          _this.seekable = backend.seekable;\n          _this.headers = backend.headers;\n          _this.length = backend.length;\n          _this.loaded = true;\n          _this.loading = false;\n          resolve();\n        }).catch(function (err) {\n          if (err.name !== 'AbortError') {\n            _this.loading = false;\n          }\n          reject(err);\n        });\n      });\n    }\n\n    /**\n     * Create a backend and wait for it to load.\n     * The returned 'backend' object may be null if there is no data to read.\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: '_openBackend',\n    value: function _openBackend() {\n      var _this2 = this;\n\n      return new Promise(function (resolve, reject) {\n        if (_this2._backend) {\n          resolve(_this2._backend);\n        } else if (_this2.eof) {\n          reject(new Error('cannot open at end of file'));\n        } else {\n          var cache = _this2._cache;\n          var max = _this2._chunkSize;\n\n          // Seek forward to the next unread point, up to chunk size\n          var readable = cache.bytesReadable(max);\n          var readTail = cache.readOffset + readable;\n          cache.seekWrite(readTail);\n\n          // Did we already cache the entire file?\n          if (_this2.length >= 0 && readTail >= _this2.length) {\n            resolve(null);\n            return;\n          }\n\n          // Do we have space to write within that chunk?\n          // Don't go beyond the end of the file, or it will confuse\n          // some browsers (Safari with blob URLs).\n          var writable = _this2._clampToLength(cache.writeOffset + cache.bytesWritable(max)) - cache.writeOffset;\n\n          if (writable === 0) {\n            // Nothing to read/write within the current readahead area.\n            resolve(null);\n          } else {\n            (function () {\n              var backend = _this2._backend = new Backend({\n                url: _this2.url,\n                offset: _this2._cache.writeOffset,\n                length: writable,\n                cachever: _this2._cachever,\n                progressive: _this2.progressive\n              });\n\n              var oncomplete = null;\n\n              var checkOpen = function checkOpen() {\n                if (backend !== _this2._backend) {\n                  oncomplete();\n                  reject(new Error('invalid state'));\n                } else {\n                  backend.on('buffer', function (buffer) {\n                    if (backend === _this2._backend) {\n                      _this2._cache.write(buffer);\n                    }\n                  });\n                  backend.on('done', function () {\n                    if (backend === _this2._backend) {\n                      if (_this2.length === -1) {\n                        // save length on those final thingies\n                        _this2.length = _this2._backend.offset + _this2._backend.bytesRead;\n                      }\n                      _this2._backend = null;\n                    }\n                  });\n                  resolve(backend);\n                }\n              };\n\n              var checkError = function checkError(err) {\n                if (backend !== _this2._backend) {\n                  reject(new Error('invalid state'));\n                } else {\n                  _this2._backend = null;\n                  reject(err);\n                }\n              };\n\n              oncomplete = function oncomplete() {\n                backend.off('open', checkOpen);\n                backend.off('error', checkError);\n              };\n              backend.on('open', checkOpen);\n              backend.on('error', checkError);\n              backend.on('cachever', function () {\n                _this2._cachever++;\n              });\n\n              backend.load();\n            })();\n          }\n        }\n      });\n    }\n\n    /**\n     * If we have empty space within the readahead area and there is not already\n     * a download backend in place, create one and start it loading in background.\n     * @returns {Promise}\n     */\n\n  }, {\n    key: '_readAhead',\n    value: function _readAhead() {\n      var _this3 = this;\n\n      return new Promise(function (resolve, reject) {\n        if (_this3._backend || _this3.eof) {\n          // do nothing\n          resolve();\n        } else {\n          _this3._openBackend().then(function () {\n            resolve();\n          }).catch(function (err) {\n            reject(err);\n          });\n        }\n      });\n    }\n\n    /**\n     * Seek the read position to a new location in the file, asynchronously.\n     * After succesful completion, reads will continue at the new offset.\n     * May fail due to network problems, invalid input, or bad state.\n     * @param {number} offset - target byte offset from beginning of file\n     * @returns {Promise} - resolved when ready to read at the new position\n     */\n\n  }, {\n    key: 'seek',\n    value: function seek(offset) {\n      var _this4 = this;\n\n      return new Promise(function (resolve, reject) {\n        if (!_this4.loaded || _this4.buffering || _this4.seeking) {\n          throw new Error('invalid state');\n        } else if (offset !== (offset | 0) || offset < 0) {\n          throw new Error('invalid input');\n        } else if (_this4.length >= 0 && offset > _this4.length) {\n          throw new Error('seek past end of file');\n        } else if (!_this4.seekable) {\n          throw new Error('seek on non-seekable stream');\n        } else {\n          if (_this4._backend) {\n            // @todo if a short seek forward, just keep reading?\n            _this4.abort();\n          }\n          _this4._cache.seekRead(offset);\n          _this4._cache.seekWrite(offset);\n\n          // Fire off a download if necessary.\n          _this4._readAhead().then(resolve).catch(reject);\n        }\n      });\n    }\n\n    /**\n     * Read up to the requested number of bytes, or until end of file is reached,\n     * and advance the read head.\n     *\n     * May wait on network activity if data is not yet available.\n     *\n     * @param {number} nbytes - max number of bytes to read\n     * @returns {ArrayBuffer} - between 0 and nbytes of data, inclusive\n     */\n\n  }, {\n    key: 'read',\n    value: function read(nbytes) {\n      var _this5 = this;\n\n      return this.buffer(nbytes).then(function (available) {\n        return _this5.readSync(available);\n      });\n    }\n\n    /**\n     * Read up to the requested number of bytes, or however much is available\n     * in the buffer until the next empty segment, and advance the read head.\n     *\n     * Returns immediately.\n     *\n     * @param {number} nbytes - max number of bytes to read\n     * @returns {ArrayBuffer} - between 0 and nbytes of data, inclusive\n     */\n\n  }, {\n    key: 'readSync',\n    value: function readSync(nbytes) {\n      var available = this.bytesAvailable(nbytes);\n      var dest = new Uint8Array(available);\n      var actual = this.readBytes(dest);\n      if (actual !== available) {\n        throw new Error('failed to read expected data');\n      }\n      return dest.buffer;\n    }\n\n    /**\n     * Read bytes into destination array until out of buffer or space,\n     * and advance the read head.\n     *\n     * Returns immediately.\n     *\n     * @param {dest} Uint8Array - destination byte array\n     * @returns {number} - count of actual bytes read\n     */\n\n  }, {\n    key: 'readBytes',\n    value: function readBytes(dest) {\n      if (!this.loaded || this.buffering || this.seeking) {\n        throw new Error('invalid state');\n      } else if (!(dest instanceof Uint8Array)) {\n        throw new Error('invalid input');\n      }\n      var nbytes = this._cache.readBytes(dest);\n\n      // Trigger readahead if necessary.\n      this._readAhead();\n\n      return nbytes;\n    }\n\n    /**\n     * Wait until the given number of bytes are available to read, or end of file.\n     * @param {number} nbytes - max bytes to wait for\n     * @returns {Promise} - resolved with available byte count when ready\n     */\n\n  }, {\n    key: 'buffer',\n    value: function buffer(nbytes) {\n      var _this6 = this;\n\n      return new Promise(function (resolve, reject) {\n        if (!_this6.loaded || _this6.buffering || _this6.seeking) {\n          throw new Error('invalid state');\n        } else if (nbytes !== (nbytes | 0) || nbytes < 0) {\n          throw new Error('invalid input');\n        }\n        var end = _this6._clampToLength(_this6.offset + nbytes);\n        var readable = end - _this6.offset;\n\n        var canceled = false;\n\n        var available = _this6.bytesAvailable(readable);\n        if (available >= readable) {\n          // Requested data is immediately available.\n          resolve(available);\n        } else {\n          _this6.buffering = true;\n\n          // If we don't already have a backend open, start downloading.\n          _this6._openBackend().then(function (backend) {\n            if (backend) {\n              return backend.bufferToOffset(end).then(function () {\n                // We might have to roll over to another download,\n                // so loop back around!\n                _this6.buffering = false;\n                return _this6.buffer(nbytes);\n              });\n            } else {\n              // No more data to read.\n              return Promise.resolve(available);\n            }\n          }).then(function (available) {\n            _this6.buffering = false;\n            resolve(available);\n          }).catch(function (err) {\n            if (err.name !== 'AbortError') {\n              // was already set synchronously; avoid stomping on old promise\n              _this6.buffering = false;\n            }\n            reject(err);\n          });\n        }\n      });\n    }\n\n    /**\n     * Number of bytes available to read immediately from the current offset.\n     * This is the max number of bytes that can be returned from a read() call.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'bytesAvailable',\n    value: function bytesAvailable() {\n      var max = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Infinity;\n\n      return this._cache.bytesReadable(max);\n    }\n\n    /**\n     * Abort any currently running downloads and operations.\n     */\n\n  }, {\n    key: 'abort',\n    value: function abort() {\n      // Clear state synchronously, so can immediately launch new i/o...\n      if (this.loading) {\n        this.loading = false;\n      }\n      if (this.buffering) {\n        this.buffering = false;\n      }\n      if (this.seeking) {\n        this.seeking = false;\n      }\n\n      // Abort any active backend request...\n      if (this._backend) {\n        this._backend.abort();\n        this._backend = null;\n      }\n    }\n\n    /**\n     * Return an array of byte ranges that are buffered.\n     * Each range is a two-element array of start and end.\n     * @returns {Array<Array<number>>}\n     */\n\n  }, {\n    key: 'getBufferedRanges',\n    value: function getBufferedRanges() {\n      return this._cache.ranges();\n    }\n\n    // ------\n    // private methods\n    // ------\n\n  }, {\n    key: '_clampToLength',\n    value: function _clampToLength(offset) {\n      if (this.length < 0) {\n        return offset;\n      } else {\n        return Math.min(this.length, offset);\n      }\n    }\n  }]);\n\n  return StreamFile;\n}();\n\nmodule.exports = StreamFile;\n\n\n//# sourceURL=webpack://ogvjs/./node_modules/stream-file/lib/stream-file.js?");

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://ogvjs/./node_modules/timers-browserify/main.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack://ogvjs/(webpack)/buildin/global.js?");

/***/ }),

/***/ "./node_modules/yuv-canvas/build/shaders.js":
/*!**************************************************!*\
  !*** ./node_modules/yuv-canvas/build/shaders.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = {\n  vertex: \"precision lowp float;\\n\\nattribute vec2 aPosition;\\nattribute vec2 aLumaPosition;\\nattribute vec2 aChromaPosition;\\nvarying vec2 vLumaPosition;\\nvarying vec2 vChromaPosition;\\nvoid main() {\\n    gl_Position = vec4(aPosition, 0, 1);\\n    vLumaPosition = aLumaPosition;\\n    vChromaPosition = aChromaPosition;\\n}\\n\",\n  fragment: \"// inspired by https://github.com/mbebenita/Broadway/blob/master/Player/canvas.js\\n\\nprecision lowp float;\\n\\nuniform sampler2D uTextureY;\\nuniform sampler2D uTextureCb;\\nuniform sampler2D uTextureCr;\\nvarying vec2 vLumaPosition;\\nvarying vec2 vChromaPosition;\\nvoid main() {\\n   // Y, Cb, and Cr planes are uploaded as LUMINANCE textures.\\n   float fY = texture2D(uTextureY, vLumaPosition).x;\\n   float fCb = texture2D(uTextureCb, vChromaPosition).x;\\n   float fCr = texture2D(uTextureCr, vChromaPosition).x;\\n\\n   // Premultipy the Y...\\n   float fYmul = fY * 1.1643828125;\\n\\n   // And convert that to RGB!\\n   gl_FragColor = vec4(\\n     fYmul + 1.59602734375 * fCr - 0.87078515625,\\n     fYmul - 0.39176171875 * fCb - 0.81296875 * fCr + 0.52959375,\\n     fYmul + 2.017234375   * fCb - 1.081390625,\\n     1\\n   );\\n}\\n\",\n  vertexStripe: \"precision lowp float;\\n\\nattribute vec2 aPosition;\\nattribute vec2 aTexturePosition;\\nvarying vec2 vTexturePosition;\\n\\nvoid main() {\\n    gl_Position = vec4(aPosition, 0, 1);\\n    vTexturePosition = aTexturePosition;\\n}\\n\",\n  fragmentStripe: \"// extra 'stripe' texture fiddling to work around IE 11's poor performance on gl.LUMINANCE and gl.ALPHA textures\\n\\nprecision lowp float;\\n\\nuniform sampler2D uStripe;\\nuniform sampler2D uTexture;\\nvarying vec2 vTexturePosition;\\nvoid main() {\\n   // Y, Cb, and Cr planes are mapped into a pseudo-RGBA texture\\n   // so we can upload them without expanding the bytes on IE 11\\n   // which doesn't allow LUMINANCE or ALPHA textures\\n   // The stripe textures mark which channel to keep for each pixel.\\n   // Each texture extraction will contain the relevant value in one\\n   // channel only.\\n\\n   float fLuminance = dot(\\n      texture2D(uStripe, vTexturePosition),\\n      texture2D(uTexture, vTexturePosition)\\n   );\\n\\n   gl_FragColor = vec4(fLuminance, fLuminance, fLuminance, 1);\\n}\\n\"\n};\n\n\n//# sourceURL=webpack://ogvjs/./node_modules/yuv-canvas/build/shaders.js?");

/***/ }),

/***/ "./node_modules/yuv-canvas/src/FrameSink.js":
/*!**************************************************!*\
  !*** ./node_modules/yuv-canvas/src/FrameSink.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("(function() {\n  \"use strict\";\n\n  /**\n   * Create a YUVCanvas and attach it to an HTML5 canvas element.\n   *\n   * This will take over the drawing context of the canvas and may turn\n   * it into a WebGL 3d canvas if possible. Do not attempt to use the\n   * drawing context directly after this.\n   *\n   * @param {HTMLCanvasElement} canvas - HTML canvas element to attach to\n   * @param {YUVCanvasOptions} options - map of options\n   * @throws exception if WebGL requested but unavailable\n   * @constructor\n   * @abstract\n   */\n  function FrameSink(canvas, options) {\n    throw new Error('abstract');\n  }\n\n  /**\n   * Draw a single YUV frame on the underlying canvas, converting to RGB.\n   * If necessary the canvas will be resized to the optimal pixel size\n   * for the given buffer's format.\n   *\n   * @param {YUVBuffer} buffer - the YUV buffer to draw\n   * @see {@link https://www.npmjs.com/package/yuv-buffer|yuv-buffer} for format\n   */\n  FrameSink.prototype.drawFrame = function(buffer) {\n    throw new Error('abstract');\n  };\n\n  /**\n   * Clear the canvas using appropriate underlying 2d or 3d context.\n   */\n  FrameSink.prototype.clear = function() {\n    throw new Error('abstract');\n  };\n\n  module.exports = FrameSink;\n\n})();\n\n\n//# sourceURL=webpack://ogvjs/./node_modules/yuv-canvas/src/FrameSink.js?");

/***/ }),

/***/ "./node_modules/yuv-canvas/src/SoftwareFrameSink.js":
/*!**********************************************************!*\
  !*** ./node_modules/yuv-canvas/src/SoftwareFrameSink.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\nCopyright (c) 2014-2016 Brion Vibber <brion@pobox.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n(function() {\n\t\"use strict\";\n\n\tvar FrameSink = __webpack_require__(/*! ./FrameSink.js */ \"./node_modules/yuv-canvas/src/FrameSink.js\"),\n\t\tYCbCr = __webpack_require__(/*! ./YCbCr.js */ \"./node_modules/yuv-canvas/src/YCbCr.js\");\n\n\t/**\n\t * @param {HTMLCanvasElement} canvas - HTML canvas eledment to attach to\n\t * @constructor\n\t */\n\tfunction SoftwareFrameSink(canvas) {\n\t\tvar self = this,\n\t\t\tctx = canvas.getContext('2d'),\n\t\t\timageData = null,\n\t\t\tresampleCanvas = null,\n\t\t\tresampleContext = null;\n\n\n\n\t\tfunction initImageData(width, height) {\n\t\t\timageData = ctx.createImageData(width, height);\n\n\t\t\t// Prefill the alpha to opaque\n\t\t\tvar data = imageData.data,\n\t\t\t\tpixelCount = width * height * 4;\n\t\t\tfor (var i = 0; i < pixelCount; i += 4) {\n\t\t\t\tdata[i + 3] = 255;\n\t\t\t}\n\t\t}\n\n\t\tfunction initResampleCanvas(cropWidth, cropHeight) {\n\t\t\tresampleCanvas = document.createElement('canvas');\n\t\t\tresampleCanvas.width = cropWidth;\n\t\t\tresampleCanvas.height = cropHeight;\n\t\t\tresampleContext = resampleCanvas.getContext('2d');\n\t\t}\n\n\t\t/**\n\t\t * Actually draw a frame into the canvas.\n\t\t * @param {YUVFrame} buffer - YUV frame buffer object to draw\n\t\t */\n\t\tself.drawFrame = function drawFrame(buffer) {\n\t\t\tvar format = buffer.format;\n\n\t\t\tif (canvas.width !== format.displayWidth || canvas.height !== format.displayHeight) {\n\t\t\t\t// Keep the canvas at the right size...\n\t\t\t\tcanvas.width = format.displayWidth;\n\t\t\t\tcanvas.height = format.displayHeight;\n\t\t\t}\n\n\t\t\tif (imageData === null ||\n\t\t\t\t\timageData.width != format.width ||\n\t\t\t\t\timageData.height != format.height) {\n\t\t\t\tinitImageData(format.width, format.height);\n\t\t\t}\n\n\t\t\t// YUV -> RGB over the entire encoded frame\n\t\t\tYCbCr.convertYCbCr(buffer, imageData.data);\n\n\t\t\tvar resample = (format.cropWidth != format.displayWidth || format.cropHeight != format.displayHeight);\n\t\t\tvar drawContext;\n\t\t\tif (resample) {\n\t\t\t\t// hack for non-square aspect-ratio\n\t\t\t\t// putImageData doesn't resample, so we have to draw in two steps.\n\t\t\t\tif (!resampleCanvas) {\n\t\t\t\t\tinitResampleCanvas(format.cropWidth, format.cropHeight);\n\t\t\t\t}\n\t\t\t\tdrawContext = resampleContext;\n\t\t\t} else {\n\t\t\t\tdrawContext = ctx;\n\t\t\t}\n\n\t\t\t// Draw cropped frame to either the final or temporary canvas\n\t\t\tdrawContext.putImageData(imageData,\n\t\t\t\t-format.cropLeft, -format.cropTop, // must offset the offset\n\t\t\t\tformat.cropLeft, format.cropTop,\n\t\t\t\tformat.cropWidth, format.cropHeight);\n\n\t\t\tif (resample) {\n\t\t\t\tctx.drawImage(resampleCanvas, 0, 0, format.displayWidth, format.displayHeight);\n\t\t\t}\n\t\t};\n\n\t\tself.clear = function() {\n\t\t\tctx.clearRect(0, 0, canvas.width, canvas.height);\n\t\t};\n\n\t\treturn self;\n\t}\n\n\tSoftwareFrameSink.prototype = Object.create(FrameSink.prototype);\n\n\tmodule.exports = SoftwareFrameSink;\n})();\n\n\n//# sourceURL=webpack://ogvjs/./node_modules/yuv-canvas/src/SoftwareFrameSink.js?");

/***/ }),

/***/ "./node_modules/yuv-canvas/src/WebGLFrameSink.js":
/*!*******************************************************!*\
  !*** ./node_modules/yuv-canvas/src/WebGLFrameSink.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\nCopyright (c) 2014-2016 Brion Vibber <brion@pobox.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n(function() {\n\t\"use strict\";\n\n\tvar FrameSink = __webpack_require__(/*! ./FrameSink.js */ \"./node_modules/yuv-canvas/src/FrameSink.js\"),\n\t\tshaders = __webpack_require__(/*! ../build/shaders.js */ \"./node_modules/yuv-canvas/build/shaders.js\");\n\n\t/**\n\t * Warning: canvas must not have been used for 2d drawing prior!\n\t *\n\t * @param {HTMLCanvasElement} canvas - HTML canvas element to attach to\n\t * @constructor\n\t */\n\tfunction WebGLFrameSink(canvas) {\n\t\tvar self = this,\n\t\t\tgl = WebGLFrameSink.contextForCanvas(canvas),\n\t\t\tdebug = false; // swap this to enable more error checks, which can slow down rendering\n\n\t\tif (gl === null) {\n\t\t\tthrow new Error('WebGL unavailable');\n\t\t}\n\n\t\t// GL!\n\t\tfunction checkError() {\n\t\t\tif (debug) {\n\t\t\t\terr = gl.getError();\n\t\t\t\tif (err !== 0) {\n\t\t\t\t\tthrow new Error(\"GL error \" + err);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction compileShader(type, source) {\n\t\t\tvar shader = gl.createShader(type);\n\t\t\tgl.shaderSource(shader, source);\n\t\t\tgl.compileShader(shader);\n\n\t\t\tif (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n\t\t\t\tvar err = gl.getShaderInfoLog(shader);\n\t\t\t\tgl.deleteShader(shader);\n\t\t\t\tthrow new Error('GL shader compilation for ' + type + ' failed: ' + err);\n\t\t\t}\n\n\t\t\treturn shader;\n\t\t}\n\n\n\t\tvar program,\n\t\t\tunpackProgram,\n\t\t\terr;\n\n\t\t// In the world of GL there are no rectangles.\n\t\t// There are only triangles.\n\t\t// THERE IS NO SPOON.\n\t\tvar rectangle = new Float32Array([\n\t\t\t// First triangle (top left, clockwise)\n\t\t\t-1.0, -1.0,\n\t\t\t+1.0, -1.0,\n\t\t\t-1.0, +1.0,\n\n\t\t\t// Second triangle (bottom right, clockwise)\n\t\t\t-1.0, +1.0,\n\t\t\t+1.0, -1.0,\n\t\t\t+1.0, +1.0\n\t\t]);\n\n\t\tvar textures = {};\n\t\tvar framebuffers = {};\n\t\tvar stripes = {};\n\t\tvar buf, positionLocation, unpackPositionLocation;\n\t\tvar unpackTexturePositionBuffer, unpackTexturePositionLocation;\n\t\tvar stripeLocation, unpackTextureLocation;\n\t\tvar lumaPositionBuffer, lumaPositionLocation;\n\t\tvar chromaPositionBuffer, chromaPositionLocation;\n\n\t\tfunction createOrReuseTexture(name) {\n\t\t\tif (!textures[name]) {\n\t\t\t\ttextures[name] = gl.createTexture();\n\t\t\t}\n\t\t\treturn textures[name];\n\t\t}\n\n\t\tfunction uploadTexture(name, width, height, data) {\n\t\t\tvar texture = createOrReuseTexture(name);\n\t\t\tgl.activeTexture(gl.TEXTURE0);\n\n\t\t\tif (WebGLFrameSink.stripe) {\n\t\t\t\tvar uploadTemp = !textures[name + '_temp'];\n\t\t\t\tvar tempTexture = createOrReuseTexture(name + '_temp');\n\t\t\t\tgl.bindTexture(gl.TEXTURE_2D, tempTexture);\n\t\t\t\tif (uploadTemp) {\n\t\t\t\t\t// new texture\n\t\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n\t\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\t\t\t\t\tgl.texImage2D(\n\t\t\t\t\t\tgl.TEXTURE_2D,\n\t\t\t\t\t\t0, // mip level\n\t\t\t\t\t\tgl.RGBA, // internal format\n\t\t\t\t\t\twidth / 4,\n\t\t\t\t\t\theight,\n\t\t\t\t\t\t0, // border\n\t\t\t\t\t\tgl.RGBA, // format\n\t\t\t\t\t\tgl.UNSIGNED_BYTE, // type\n\t\t\t\t\t\tdata // data!\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\t// update texture\n\t\t\t\t\tgl.texSubImage2D(\n\t\t\t\t\t\tgl.TEXTURE_2D,\n\t\t\t\t\t\t0, // mip level\n\t\t\t\t\t\t0, // x offset\n\t\t\t\t\t\t0, // y offset\n\t\t\t\t\t\twidth / 4,\n\t\t\t\t\t\theight,\n\t\t\t\t\t\tgl.RGBA, // format\n\t\t\t\t\t\tgl.UNSIGNED_BYTE, // type\n\t\t\t\t\t\tdata // data!\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tvar stripeTexture = textures[name + '_stripe'];\n\t\t\t\tvar uploadStripe = !stripeTexture;\n\t\t\t\tif (uploadStripe) {\n\t\t\t\t\tstripeTexture = createOrReuseTexture(name + '_stripe');\n\t\t\t\t}\n\t\t\t\tgl.bindTexture(gl.TEXTURE_2D, stripeTexture);\n\t\t\t\tif (uploadStripe) {\n\t\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n\t\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\t\t\t\t\tgl.texImage2D(\n\t\t\t\t\t\tgl.TEXTURE_2D,\n\t\t\t\t\t\t0, // mip level\n\t\t\t\t\t\tgl.RGBA, // internal format\n\t\t\t\t\t\twidth,\n\t\t\t\t\t\t1,\n\t\t\t\t\t\t0, // border\n\t\t\t\t\t\tgl.RGBA, // format\n\t\t\t\t\t\tgl.UNSIGNED_BYTE, //type\n\t\t\t\t\t\tbuildStripe(width, 1) // data!\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tgl.bindTexture(gl.TEXTURE_2D, texture);\n\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n\t\t\t\tgl.texImage2D(\n\t\t\t\t\tgl.TEXTURE_2D,\n\t\t\t\t\t0, // mip level\n\t\t\t\t\tgl.LUMINANCE, // internal format\n\t\t\t\t\twidth,\n\t\t\t\t\theight,\n\t\t\t\t\t0, // border\n\t\t\t\t\tgl.LUMINANCE, // format\n\t\t\t\t\tgl.UNSIGNED_BYTE, //type\n\t\t\t\t\tdata // data!\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tfunction unpackTexture(name, width, height) {\n\t\t\tvar texture = textures[name];\n\n\t\t\t// Upload to a temporary RGBA texture, then unpack it.\n\t\t\t// This is faster than CPU-side swizzling in ANGLE on Windows.\n\t\t\tgl.useProgram(unpackProgram);\n\n\t\t\tvar fb = framebuffers[name];\n\t\t\tif (!fb) {\n\t\t\t\t// Create a framebuffer and an empty target size\n\t\t\t\tgl.activeTexture(gl.TEXTURE0);\n\t\t\t\tgl.bindTexture(gl.TEXTURE_2D, texture);\n\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\t\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n\t\t\t\tgl.texImage2D(\n\t\t\t\t\tgl.TEXTURE_2D,\n\t\t\t\t\t0, // mip level\n\t\t\t\t\tgl.RGBA, // internal format\n\t\t\t\t\twidth,\n\t\t\t\t\theight,\n\t\t\t\t\t0, // border\n\t\t\t\t\tgl.RGBA, // format\n\t\t\t\t\tgl.UNSIGNED_BYTE, //type\n\t\t\t\t\tnull // data!\n\t\t\t\t);\n\n\t\t\t\tfb = framebuffers[name] = gl.createFramebuffer();\n\t\t\t}\n\n\t\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n\t\t\tgl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n\t\t\tvar tempTexture = textures[name + '_temp'];\n\t\t\tgl.activeTexture(gl.TEXTURE1);\n\t\t\tgl.bindTexture(gl.TEXTURE_2D, tempTexture);\n\t\t\tgl.uniform1i(unpackTextureLocation, 1);\n\n\t\t\tvar stripeTexture = textures[name + '_stripe'];\n\t\t\tgl.activeTexture(gl.TEXTURE2);\n\t\t\tgl.bindTexture(gl.TEXTURE_2D, stripeTexture);\n\t\t\tgl.uniform1i(stripeLocation, 2);\n\n\t\t\t// Rectangle geometry\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, buf);\n\t\t\tgl.enableVertexAttribArray(positionLocation);\n\t\t\tgl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n\n\t\t\t// Set up the texture geometry...\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, unpackTexturePositionBuffer);\n\t\t\tgl.enableVertexAttribArray(unpackTexturePositionLocation);\n\t\t\tgl.vertexAttribPointer(unpackTexturePositionLocation, 2, gl.FLOAT, false, 0, 0);\n\n\t\t\t// Draw into the target texture...\n\t\t\tgl.viewport(0, 0, width, height);\n\n\t\t\tgl.drawArrays(gl.TRIANGLES, 0, rectangle.length / 2);\n\n\t\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n\t\t}\n\n\t\tfunction attachTexture(name, register, index) {\n\t\t\tgl.activeTexture(register);\n\t\t\tgl.bindTexture(gl.TEXTURE_2D, textures[name]);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n\n\t\t\tgl.uniform1i(gl.getUniformLocation(program, name), index);\n\t\t}\n\n\t\tfunction buildStripe(width) {\n\t\t\tif (stripes[width]) {\n\t\t\t\treturn stripes[width];\n\t\t\t}\n\t\t\tvar len = width,\n\t\t\t\tout = new Uint32Array(len);\n\t\t\tfor (var i = 0; i < len; i += 4) {\n\t\t\t\tout[i    ] = 0x000000ff;\n\t\t\t\tout[i + 1] = 0x0000ff00;\n\t\t\t\tout[i + 2] = 0x00ff0000;\n\t\t\t\tout[i + 3] = 0xff000000;\n\t\t\t}\n\t\t\treturn stripes[width] = new Uint8Array(out.buffer);\n\t\t}\n\n\t\tfunction initProgram(vertexShaderSource, fragmentShaderSource) {\n\t\t\tvar vertexShader = compileShader(gl.VERTEX_SHADER, vertexShaderSource);\n\t\t\tvar fragmentShader = compileShader(gl.FRAGMENT_SHADER, fragmentShaderSource);\n\n\t\t\tvar program = gl.createProgram();\n\t\t\tgl.attachShader(program, vertexShader);\n\t\t\tgl.attachShader(program, fragmentShader);\n\n\t\t\tgl.linkProgram(program);\n\t\t\tif (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n\t\t\t\tvar err = gl.getProgramInfoLog(program);\n\t\t\t\tgl.deleteProgram(program);\n\t\t\t\tthrow new Error('GL program linking failed: ' + err);\n\t\t\t}\n\n\t\t\treturn program;\n\t\t}\n\n\t\tfunction init() {\n\t\t\tif (WebGLFrameSink.stripe) {\n\t\t\t\tunpackProgram = initProgram(shaders.vertexStripe, shaders.fragmentStripe);\n\t\t\t\tunpackPositionLocation = gl.getAttribLocation(unpackProgram, 'aPosition');\n\n\t\t\t\tunpackTexturePositionBuffer = gl.createBuffer();\n\t\t\t\tvar textureRectangle = new Float32Array([\n\t\t\t\t\t0, 0,\n\t\t\t\t\t1, 0,\n\t\t\t\t\t0, 1,\n\t\t\t\t\t0, 1,\n\t\t\t\t\t1, 0,\n\t\t\t\t\t1, 1\n\t\t\t\t]);\n\t\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, unpackTexturePositionBuffer);\n\t\t\t\tgl.bufferData(gl.ARRAY_BUFFER, textureRectangle, gl.STATIC_DRAW);\n\n\t\t\t\tunpackTexturePositionLocation = gl.getAttribLocation(unpackProgram, 'aTexturePosition');\n\t\t\t\tstripeLocation = gl.getUniformLocation(unpackProgram, 'uStripe');\n\t\t\t\tunpackTextureLocation = gl.getUniformLocation(unpackProgram, 'uTexture');\n\t\t\t}\n\t\t\tprogram = initProgram(shaders.vertex, shaders.fragment);\n\n\t\t\tbuf = gl.createBuffer();\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, buf);\n\t\t\tgl.bufferData(gl.ARRAY_BUFFER, rectangle, gl.STATIC_DRAW);\n\n\t\t\tpositionLocation = gl.getAttribLocation(program, 'aPosition');\n\t\t\tlumaPositionBuffer = gl.createBuffer();\n\t\t\tlumaPositionLocation = gl.getAttribLocation(program, 'aLumaPosition');\n\t\t\tchromaPositionBuffer = gl.createBuffer();\n\t\t\tchromaPositionLocation = gl.getAttribLocation(program, 'aChromaPosition');\n\t\t}\n\n\t\t/**\n\t\t * Actually draw a frame.\n\t\t * @param {YUVFrame} buffer - YUV frame buffer object\n\t\t */\n\t\tself.drawFrame = function(buffer) {\n\t\t\tvar format = buffer.format;\n\n\t\t\tvar formatUpdate = (!program || canvas.width !== format.displayWidth || canvas.height !== format.displayHeight);\n\t\t\tif (formatUpdate) {\n\t\t\t\t// Keep the canvas at the right size...\n\t\t\t\tcanvas.width = format.displayWidth;\n\t\t\t\tcanvas.height = format.displayHeight;\n\t\t\t\tself.clear();\n\t\t\t}\n\n\t\t\tif (!program) {\n\t\t\t\tinit();\n\t\t\t}\n\n\t\t\tif (formatUpdate) {\n\t\t\t\tvar setupTexturePosition = function(buffer, location, texWidth) {\n\t\t\t\t\t// Warning: assumes that the stride for Cb and Cr is the same size in output pixels\n\t\t\t\t\tvar textureX0 = format.cropLeft / texWidth;\n\t\t\t\t\tvar textureX1 = (format.cropLeft + format.cropWidth) / texWidth;\n\t\t\t\t\tvar textureY0 = (format.cropTop + format.cropHeight) / format.height;\n\t\t\t\t\tvar textureY1 = format.cropTop / format.height;\n\t\t\t\t\tvar textureRectangle = new Float32Array([\n\t\t\t\t\t\ttextureX0, textureY0,\n\t\t\t\t\t\ttextureX1, textureY0,\n\t\t\t\t\t\ttextureX0, textureY1,\n\t\t\t\t\t\ttextureX0, textureY1,\n\t\t\t\t\t\ttextureX1, textureY0,\n\t\t\t\t\t\ttextureX1, textureY1\n\t\t\t\t\t]);\n\n\t\t\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\t\t\t\t\tgl.bufferData(gl.ARRAY_BUFFER, textureRectangle, gl.STATIC_DRAW);\n\t\t\t\t};\n\t\t\t\tsetupTexturePosition(\n\t\t\t\t\tlumaPositionBuffer,\n\t\t\t\t\tlumaPositionLocation,\n\t\t\t\t\tbuffer.y.stride);\n\t\t\t\tsetupTexturePosition(\n\t\t\t\t\tchromaPositionBuffer,\n\t\t\t\t\tchromaPositionLocation,\n\t\t\t\t\tbuffer.u.stride * format.width / format.chromaWidth);\n\t\t\t}\n\n\t\t\t// Create or update the textures...\n\t\t\tuploadTexture('uTextureY', buffer.y.stride, format.height, buffer.y.bytes);\n\t\t\tuploadTexture('uTextureCb', buffer.u.stride, format.chromaHeight, buffer.u.bytes);\n\t\t\tuploadTexture('uTextureCr', buffer.v.stride, format.chromaHeight, buffer.v.bytes);\n\n\t\t\tif (WebGLFrameSink.stripe) {\n\t\t\t\t// Unpack the textures after upload to avoid blocking on GPU\n\t\t\t\tunpackTexture('uTextureY', buffer.y.stride, format.height);\n\t\t\t\tunpackTexture('uTextureCb', buffer.u.stride, format.chromaHeight);\n\t\t\t\tunpackTexture('uTextureCr', buffer.v.stride, format.chromaHeight);\n\t\t\t}\n\n\t\t\t// Set up the rectangle and draw it\n\t\t\tgl.useProgram(program);\n\t\t\tgl.viewport(0, 0, canvas.width, canvas.height);\n\n\t\t\tattachTexture('uTextureY', gl.TEXTURE0, 0);\n\t\t\tattachTexture('uTextureCb', gl.TEXTURE1, 1);\n\t\t\tattachTexture('uTextureCr', gl.TEXTURE2, 2);\n\n\t\t\t// Set up geometry\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, buf);\n\t\t\tgl.enableVertexAttribArray(positionLocation);\n\t\t\tgl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n\n\t\t\t// Set up the texture geometry...\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, lumaPositionBuffer);\n\t\t\tgl.enableVertexAttribArray(lumaPositionLocation);\n\t\t\tgl.vertexAttribPointer(lumaPositionLocation, 2, gl.FLOAT, false, 0, 0);\n\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, chromaPositionBuffer);\n\t\t\tgl.enableVertexAttribArray(chromaPositionLocation);\n\t\t\tgl.vertexAttribPointer(chromaPositionLocation, 2, gl.FLOAT, false, 0, 0);\n\n\t\t\t// Aaaaand draw stuff.\n\t\t\tgl.drawArrays(gl.TRIANGLES, 0, rectangle.length / 2);\n\t\t};\n\n\t\tself.clear = function() {\n\t\t\tgl.viewport(0, 0, canvas.width, canvas.height);\n\t\t\tgl.clearColor(0.0, 0.0, 0.0, 0.0);\n\t\t\tgl.clear(gl.COLOR_BUFFER_BIT);\n\t\t};\n\n\t\tself.clear();\n\n\t\treturn self;\n\t}\n\n\t// For Windows; luminance and alpha textures are ssllooww to upload,\n\t// so we pack into RGBA and unpack in the shaders.\n\t//\n\t// This seems to affect all browsers on Windows, probably due to fun\n\t// mismatches between GL and D3D.\n\tWebGLFrameSink.stripe = (function() {\n\t\tif (navigator.userAgent.indexOf('Windows') !== -1) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t})();\n\n\tWebGLFrameSink.contextForCanvas = function(canvas) {\n\t\tvar options = {\n\t\t\t// Don't trigger discrete GPU in multi-GPU systems\n\t\t\tpreferLowPowerToHighPerformance: true,\n\t\t\tpowerPreference: 'low-power',\n\t\t\t// Don't try to use software GL rendering!\n\t\t\tfailIfMajorPerformanceCaveat: true,\n\t\t\t// In case we need to capture the resulting output.\n\t\t\tpreserveDrawingBuffer: true\n\t\t};\n\t\treturn canvas.getContext('webgl', options) || canvas.getContext('experimental-webgl', options);\n\t};\n\n\t/**\n\t * Static function to check if WebGL will be available with appropriate features.\n\t *\n\t * @returns {boolean} - true if available\n\t */\n\tWebGLFrameSink.isAvailable = function() {\n\t\tvar canvas = document.createElement('canvas'),\n\t\t\tgl;\n\t\tcanvas.width = 1;\n\t\tcanvas.height = 1;\n\t\ttry {\n\t\t\tgl = WebGLFrameSink.contextForCanvas(canvas);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t\tif (gl) {\n\t\t\tvar register = gl.TEXTURE0,\n\t\t\t\twidth = 4,\n\t\t\t\theight = 4,\n\t\t\t\ttexture = gl.createTexture(),\n\t\t\t\tdata = new Uint8Array(width * height),\n\t\t\t\ttexWidth = WebGLFrameSink.stripe ? (width / 4) : width,\n\t\t\t\tformat = WebGLFrameSink.stripe ? gl.RGBA : gl.LUMINANCE,\n\t\t\t\tfilter = WebGLFrameSink.stripe ? gl.NEAREST : gl.LINEAR;\n\n\t\t\tgl.activeTexture(register);\n\t\t\tgl.bindTexture(gl.TEXTURE_2D, texture);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);\n\t\t\tgl.texImage2D(\n\t\t\t\tgl.TEXTURE_2D,\n\t\t\t\t0, // mip level\n\t\t\t\tformat, // internal format\n\t\t\t\ttexWidth,\n\t\t\t\theight,\n\t\t\t\t0, // border\n\t\t\t\tformat, // format\n\t\t\t\tgl.UNSIGNED_BYTE, //type\n\t\t\t\tdata // data!\n\t\t\t);\n\n\t\t\tvar err = gl.getError();\n\t\t\tif (err) {\n\t\t\t\t// Doesn't support luminance textures?\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\tWebGLFrameSink.prototype = Object.create(FrameSink.prototype);\n\n\tmodule.exports = WebGLFrameSink;\n})();\n\n\n//# sourceURL=webpack://ogvjs/./node_modules/yuv-canvas/src/WebGLFrameSink.js?");

/***/ }),

/***/ "./node_modules/yuv-canvas/src/YCbCr.js":
/*!**********************************************!*\
  !*** ./node_modules/yuv-canvas/src/YCbCr.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\nCopyright (c) 2014-2019 Brion Vibber <brion@pobox.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n(function() {\n\t\"use strict\";\n\n\tvar depower = __webpack_require__(/*! ./depower.js */ \"./node_modules/yuv-canvas/src/depower.js\");\n\n\t/**\n\t * Basic YCbCr->RGB conversion\n\t *\n\t * @author Brion Vibber <brion@pobox.com>\n\t * @copyright 2014-2019\n\t * @license MIT-style\n\t *\n\t * @param {YUVFrame} buffer - input frame buffer\n\t * @param {Uint8ClampedArray} output - array to draw RGBA into\n\t * Assumes that the output array already has alpha channel set to opaque.\n\t */\n\tfunction convertYCbCr(buffer, output) {\n\t\tvar width = buffer.format.width | 0,\n\t\t\theight = buffer.format.height | 0,\n\t\t\thdec = depower(buffer.format.width / buffer.format.chromaWidth) | 0,\n\t\t\tvdec = depower(buffer.format.height / buffer.format.chromaHeight) | 0,\n\t\t\tbytesY = buffer.y.bytes,\n\t\t\tbytesCb = buffer.u.bytes,\n\t\t\tbytesCr = buffer.v.bytes,\n\t\t\tstrideY = buffer.y.stride | 0,\n\t\t\tstrideCb = buffer.u.stride | 0,\n\t\t\tstrideCr = buffer.v.stride | 0,\n\t\t\toutStride = width << 2,\n\t\t\tYPtr = 0, Y0Ptr = 0, Y1Ptr = 0,\n\t\t\tCbPtr = 0, CrPtr = 0,\n\t\t\toutPtr = 0, outPtr0 = 0, outPtr1 = 0,\n\t\t\tcolorCb = 0, colorCr = 0,\n\t\t\tmultY = 0, multCrR = 0, multCbCrG = 0, multCbB = 0,\n\t\t\tx = 0, y = 0, xdec = 0, ydec = 0;\n\n\t\tif (hdec == 1 && vdec == 1) {\n\t\t\t// Optimize for 4:2:0, which is most common\n\t\t\toutPtr0 = 0;\n\t\t\toutPtr1 = outStride;\n\t\t\tydec = 0;\n\t\t\tfor (y = 0; y < height; y += 2) {\n\t\t\t\tY0Ptr = y * strideY | 0;\n\t\t\t\tY1Ptr = Y0Ptr + strideY | 0;\n\t\t\t\tCbPtr = ydec * strideCb | 0;\n\t\t\t\tCrPtr = ydec * strideCr | 0;\n\t\t\t\tfor (x = 0; x < width; x += 2) {\n\t\t\t\t\tcolorCb = bytesCb[CbPtr++] | 0;\n\t\t\t\t\tcolorCr = bytesCr[CrPtr++] | 0;\n\n\t\t\t\t\t// Quickie YUV conversion\n\t\t\t\t\t// https://en.wikipedia.org/wiki/YCbCr#ITU-R_BT.2020_conversion\n\t\t\t\t\t// multiplied by 256 for integer-friendliness\n\t\t\t\t\tmultCrR   = (409 * colorCr | 0) - 57088 | 0;\n\t\t\t\t\tmultCbCrG = (100 * colorCb | 0) + (208 * colorCr | 0) - 34816 | 0;\n\t\t\t\t\tmultCbB   = (516 * colorCb | 0) - 70912 | 0;\n\n\t\t\t\t\tmultY = 298 * bytesY[Y0Ptr++] | 0;\n\t\t\t\t\toutput[outPtr0    ] = (multY + multCrR) >> 8;\n\t\t\t\t\toutput[outPtr0 + 1] = (multY - multCbCrG) >> 8;\n\t\t\t\t\toutput[outPtr0 + 2] = (multY + multCbB) >> 8;\n\t\t\t\t\toutPtr0 += 4;\n\n\t\t\t\t\tmultY = 298 * bytesY[Y0Ptr++] | 0;\n\t\t\t\t\toutput[outPtr0    ] = (multY + multCrR) >> 8;\n\t\t\t\t\toutput[outPtr0 + 1] = (multY - multCbCrG) >> 8;\n\t\t\t\t\toutput[outPtr0 + 2] = (multY + multCbB) >> 8;\n\t\t\t\t\toutPtr0 += 4;\n\n\t\t\t\t\tmultY = 298 * bytesY[Y1Ptr++] | 0;\n\t\t\t\t\toutput[outPtr1    ] = (multY + multCrR) >> 8;\n\t\t\t\t\toutput[outPtr1 + 1] = (multY - multCbCrG) >> 8;\n\t\t\t\t\toutput[outPtr1 + 2] = (multY + multCbB) >> 8;\n\t\t\t\t\toutPtr1 += 4;\n\n\t\t\t\t\tmultY = 298 * bytesY[Y1Ptr++] | 0;\n\t\t\t\t\toutput[outPtr1    ] = (multY + multCrR) >> 8;\n\t\t\t\t\toutput[outPtr1 + 1] = (multY - multCbCrG) >> 8;\n\t\t\t\t\toutput[outPtr1 + 2] = (multY + multCbB) >> 8;\n\t\t\t\t\toutPtr1 += 4;\n\t\t\t\t}\n\t\t\t\toutPtr0 += outStride;\n\t\t\t\toutPtr1 += outStride;\n\t\t\t\tydec++;\n\t\t\t}\n\t\t} else {\n\t\t\toutPtr = 0;\n\t\t\tfor (y = 0; y < height; y++) {\n\t\t\t\txdec = 0;\n\t\t\t\tydec = y >> vdec;\n\t\t\t\tYPtr = y * strideY | 0;\n\t\t\t\tCbPtr = ydec * strideCb | 0;\n\t\t\t\tCrPtr = ydec * strideCr | 0;\n\n\t\t\t\tfor (x = 0; x < width; x++) {\n\t\t\t\t\txdec = x >> hdec;\n\t\t\t\t\tcolorCb = bytesCb[CbPtr + xdec] | 0;\n\t\t\t\t\tcolorCr = bytesCr[CrPtr + xdec] | 0;\n\n\t\t\t\t\t// Quickie YUV conversion\n\t\t\t\t\t// https://en.wikipedia.org/wiki/YCbCr#ITU-R_BT.2020_conversion\n\t\t\t\t\t// multiplied by 256 for integer-friendliness\n\t\t\t\t\tmultCrR   = (409 * colorCr | 0) - 57088 | 0;\n\t\t\t\t\tmultCbCrG = (100 * colorCb | 0) + (208 * colorCr | 0) - 34816 | 0;\n\t\t\t\t\tmultCbB   = (516 * colorCb | 0) - 70912 | 0;\n\n\t\t\t\t\tmultY = 298 * bytesY[YPtr++] | 0;\n\t\t\t\t\toutput[outPtr    ] = (multY + multCrR) >> 8;\n\t\t\t\t\toutput[outPtr + 1] = (multY - multCbCrG) >> 8;\n\t\t\t\t\toutput[outPtr + 2] = (multY + multCbB) >> 8;\n\t\t\t\t\toutPtr += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmodule.exports = {\n\t\tconvertYCbCr: convertYCbCr\n\t};\n})();\n\n\n//# sourceURL=webpack://ogvjs/./node_modules/yuv-canvas/src/YCbCr.js?");

/***/ }),

/***/ "./node_modules/yuv-canvas/src/depower.js":
/*!************************************************!*\
  !*** ./node_modules/yuv-canvas/src/depower.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\nCopyright (c) 2014-2016 Brion Vibber <brion@pobox.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n(function() {\n  \"use strict\";\n\n  /**\n   * Convert a ratio into a bit-shift count; for instance a ratio of 2\n   * becomes a bit-shift of 1, while a ratio of 1 is a bit-shift of 0.\n   *\n   * @author Brion Vibber <brion@pobox.com>\n   * @copyright 2016\n   * @license MIT-style\n   *\n   * @param {number} ratio - the integer ratio to convert.\n   * @returns {number} - number of bits to shift to multiply/divide by the ratio.\n   * @throws exception if given a non-power-of-two\n   */\n  function depower(ratio) {\n    var shiftCount = 0,\n      n = ratio >> 1;\n    while (n != 0) {\n      n = n >> 1;\n      shiftCount++\n    }\n    if (ratio !== (1 << shiftCount)) {\n      throw 'chroma plane dimensions must be power of 2 ratio to luma plane dimensions; got ' + ratio;\n    }\n    return shiftCount;\n  }\n\n  module.exports = depower;\n})();\n\n\n//# sourceURL=webpack://ogvjs/./node_modules/yuv-canvas/src/depower.js?");

/***/ }),

/***/ "./node_modules/yuv-canvas/src/yuv-canvas.js":
/*!***************************************************!*\
  !*** ./node_modules/yuv-canvas/src/yuv-canvas.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\nCopyright (c) 2014-2016 Brion Vibber <brion@pobox.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n(function() {\n  \"use strict\";\n\n  var FrameSink = __webpack_require__(/*! ./FrameSink.js */ \"./node_modules/yuv-canvas/src/FrameSink.js\"),\n    SoftwareFrameSink = __webpack_require__(/*! ./SoftwareFrameSink.js */ \"./node_modules/yuv-canvas/src/SoftwareFrameSink.js\"),\n    WebGLFrameSink = __webpack_require__(/*! ./WebGLFrameSink.js */ \"./node_modules/yuv-canvas/src/WebGLFrameSink.js\");\n\n  /**\n   * @typedef {Object} YUVCanvasOptions\n   * @property {boolean} webGL - Whether to use WebGL to draw to the canvas and accelerate color space conversion. If left out, defaults to auto-detect.\n   */\n\n  var YUVCanvas = {\n    FrameSink: FrameSink,\n\n    SoftwareFrameSink: SoftwareFrameSink,\n\n    WebGLFrameSink: WebGLFrameSink,\n\n    /**\n     * Attach a suitable FrameSink instance to an HTML5 canvas element.\n     *\n     * This will take over the drawing context of the canvas and may turn\n     * it into a WebGL 3d canvas if possible. Do not attempt to use the\n     * drawing context directly after this.\n     *\n     * @param {HTMLCanvasElement} canvas - HTML canvas element to attach to\n     * @param {YUVCanvasOptions} options - map of options\n     * @returns {FrameSink} - instance of suitable subclass.\n     */\n    attach: function(canvas, options) {\n      options = options || {};\n      var webGL = ('webGL' in options) ? options.webGL : WebGLFrameSink.isAvailable();\n      if (webGL) {\n        return new WebGLFrameSink(canvas, options);\n      } else {\n        return new SoftwareFrameSink(canvas, options);\n      }\n    }\n  };\n\n  module.exports = YUVCanvas;\n})();\n\n\n//# sourceURL=webpack://ogvjs/./node_modules/yuv-canvas/src/yuv-canvas.js?");

/***/ }),

/***/ "./src/js/Bisector.js":
/*!****************************!*\
  !*** ./src/js/Bisector.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\n/**\n * Give as your 'process' function something that will trigger an async\n * operation, then call the left() or right() methods to run another\n * iteration, bisecting to the given direction.\n *\n * Caller is responsible for determining when done.\n *\n * @params options object {\n *   start: number,\n *   end: number,\n *   process: function(start, position, end)\n * }\n */\nclass Bisector {\n  constructor(options) {\n    this.lower = options.start;\n    this.upper = options.end;\n    this.onprocess = options.process;\n    this.position = 0;\n    this.n = 0;\n  }\n\n  iterate() {\n    this.n++;\n    this.position = Math.floor((this.lower + this.upper) / 2);\n    return this.onprocess(this.lower, this.upper, this.position);\n  }\n\n  start() {\n    this.iterate();\n    return this;\n  }\n\n  left() {\n    this.upper = this.position;\n    return this.iterate();\n  }\n\n  right() {\n    this.lower = this.position;\n    return this.iterate();\n  }\n\n}\n\nvar _default = Bisector;\nexports.default = _default;\n\n//# sourceURL=webpack://ogvjs/./src/js/Bisector.js?");

/***/ }),

/***/ "./src/js/BogoSlow.js":
/*!****************************!*\
  !*** ./src/js/BogoSlow.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * A quick CPU/JS engine benchmark to guesstimate whether we're\n * fast enough to handle 360p video in JavaScript.\n */\n\nfunction BogoSlow() {\n  var self = this;\n  var timer; // FIXME: avoid to use window scope here\n\n  if (window.performance && window.performance.now) {\n    timer = function timer() {\n      return window.performance.now();\n    };\n  } else {\n    timer = function timer() {\n      return Date.now();\n    };\n  }\n\n  var savedSpeed = null;\n\n  function run() {\n    var ops = 0;\n\n    var fibonacci = function fibonacci(n) {\n      ops++;\n\n      if (n < 2) {\n        return n;\n      } else {\n        return fibonacci(n - 2) + fibonacci(n - 1);\n      }\n    };\n\n    var start = timer();\n    fibonacci(30);\n    var delta = timer() - start;\n    savedSpeed = ops / delta;\n  }\n  /**\n   * Return a scale value of operations/sec from the benchmark.\n   * If the benchmark has already been run, uses a memoized result.\n   *\n   * @property {number}\n   */\n\n\n  Object.defineProperty(self, 'speed', {\n    get: function get() {\n      if (savedSpeed === null) {\n        run();\n      }\n\n      return savedSpeed;\n    }\n  });\n  /**\n   * Return the defined cutoff speed value for 'slow' devices,\n   * based on results measured from some test devices.\n   *\n   * @property {number}\n   */\n\n  Object.defineProperty(self, 'slowCutoff', {\n    get: function get() {\n      // 2012 Retina MacBook Pro (Safari 7)  ~150,000\n      // 2009 Dell T5500         (IE 11)     ~100,000\n      // iPad Air                (iOS 7)      ~65,000\n      // 2010 MBP / OS X 10.9    (Safari 7)   ~62,500\n      // 2010 MBP / Win7 VM      (IE 11)      ~50,000+-\n      //   ^ these play 360p ok\n      // ----------- line of moderate doom ----------\n      return 50000; //   v these play 160p ok\n      // iPad Mini non-Retina    (iOS 8 beta) ~25,000\n      // Dell Inspiron Duo       (IE 11)      ~25,000\n      // Surface RT              (IE 11)      ~18,000\n      // iPod Touch 5th-gen      (iOS 8 beta) ~16,000\n    }\n  });\n  /**\n   * Return the defined cutoff speed value for 'too slow' devices,\n   * based on results measured from some test devices.\n   *\n   * No longer used.\n   *\n   * @property {number}\n   * @deprecated\n   */\n\n  Object.defineProperty(self, 'tooSlowCutoff', {\n    get: function get() {\n      return 0;\n    }\n  });\n  /**\n   * 'Slow' devices can play audio and should sorta play our\n   * extra-tiny Wikimedia 160p15 transcodes\n   *\n   * @property {boolean}\n   */\n\n  Object.defineProperty(self, 'slow', {\n    get: function get() {\n      return self.speed < self.slowCutoff;\n    }\n  });\n  /**\n   * 'Too slow' devices aren't reliable at all\n   *\n   * @property {boolean}\n   */\n\n  Object.defineProperty(self, 'tooSlow', {\n    get: function get() {\n      return self.speed < self.tooSlowCutoff;\n    }\n  });\n}\n\nmodule.exports = BogoSlow;\n\n//# sourceURL=webpack://ogvjs/./src/js/BogoSlow.js?");

/***/ }),

/***/ "./src/js/OGVCompat.js":
/*!*****************************!*\
  !*** ./src/js/OGVCompat.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _BogoSlow = _interopRequireDefault(__webpack_require__(/*! ./BogoSlow.js */ \"./src/js/BogoSlow.js\"));\n\nlet OGVCompat = new class {\n  constructor() {\n    this.benchmark = new _BogoSlow.default();\n  }\n\n  hasTypedArrays() {\n    // emscripten-compiled code requires typed arrays\n    return !!window.Uint32Array;\n  }\n\n  hasWebAudio() {\n    return !!(window.AudioContext || window.webkitAudioContext);\n  }\n\n  hasFlash() {\n    if (navigator.userAgent.indexOf('Trident') !== -1) {\n      // We only do the ActiveX test because we only need Flash in\n      // Internet Explorer 10/11. Other browsers use Web Audio directly\n      // (Edge, Safari) or native playback, so there's no need to test\n      // other ways of loading Flash.\n      try {\n        let obj = new ActiveXObject('ShockwaveFlash.ShockwaveFlash');\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n\n    return false;\n  }\n\n  hasAudio() {\n    return this.hasWebAudio() || this.hasFlash();\n  }\n\n  isBlacklisted(userAgent) {\n    // JIT bugs in old Safari versions\n    let blacklist = [/\\(i.* OS [6789]_.* like Mac OS X\\).* Mobile\\/.* Safari\\//, /\\(Macintosh.* Version\\/6\\..* Safari\\/\\d/];\n    let blacklisted = false;\n    blacklist.forEach(regex => {\n      if (userAgent.match(regex)) {\n        blacklisted = true;\n      }\n    });\n    return blacklisted;\n  }\n\n  isSlow() {\n    return this.benchmark.slow;\n  }\n\n  isTooSlow() {\n    return this.benchmark.tooSlow;\n  }\n\n  supported(component) {\n    if (component === 'OGVDecoder') {\n      return this.hasTypedArrays() && !this.isBlacklisted(navigator.userAgent);\n    }\n\n    if (component === 'OGVPlayer') {\n      return this.supported('OGVDecoder') && this.hasAudio() && !this.isTooSlow();\n    }\n\n    return false;\n  }\n\n}();\nvar _default = OGVCompat;\nexports.default = _default;\n\n//# sourceURL=webpack://ogvjs/./src/js/OGVCompat.js?");

/***/ }),

/***/ "./src/js/OGVDecoderAudioProxy.js":
/*!****************************************!*\
  !*** ./src/js/OGVDecoderAudioProxy.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _OGVProxyClass = _interopRequireDefault(__webpack_require__(/*! ./OGVProxyClass.js */ \"./src/js/OGVProxyClass.js\"));\n\nclass OGVDecoderAudioProxy extends (0, _OGVProxyClass.default)({\n  loadedMetadata: false,\n  audioFormat: null,\n  audioBuffer: null,\n  cpuTime: 0\n}) {\n  init(callback) {\n    this.proxy('init', [], callback);\n  }\n\n  processHeader(data, callback) {\n    this.proxy('processHeader', [data], callback, [data]);\n  }\n\n  processAudio(data, callback) {\n    this.proxy('processAudio', [data], callback, [data]);\n  }\n\n  close() {\n    this.terminate();\n  }\n\n}\n\nvar _default = OGVDecoderAudioProxy;\nexports.default = _default;\n\n//# sourceURL=webpack://ogvjs/./src/js/OGVDecoderAudioProxy.js?");

/***/ }),

/***/ "./src/js/OGVDecoderVideoProxy.js":
/*!****************************************!*\
  !*** ./src/js/OGVDecoderVideoProxy.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _OGVProxyClass = _interopRequireDefault(__webpack_require__(/*! ./OGVProxyClass.js */ \"./src/js/OGVProxyClass.js\"));\n\nclass OGVDecoderVideoProxy extends (0, _OGVProxyClass.default)({\n  loadedMetadata: false,\n  videoFormat: null,\n  frameBuffer: null,\n  cpuTime: 0\n}) {\n  init(callback) {\n    this.proxy('init', [], callback);\n  }\n\n  processHeader(data, callback) {\n    this.proxy('processHeader', [data], callback, [data]);\n  }\n\n  processFrame(data, callback) {\n    this.proxy('processFrame', [data], callback, [data]);\n  }\n\n  close() {\n    this.terminate();\n  }\n\n  sync() {\n    this.proxy('sync', [], () => {});\n  }\n\n  recycleFrame(frame) {\n    this.proxy('recycleFrame', [frame], () => {}, [frame.y.bytes.buffer, frame.u.bytes.buffer, frame.v.bytes.buffer]);\n  }\n\n}\n\nvar _default = OGVDecoderVideoProxy;\nexports.default = _default;\n\n//# sourceURL=webpack://ogvjs/./src/js/OGVDecoderVideoProxy.js?");

/***/ }),

/***/ "./src/js/OGVLoaderBase.js":
/*!*********************************!*\
  !*** ./src/js/OGVLoaderBase.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _WebAssemblyCheck = _interopRequireDefault(__webpack_require__(/*! ./WebAssemblyCheck.js */ \"./src/js/WebAssemblyCheck.js\"));\n\nconst OGVVersion = undefined;\nconst scriptMap = {\n  OGVDemuxerOgg: 'ogv-demuxer-ogg.js',\n  OGVDemuxerOggW: 'ogv-demuxer-ogg-wasm.js',\n  OGVDemuxerWebM: 'ogv-demuxer-webm.js',\n  OGVDemuxerWebMW: 'ogv-demuxer-webm-wasm.js',\n  OGVDecoderAudioOpus: 'ogv-decoder-audio-opus.js',\n  OGVDecoderAudioOpusW: 'ogv-decoder-audio-opus-wasm.js',\n  OGVDecoderAudioVorbis: 'ogv-decoder-audio-vorbis.js',\n  OGVDecoderAudioVorbisW: 'ogv-decoder-audio-vorbis-wasm.js',\n  OGVDecoderVideoTheora: 'ogv-decoder-video-theora.js',\n  OGVDecoderVideoTheoraW: 'ogv-decoder-video-theora-wasm.js',\n  OGVDecoderVideoVP8: 'ogv-decoder-video-vp8.js',\n  OGVDecoderVideoVP8W: 'ogv-decoder-video-vp8-wasm.js',\n  OGVDecoderVideoVP8MTW: 'ogv-decoder-video-vp8-mt-wasm.js',\n  OGVDecoderVideoVP9: 'ogv-decoder-video-vp9.js',\n  OGVDecoderVideoVP9W: 'ogv-decoder-video-vp9-wasm.js',\n  OGVDecoderVideoVP9SIMDW: 'ogv-decoder-video-vp9-simd-wasm.js',\n  OGVDecoderVideoVP9MTW: 'ogv-decoder-video-vp9-mt-wasm.js',\n  OGVDecoderVideoVP9SIMDMTW: 'ogv-decoder-video-vp9-simd-mt-wasm.js',\n  OGVDecoderVideoAV1: 'ogv-decoder-video-av1.js',\n  OGVDecoderVideoAV1W: 'ogv-decoder-video-av1-wasm.js',\n  OGVDecoderVideoAV1SIMDW: 'ogv-decoder-video-av1-simd-wasm.js',\n  OGVDecoderVideoAV1MTW: 'ogv-decoder-video-av1-mt-wasm.js',\n  OGVDecoderVideoAV1SIMDMTW: 'ogv-decoder-video-av1-simd-mt-wasm.js'\n};\n\nclass OGVLoaderBase {\n  constructor() {\n    this.base = this.defaultBase();\n  }\n\n  defaultBase() {\n    return undefined;\n  }\n\n  wasmSupported() {\n    return _WebAssemblyCheck.default.wasmSupported();\n  }\n\n  scriptForClass(className) {\n    return scriptMap[className];\n  }\n\n  urlForClass(className) {\n    let scriptName = this.scriptForClass(className);\n\n    if (scriptName) {\n      return this.urlForScript(scriptName);\n    } else {\n      throw new Error('asked for URL for unknown class ' + className);\n    }\n  }\n\n  urlForScript(scriptName) {\n    if (scriptName) {\n      let base = this.base;\n\n      if (base === undefined) {\n        base = '';\n      } else {\n        base += '/';\n      }\n\n      return base + scriptName + '?version=' + encodeURIComponent(OGVVersion);\n    } else {\n      throw new Error('asked for URL for unknown script ' + scriptName);\n    }\n  }\n\n  loadClass(className, callback, options) {\n    options = options || {};\n    let global = this.getGlobal();\n    let url = this.urlForClass(className);\n\n    let classWrapper = options => {\n      options = options || {};\n\n      options.locateFile = filename => {\n        // Allow secondary resources like the .wasm payload\n        // to be loaded by the emscripten code.\n        if (filename.slice(0, 5) === 'data:') {\n          // emscripten 1.37.25 loads memory initializers as data: URI\n          return filename;\n        } else {\n          return this.urlForScript(filename);\n        }\n      };\n\n      options.mainScriptUrlOrBlob = this.scriptForClass(className) + '?version=' + encodeURIComponent(OGVVersion); // Note: these pseudoclasses should not use 'new',\n      // which breaks in emscripten 1.38.10\n\n      return global[className](options);\n    };\n\n    if (typeof global[className] === 'function') {\n      // already loaded!\n      callback(classWrapper);\n    } else {\n      this.loadScript(url, () => {\n        callback(classWrapper);\n      });\n    }\n  }\n\n}\n\nvar _default = OGVLoaderBase;\nexports.default = _default;\n\n//# sourceURL=webpack://ogvjs/./src/js/OGVLoaderBase.js?");

/***/ }),

/***/ "./src/js/OGVLoaderWeb.js":
/*!********************************!*\
  !*** ./src/js/OGVLoaderWeb.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _OGVDecoderAudioProxy = _interopRequireDefault(__webpack_require__(/*! ./OGVDecoderAudioProxy.js */ \"./src/js/OGVDecoderAudioProxy.js\"));\n\nvar _OGVDecoderVideoProxy = _interopRequireDefault(__webpack_require__(/*! ./OGVDecoderVideoProxy.js */ \"./src/js/OGVDecoderVideoProxy.js\"));\n\nvar _OGVLoaderBase = _interopRequireDefault(__webpack_require__(/*! ./OGVLoaderBase.js */ \"./src/js/OGVLoaderBase.js\"));\n\n/* global Promise */\n\n/* global BlobBuilder */\nconst proxyInfo = {\n  audio: {\n    proxy: _OGVDecoderAudioProxy.default,\n    worker: 'ogv-worker-audio.js'\n  },\n  video: {\n    proxy: _OGVDecoderVideoProxy.default,\n    worker: 'ogv-worker-video.js'\n  }\n}; // @fixme make this less awful\n\nconst proxyTypes = {\n  OGVDecoderAudioOpus: 'audio',\n  OGVDecoderAudioOpusW: 'audio',\n  OGVDecoderAudioVorbis: 'audio',\n  OGVDecoderAudioVorbisW: 'audio',\n  OGVDecoderVideoTheora: 'video',\n  OGVDecoderVideoTheoraW: 'video',\n  OGVDecoderVideoVP8: 'video',\n  OGVDecoderVideoVP8W: 'video',\n  OGVDecoderVideoVP9: 'video',\n  OGVDecoderVideoVP9W: 'video',\n  OGVDecoderVideoVP9SIMDW: 'video',\n  OGVDecoderVideoAV1: 'video',\n  OGVDecoderVideoAV1W: 'video',\n  OGVDecoderVideoAV1SIMDW: 'video'\n};\n\nclass OGVLoaderWeb extends _OGVLoaderBase.default {\n  constructor() {\n    super();\n    this.scriptStatus = {};\n    this.scriptCallbacks = {};\n  }\n\n  getGlobal() {\n    return window;\n  }\n\n  defaultBase() {\n    // for browser, try to autodetect\n    let scriptNodes = document.querySelectorAll('script'),\n        regex = /^(?:|(.*)\\/)ogv(?:-support|-es2017)?\\.js(?:\\?|#|$)/,\n        path,\n        matches;\n\n    for (let i = 0; i < scriptNodes.length; i++) {\n      path = scriptNodes[i].getAttribute('src');\n\n      if (path) {\n        matches = path.match(regex);\n\n        if (matches) {\n          return matches[1];\n        }\n      }\n    }\n\n    return undefined; // current dir\n  }\n\n  loadClass(className, callback, options) {\n    options = options || {};\n\n    if (options.worker) {\n      this.workerProxy(className, callback);\n    } else {\n      super.loadClass(className, callback, options);\n    }\n  }\n\n  loadScript(src, callback) {\n    if (this.scriptStatus[src] == 'done') {\n      callback();\n    } else if (this.scriptStatus[src] == 'loading') {\n      this.scriptCallbacks[src].push(callback);\n    } else {\n      this.scriptStatus[src] = 'loading';\n      this.scriptCallbacks[src] = [callback];\n      let scriptNode = document.createElement('script');\n\n      let done = event => {\n        let callbacks = this.scriptCallbacks[src];\n        delete this.scriptCallbacks[src];\n        this.scriptStatus[src] = 'done';\n        callbacks.forEach(cb => {\n          cb();\n        });\n      };\n\n      scriptNode.addEventListener('load', done);\n      scriptNode.addEventListener('error', done);\n      scriptNode.src = src;\n      document.querySelector('head').appendChild(scriptNode);\n    }\n  }\n\n  workerProxy(className, callback) {\n    let proxyType = proxyTypes[className],\n        info = proxyInfo[proxyType];\n\n    if (!info) {\n      throw new Error('Requested worker for class with no proxy: ' + className);\n    }\n\n    let proxyClass = info.proxy,\n        workerScript = info.worker,\n        codecUrl = this.urlForScript(this.scriptForClass(className)),\n        workerUrl = this.urlForScript(workerScript),\n        worker;\n\n    var construct = function construct(options) {\n      return new proxyClass(worker, className, options);\n    };\n\n    if (workerUrl.match(/^https?:|\\/\\//i)) {\n      // Can't load workers natively cross-domain, but if CORS\n      // is set up we can fetch the worker stub and the desired\n      // class and load them from a blob.\n      var getCodec,\n          getWorker,\n          codecResponse,\n          workerResponse,\n          codecLoaded = false,\n          workerLoaded = false,\n          blob;\n\n      function completionCheck() {\n        if (codecLoaded == true && workerLoaded == true) {\n          try {\n            blob = new Blob([codecResponse + \" \" + workerResponse], {\n              type: 'application/javascript'\n            });\n          } catch (e) {\n            // Backwards-compatibility\n            window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;\n            blob = new BlobBuilder();\n            blob.append(codecResponse + \" \" + workerResponse);\n            blob = blob.getBlob();\n          } // Create the web worker\n\n\n          worker = new Worker(URL.createObjectURL(blob));\n          callback(function (options) {\n            return Promise.resolve(new construct(options));\n          });\n        }\n      } // Load the codec\n\n\n      getCodec = new XMLHttpRequest();\n      getCodec.open(\"GET\", codecUrl, true);\n\n      getCodec.onreadystatechange = function () {\n        if (getCodec.readyState == 4 && getCodec.status == 200) {\n          codecResponse = getCodec.responseText; // Update the codec response loaded flag\n\n          codecLoaded = true;\n          completionCheck();\n        }\n      };\n\n      getCodec.send(); // Load the worker\n\n      getWorker = new XMLHttpRequest();\n      getWorker.open(\"GET\", workerUrl, true);\n\n      getWorker.onreadystatechange = function () {\n        if (getWorker.readyState == 4 && getWorker.status == 200) {\n          workerResponse = getWorker.responseText; // Update the worker response loaded flag\n\n          workerLoaded = true;\n          completionCheck();\n        }\n      };\n\n      getWorker.send();\n    } else {\n      // Local URL; load it directly for simplicity.\n      worker = new Worker(workerUrl);\n      callback(function (options) {\n        return Promise.resolve(new construct(options));\n      });\n    }\n  }\n\n}\n\nlet OGVLoader = new OGVLoaderWeb();\nvar _default = OGVLoader;\nexports.default = _default;\n\n//# sourceURL=webpack://ogvjs/./src/js/OGVLoaderWeb.js?");

/***/ }),

/***/ "./src/js/OGVMediaError.js":
/*!*********************************!*\
  !*** ./src/js/OGVMediaError.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _extend = _interopRequireDefault(__webpack_require__(/*! ./extend.js */ \"./src/js/extend.js\"));\n\nconst OGVMediaErrorConstants = {\n  MEDIA_ERR_ABORTED: 1,\n  MEDIA_ERR_NETWORK: 2,\n  MEDIA_ERR_DECODE: 3,\n  MEDIA_ERR_SRC_NOT_SUPPORTED: 4\n};\n/**\n * Analogue of the MediaError class returned by\n * HTMLMediaElement.error property\n */\n\nclass OGVMediaError {\n  constructor(code, message) {\n    this.code = code;\n    this.message = message;\n  }\n\n}\n\n(0, _extend.default)(OGVMediaError, OGVMediaErrorConstants);\n(0, _extend.default)(OGVMediaError.prototype, OGVMediaErrorConstants);\nvar _default = OGVMediaError;\nexports.default = _default;\n\n//# sourceURL=webpack://ogvjs/./src/js/OGVMediaError.js?");

/***/ }),

/***/ "./src/js/OGVMediaType.js":
/*!********************************!*\
  !*** ./src/js/OGVMediaType.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction trim(str) {\n  return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\n}\n\nfunction split(str, sep, limit) {\n  let bits = str.split(sep, limit).map(substr => trim(substr));\n\n  if (typeof limit === 'number') {\n    // Extend with nulls to the expected length.\n    while (bits.length < limit) {\n      bits.push(null);\n    }\n  }\n\n  return bits;\n}\n\nclass OGVMediaType {\n  constructor(contentType) {\n    contentType = String(contentType);\n    this.major = null;\n    this.minor = null;\n    this.codecs = null;\n    let parts = split(contentType, ';');\n\n    if (parts.length) {\n      let base = parts.shift();\n\n      if (base) {\n        let bits = split(base, '/', 2);\n        this.major = bits[0];\n        this.minor = bits[1];\n      }\n\n      for (let i in parts) {\n        let str = parts[i];\n        let matches = str.match(/^codecs\\s*=\\s*\"(.*?)\"$/);\n\n        if (matches) {\n          this.codecs = split(matches[1], ',');\n          break;\n        }\n      }\n    }\n  }\n\n}\n\nvar _default = OGVMediaType;\nexports.default = _default;\n\n//# sourceURL=webpack://ogvjs/./src/js/OGVMediaType.js?");

/***/ }),

/***/ "./src/js/OGVPlayer.js":
/*!*****************************!*\
  !*** ./src/js/OGVPlayer.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(setImmediate) {\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _yuvCanvas = _interopRequireDefault(__webpack_require__(/*! yuv-canvas */ \"./node_modules/yuv-canvas/src/yuv-canvas.js\"));\n\nvar _streamFile = _interopRequireDefault(__webpack_require__(/*! stream-file */ \"./node_modules/stream-file/lib/stream-file.js\"));\n\nvar _audioFeeder = _interopRequireDefault(__webpack_require__(/*! audio-feeder */ \"./node_modules/audio-feeder/dist/AudioFeeder.js\"));\n\nvar _dynamicaudio = _interopRequireDefault(__webpack_require__(/*! audio-feeder/dist/dynamicaudio.swf */ \"./node_modules/audio-feeder/dist/dynamicaudio.swf\"));\n\nvar _OGVLoaderWeb = _interopRequireDefault(__webpack_require__(/*! ./OGVLoaderWeb.js */ \"./src/js/OGVLoaderWeb.js\"));\n\nvar _Bisector = _interopRequireDefault(__webpack_require__(/*! ./Bisector.js */ \"./src/js/Bisector.js\"));\n\nvar _extend = _interopRequireDefault(__webpack_require__(/*! ./extend.js */ \"./src/js/extend.js\"));\n\nvar _OGVMediaError = _interopRequireDefault(__webpack_require__(/*! ./OGVMediaError.js */ \"./src/js/OGVMediaError.js\"));\n\nvar _OGVMediaType = _interopRequireDefault(__webpack_require__(/*! ./OGVMediaType.js */ \"./src/js/OGVMediaType.js\"));\n\nvar _OGVTimeRanges = _interopRequireDefault(__webpack_require__(/*! ./OGVTimeRanges.js */ \"./src/js/OGVTimeRanges.js\"));\n\nvar _OGVWrapperCodec = _interopRequireDefault(__webpack_require__(/*! ./OGVWrapperCodec.js */ \"./src/js/OGVWrapperCodec.js\"));\n\n// OGVPlayer.js\n// External deps\n// Internal deps\nlet sumanNum = 1;\nconst constants = {\n  /**\n   * Constants for networkState\n   */\n  NETWORK_EMPTY: 0,\n  NETWORK_IDLE: 1,\n  NETWORK_LOADING: 2,\n  NETWORK_NO_SOURCE: 3,\n\n  /**\n   * Constants for readyState\n   */\n  HAVE_NOTHING: 0,\n  HAVE_METADATA: 1,\n  HAVE_CURRENT_DATA: 2,\n  HAVE_FUTURE_DATA: 3,\n  HAVE_ENOUGH_DATA: 4\n};\nconst State = {\n  INITIAL: 'INITIAL',\n  SEEKING_END: 'SEEKING_END',\n  LOADED: 'LOADED',\n  PRELOAD: 'PRELOAD',\n  READY: 'READY',\n  PLAYING: 'PLAYING',\n  SEEKING: 'SEEKING',\n  ENDED: 'ENDED',\n  ERROR: 'ERROR'\n};\nconst SeekState = {\n  NOT_SEEKING: 'NOT_SEEKING',\n  BISECT_TO_TARGET: 'BISECT_TO_TARGET',\n  BISECT_TO_KEYPOINT: 'BISECT_TO_KEYPOINT',\n  LINEAR_TO_TARGET: 'LINEAR_TO_TARGET'\n};\nconst SeekMode = {\n  EXACT: \"exact\",\n  FAST: \"fast\"\n};\nlet getTimestamp;\n\nif (typeof performance === 'undefined' || typeof performance.now === undefined) {\n  getTimestamp = Date.now;\n} else {\n  getTimestamp = performance.now.bind(performance);\n}\n\nfunction OGVJSElement() {\n  // Stub constructor so we can extend this and\n  // still have it work in IE11 without a big\n  // polyfill.\n  // IE 11 or pre-custom-elements browser\n  // Note we're not ready to use custom elements without an API break,\n  // as we require an options param for some setup that isn't possible\n  let el = document.createElement('ogvjs');\n\n  if (Object.setPrototypeOf) {\n    // Modernish browser\n    Object.setPrototypeOf(el, Object.getPrototypeOf(this));\n  } else {\n    // IE icky!\n    el.__proto__ = this.__proto__;\n  }\n\n  return el;\n}\n\nOGVJSElement.prototype = Object.create(HTMLElement.prototype, {});\n/**\n * Player class -- instantiate one of these to get an 'ogvjs' HTML element\n * which has a similar interface to the HTML audio/video elements.\n *\n * @param options: optional dictionary of options:\n *                 'base': string; base URL for additional resources, such as Flash audio shim\n *                 'webGL': bool; pass true to use WebGL acceleration if available\n *                 'forceWebGL': bool; pass true to require WebGL even if not detected\n */\n\nclass OGVPlayer extends OGVJSElement {\n  constructor(options) {\n    super();\n    this.YUVCanvas = _yuvCanvas.default;\n    options = options || {};\n    options.base = options.base || _OGVLoaderWeb.default.base;\n    this._options = options;\n    this._instanceId = 'ogvjs' + ++OGVPlayer.instanceCount; // Running the codec in a worker thread equals happy times!\n\n    if (typeof options.worker !== 'undefined') {\n      this._enableWorker = !!options.worker;\n    } else {\n      this._enableWorker = !!window.Worker;\n    } // Use the WebAssembly build by default if available;\n    // it should load and compile faster than asm.js.\n\n\n    if (typeof options.wasm !== 'undefined') {\n      this._enableWASM = !!options.wasm;\n    } else {\n      this._enableWASM = _OGVLoaderWeb.default.wasmSupported();\n    } // Experimental pthreads multithreading mode, if built.\n\n\n    this._enableThreading = !!options.threading; // Experimental SIMD mode, if built.\n\n    this._enableSIMD = !!options.simd;\n    this._state = State.INITIAL;\n    this._seekState = SeekState.NOT_SEEKING;\n    this._detectedType = null;\n    this._canvas = document.createElement('canvas');\n    this._frameSink = null;\n\n    if (options.video && this._canvas.captureStream) {\n      this._mediaStream = new MediaStream();\n      this._video = typeof options.video === 'object' ? options.video : document.createElement('video');\n      this._video.playsInline = true; // for iOS to not fullscreen it\n\n      this._video.srcObject = this._mediaStream;\n    } else {\n      this._video = null;\n    }\n\n    this._videoTrack = null;\n    this._audioTrack = null;\n    this._canvasStream = null;\n    this.className = this._instanceId;\n    (0, _extend.default)(this, constants);\n    this._view = this._video || this._canvas;\n    this._view.style.position = 'absolute';\n    this._view.style.top = '0';\n    this._view.style.left = '0';\n    this._view.style.width = '100%';\n    this._view.style.height = '100%';\n    this._view.style.objectFit = 'contain';\n    this.appendChild(this._view); // Used for relative timestamp in _log()\n\n    this._startTime = getTimestamp();\n    this._codec = null;\n    this._audioInfo = null;\n    this._videoInfo = null;\n    this._actionQueue = [];\n    this._audioFeeder = null;\n    this._muted = false;\n    this._initialPlaybackPosition = 0.0;\n    this._initialPlaybackOffset = 0.0;\n    this._prebufferingAudio = false;\n    this._initialSeekTime = 0.0;\n    this._currentSrc = '';\n    this._streamEnded = false;\n    this._mediaError = null;\n    this._dataEnded = false;\n    this._byteLength = 0;\n    this._duration = null;\n    this._lastSeenTimestamp = null;\n    this._nextProcessingTimer;\n    this._nextFrameTimer = null;\n    this._loading = false;\n    this._started = false;\n    this._paused = true;\n    this._ended = false;\n    this._startedPlaybackInDocument = false;\n    this._stream = undefined; // Benchmark data, exposed via getPlaybackStats()\n\n    this._framesProcessed = 0; // frames\n\n    this._targetPerFrameTime = 1000 / 60; // ms\n\n    this._actualPerFrameTime = 0; // ms\n\n    this._totalFrameTime = 0; // ms\n\n    this._totalFrameCount = 0; // frames\n\n    this._playTime = 0; // ms\n\n    this._bufferTime = 0; // ms\n\n    this._drawingTime = 0; // ms\n\n    this._proxyTime = 0; // ms\n\n    this._totalJitter = 0; // sum of ms we're off from expected frame delivery time\n    // Benchmark data that doesn't clear\n\n    this._droppedAudio = 0; // number of times we were starved for audio\n\n    this._delayedAudio = 0; // seconds audio processing was delayed by blocked CPU\n\n    this._lateFrames = 0; // number of times a frame was late and we had to halt audio\n\n    this._poster = '';\n    this._thumbnail = null;\n    this._frameEndTimestamp = 0.0;\n    this._audioEndTimestamp = 0.0;\n    this._decodedFrames = [];\n    this._pendingFrames = [];\n    this._lastFrameDecodeTime = 0.0;\n    this._lastFrameVideoCpuTime = 0;\n    this._lastFrameAudioCpuTime = 0;\n    this._lastFrameDemuxerCpuTime = 0;\n    this._lastFrameDrawingTime = 0;\n    this._lastFrameBufferTime = 0;\n    this._lastFrameProxyTime = 0;\n    this._lastVideoCpuTime = 0;\n    this._lastAudioCpuTime = 0;\n    this._lastDemuxerCpuTime = 0;\n    this._lastBufferTime = 0;\n    this._lastProxyTime = 0;\n    this._lastDrawingTime = 0;\n    this._lastFrameTimestamp = 0.0;\n    this._currentVideoCpuTime = 0.0;\n    this._lastTimeUpdate = 0; // ms\n\n    this._timeUpdateInterval = 250; // ms\n    // -- seek functions\n\n    this._seekTargetTime = 0.0;\n    this._bisectTargetTime = 0.0;\n    this._seekMode = null;\n    this._lastSeekPosition = null;\n    this._seekBisector = null;\n    this._didSeek = null;\n    this._depth = 0;\n    this._needProcessing = false;\n    this._pendingFrame = 0;\n    this._pendingAudio = 0;\n    this._framePipelineDepth = 8;\n    this._frameParallelism = this._enableThreading ? Math.min(16, navigator.hardwareConcurrency) || 1 : 0;\n    this._audioPipelineDepth = 12;\n    this._videoInfo = null;\n    this._audioInfo = null; // Display size...\n\n    this._width = 0;\n    this._height = 0;\n    this._volume = 1;\n    this._playbackRate = 1;\n    Object.defineProperties(this, {\n      /**\n       * HTMLMediaElement src property\n       */\n      src: {\n        get: function getSrc() {\n          return this.getAttribute('src') || '';\n        },\n        set: function setSrc(val) {\n          this.setAttribute('src', val);\n          this._loading = false; // just in case?\n\n          this._prepForLoad(\"interactive\");\n        }\n      },\n\n      /**\n       * HTMLMediaElement buffered property\n       */\n      buffered: {\n        get: function getBuffered() {\n          let ranges;\n\n          if (this._stream && this._byteLength && this._duration) {\n            ranges = this._stream.getBufferedRanges().map(range => {\n              return range.map(offset => {\n                return offset / this._stream.length * this._duration;\n              });\n            });\n          } else {\n            ranges = [[0, 0]];\n          }\n\n          return new _OGVTimeRanges.default(ranges);\n        }\n      },\n\n      /**\n       * HTMLMediaElement seekable property\n       */\n      seekable: {\n        get: function getSeekable() {\n          if (this.duration < Infinity && this._stream && this._stream.seekable && this._codec && this._codec.seekable) {\n            return new _OGVTimeRanges.default([[0, this._duration]]);\n          } else {\n            return new _OGVTimeRanges.default([]);\n          }\n        }\n      },\n\n      /**\n       * HTMLMediaElement currentTime property\n       */\n      currentTime: {\n        get: function getCurrentTime() {\n          if (this._state == State.SEEKING) {\n            return this._seekTargetTime;\n          } else {\n            if (this._codec) {\n              if (this._state == State.PLAYING && !this._paused) {\n                return this._getPlaybackTime();\n              } else {\n                return this._initialPlaybackOffset;\n              }\n            } else {\n              return this._initialSeekTime;\n            }\n          }\n        },\n        set: function setCurrentTime(val) {\n          this._seek(val, SeekMode.EXACT);\n        }\n      },\n\n      /**\n       * HTMLMediaElement duration property\n       */\n      duration: {\n        get: function getDuration() {\n          if (this._codec && this._codec.loadedMetadata) {\n            if (this._duration !== null) {\n              return this._duration;\n            } else {\n              return Infinity;\n            }\n          } else {\n            return NaN;\n          }\n        }\n      },\n\n      /**\n       * HTMLMediaElement paused property\n       */\n      paused: {\n        get: function getPaused() {\n          return this._paused;\n        }\n      },\n\n      /**\n       * HTMLMediaElement ended property\n       */\n      ended: {\n        get: function getEnded() {\n          return this._ended;\n        }\n      },\n\n      /**\n       * HTMLMediaElement ended property\n       */\n      seeking: {\n        get: function getSeeking() {\n          return this._state == State.SEEKING;\n        }\n      },\n\n      /**\n       * HTMLMediaElement muted property\n       */\n      muted: {\n        get: function getMuted() {\n          return this._muted;\n        },\n        set: function setMuted(val) {\n          this._muted = val;\n\n          if (this._audioFeeder) {\n            this._audioFeeder.muted = this._muted;\n          } else if (this._started && !this._muted && this._codec && this._codec.hasAudio) {\n            this._log('unmuting: switching from timer to audio clock');\n\n            this._initAudioFeeder();\n\n            this._startPlayback(this._audioEndTimestamp);\n          }\n\n          this._fireEventAsync('volumechange');\n        }\n      },\n\n      /**\n       * HTMLMediaElement poster property\n       */\n      poster: {\n        get: function getPoster() {\n          return this._poster;\n        },\n        set: function setPoster(val) {\n          this._poster = val;\n\n          if (!this._started) {\n            if (this._thumbnail) {\n              this.removeChild(this._thumbnail);\n            }\n\n            let thumbnail = new Image();\n            thumbnail.src = this._poster;\n            thumbnail.className = 'ogvjs-poster';\n            thumbnail.style.position = 'absolute';\n            thumbnail.style.top = '0';\n            thumbnail.style.left = '0';\n            thumbnail.style.width = '100%';\n            thumbnail.style.height = '100%';\n            thumbnail.style.objectFit = 'contain';\n            thumbnail.style.visibility = 'hidden';\n            thumbnail.addEventListener('load', () => {\n              if (this._thumbnail === thumbnail) {\n                OGVPlayer.styleManager.appendRule('.' + this._instanceId, {\n                  width: thumbnail.naturalWidth + 'px',\n                  height: thumbnail.naturalHeight + 'px'\n                });\n                OGVPlayer.updatePositionOnResize();\n                thumbnail.style.visibility = 'visible';\n              }\n            });\n            this._thumbnail = thumbnail;\n            this.appendChild(thumbnail);\n          }\n        }\n      },\n\n      /**\n       * HTMLMediaElement video width property\n       */\n      videoWidth: {\n        get: function getVideoWidth() {\n          if (this._videoInfo) {\n            return this._videoInfo.displayWidth;\n          } else {\n            return 0;\n          }\n        }\n      },\n\n      /**\n       * HTMLMediaElement video height property\n       */\n      videoHeight: {\n        get: function getVideoHeight() {\n          if (this._videoInfo) {\n            return this._videoInfo.displayHeight;\n          } else {\n            return 0;\n          }\n        }\n      },\n\n      /**\n       * Custom video framerate property\n       */\n      ogvjsVideoFrameRate: {\n        get: function getOgvJsVideoFrameRate() {\n          if (this._videoInfo) {\n            if (this._videoInfo.fps == 0) {\n              return this._totalFrameCount / (this._totalFrameTime / 1000);\n            } else {\n              return this._videoInfo.fps;\n            }\n          } else {\n            return 0;\n          }\n        }\n      },\n\n      /**\n       * Custom audio metadata property\n       */\n      ogvjsAudioChannels: {\n        get: function getOgvJsAudioChannels() {\n          if (this._audioInfo) {\n            return this._audioInfo.channels;\n          } else {\n            return 0;\n          }\n        }\n      },\n\n      /**\n       * Custom audio metadata property\n       */\n      ogvjsAudioSampleRate: {\n        get: function getOgvJsAudioChannels() {\n          if (this._audioInfo) {\n            return this._audioInfo.rate;\n          } else {\n            return 0;\n          }\n        }\n      },\n\n      /**\n       * @property width\n       * @todo reflect to the width attribute?\n       */\n      width: {\n        get: function getWidth() {\n          return this._width;\n        },\n        set: function setWidth(val) {\n          this._width = parseInt(val, 10);\n          this.style.width = this._width + 'px';\n          OGVPlayer.updatePositionOnResize();\n        }\n      },\n\n      /**\n       * @property height\n       * @todo reflect to the height attribute?\n       */\n      height: {\n        get: function getHeight() {\n          return this._height;\n        },\n        set: function setHeight(val) {\n          this._height = parseInt(val, 10);\n          this.style.height = this._height + 'px';\n          OGVPlayer.updatePositionOnResize();\n        }\n      },\n\n      /**\n       * @property autoplay {boolean} stub prop\n       * @todo reflect to the autoplay attribute?\n       * @todo implement actual autoplay behavior\n       */\n      autoplay: {\n        get: function getAutoplay() {\n          return false;\n        },\n        set: function setAutoplay(val) {// ignore\n        }\n      },\n\n      /**\n       * @property controls {boolean} stub prop\n       * @todo reflect to the controls attribute?\n       * @todo implement actual control behavior\n       */\n      controls: {\n        get: function getControls() {\n          return false;\n        },\n        set: function setControls(val) {// ignore\n        }\n      },\n\n      /**\n       * @property loop {boolean} stub prop\n       * @todo reflect to the controls attribute?\n       * @todo implement actual loop behavior\n       */\n      loop: {\n        get: function getLoop() {\n          return false;\n        },\n        set: function setLoop(val) {// ignore\n        }\n      },\n\n      /**\n       * @property crossOrigin {string|null} stub prop\n       * @todo reflect to the crossorigin attribute?\n       * @todo implement actual behavior\n       */\n      crossOrigin: {\n        get: function getCrossOrigin() {\n          return null;\n        },\n        set: function setCrossOrigin(val) {// ignore\n        }\n      },\n\n      /**\n       * Returns the URL to the currently-playing resource.\n       * @property currentSrc {string|null}\n       */\n      currentSrc: {\n        get: function getCurrentSrc() {\n          // @todo return absolute URL per spec\n          return this._currentSrc;\n        }\n      },\n      defaultMuted: {\n        get: function getDefaultMuted() {\n          return false;\n        }\n      },\n      defaultPlaybackRate: {\n        get: function getDefaultPlaybackRate() {\n          return 1;\n        }\n      },\n\n      /**\n       * @property error {OGVMediaError|null}\n       */\n      error: {\n        get: function getError() {\n          if (this._state === State.ERROR) {\n            if (this._mediaError) {\n              return this._mediaError;\n            } else {\n              return new _OGVMediaError.default(\"unknown error occurred in media procesing\");\n            }\n          } else {\n            return null;\n          }\n        }\n      },\n\n      /**\n       * @property preload {string}\n       */\n      preload: {\n        get: function getPreload() {\n          return this.getAttribute('preload') || '';\n        },\n        set: function setPreload(val) {\n          this.setAttribute('preload', val);\n        }\n      },\n\n      /**\n       * @property readyState {number}\n       * @todo return more accurate info about availability of data\n       */\n      readyState: {\n        get: function getReadyState() {\n          if (this._stream && this._codec && this._codec.loadedMetadata) {\n            // for now we don't really calc this stuff\n            // just pretend we have lots of data coming in already\n            return OGVPlayer.HAVE_ENOUGH_DATA;\n          } else {\n            return OGVPlayer.HAVE_NOTHING;\n          }\n        }\n      },\n\n      /**\n       * @property networkState {number}\n       * @todo implement\n       */\n      networkState: {\n        get: function getNetworkState() {\n          if (this._stream) {\n            if (this._stream.waiting) {\n              return OGVPlayer.NETWORK_LOADING;\n            } else {\n              return OGVPlayer.NETWORK_IDLE;\n            }\n          } else {\n            if (this.readyState == OGVPlayer.HAVE_NOTHING) {\n              return OGVPlayer.NETWORK_EMPTY;\n            } else {\n              return OGVPlayer.NETWORK_NO_SOURCE;\n            }\n          }\n        }\n      },\n\n      /**\n       * @property playbackRate {number}\n       */\n      playbackRate: {\n        get: function getPlaybackRate() {\n          return this._playbackRate;\n        },\n        set: function setPlaybackRate(val) {\n          var newRate = Number(val) || 1.0;\n\n          if (this._audioFeeder) {\n            this._audioFeeder.tempo = newRate;\n          } else if (!this._paused) {\n            // Change while playing\n            // Move to the coordinate system created by the new tempo\n            this._initialPlaybackOffset = this._getPlaybackTime();\n            this._initialPlaybackPosition = newRate * getTimestamp() / 1000;\n          }\n\n          this._playbackRate = newRate;\n\n          this._fireEventAsync('ratechange');\n        }\n      },\n\n      /**\n       * @property played {OGVTimeRanges}\n       * @todo implement correctly more or less\n       */\n      played: {\n        get: function getPlayed() {\n          return new _OGVTimeRanges.default([[0, this.currentTime]]);\n        }\n      },\n\n      /**\n       * @property volume {number}\n       */\n      volume: {\n        get: function getVolume() {\n          return this._volume;\n        },\n        set: function setVolume(val) {\n          this._volume = +val;\n\n          if (this._audioFeeder) {\n            this._audioFeeder.volume = this._volume;\n          }\n\n          this._fireEventAsync('volumechange');\n        }\n      }\n    }); // Events!\n\n    /**\n     * custom onframecallback, takes frame decode time in ms\n     */\n\n    this.onframecallback = null;\n    /**\n     * Network state events\n     * @todo implement\n     */\n\n    this.onloadstate = null;\n    this.onprogress = null;\n    this.onsuspend = null;\n    this.onabort = null;\n    this.onemptied = null;\n    this.onstalled = null;\n    /**\n     * Called when all metadata is available.\n     * Note in theory we must know 'duration' at this point.\n     */\n\n    this.onloadedmetadata = null;\n    /**\n     * Called when enough data for first frame is ready.\n     * @todo implement\n     */\n\n    this.onloadeddata = null;\n    /**\n     * Called when enough data is ready to start some playback.\n     * @todo implement\n     */\n\n    this.oncanplay = null;\n    /**\n     * Called when enough data is ready to play through to the\n     * end if no surprises in network download rate.\n     * @todo implement\n     */\n\n    this.oncanplaythrough = null;\n    /**\n     * Called when playback continues after a stall\n     * @todo implement\n     */\n\n    this.onplaying = null;\n    /**\n     * Called when playback is delayed waiting on data\n     * @todo implement\n     */\n\n    this.onwaiting = null;\n    /**\n     * Called when seeking begins\n     * @todo implement\n     */\n\n    this.onseeking = null;\n    /**\n     * Called when seeking ends\n     * @todo implement\n     */\n\n    this.onseeked = null;\n    /**\n     * Called when playback ends\n     */\n\n    this.onended = null;\n    /**\n     * Called when duration becomes known\n     * @todo implement\n     */\n\n    this.ondurationchange = null;\n    /**\n     * Called periodically during playback\n     */\n\n    this.ontimeupdate = null;\n    /**\n     * Called when we start playback\n     */\n\n    this.onplay = null;\n    /**\n     * Called when we get paused\n     */\n\n    this.onpause = null;\n    /**\n     * Called when the playback rate changes\n     * @todo implement\n     */\n\n    this.onratechange = null;\n    /**\n     * Called when the size of the video stream changes\n     * @todo implement\n     */\n\n    this.onresize = null;\n    /**\n     * Called when the volume setting changes\n     * @todo implement\n     */\n\n    this.onvolumechange = null;\n    /**\n     * Called when the audio feeder is created\n     * This allows for modifying the instance for special audio processing\n     */\n\n    this.onaudiofeedercreated = null;\n  }\n\n  _time(cb) {\n    let start = getTimestamp();\n    cb();\n    let delta = getTimestamp() - start;\n    this._lastFrameDecodeTime += delta;\n    return delta;\n  }\n\n  _log(msg) {\n    let options = this._options;\n\n    if (options.debug) {\n      let now = getTimestamp(),\n          delta = now - this._startTime; //console.log('+' + delta + 'ms ' + msg);\n      //then = now;\n\n      if (!options.debugFilter || msg.match(options.debugFilter)) {\n        console.log('[' + Math.round(delta * 10) / 10 + 'ms] ' + msg);\n      }\n    }\n  }\n\n  _fireEvent(eventName) {\n    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    this._log('fireEvent ' + eventName);\n\n    let standard = typeof Event == 'function';\n    let event;\n\n    if (standard) {\n      // standard event creation\n      event = new CustomEvent(eventName);\n    } else {\n      // IE back-compat mode\n      // https://msdn.microsoft.com/en-us/library/dn905219%28v=vs.85%29.aspx\n      event = document.createEvent('Event');\n      event.initEvent(eventName, false, false);\n    }\n\n    for (let prop in props) {\n      if (props.hasOwnProperty(prop)) {\n        event[prop] = props[prop];\n      }\n    }\n\n    let allowDefault = this.dispatchEvent(event);\n\n    if (!standard && eventName === 'resize' && this.onresize && allowDefault) {\n      // resize demands special treatment!\n      // in IE 11 it doesn't fire through to the .onresize handler\n      // for some crazy reason\n      this.onresize.call(this, event);\n    }\n  }\n\n  _fireEventAsync(eventName) {\n    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    this._log('fireEventAsync ' + eventName);\n\n    setImmediate(() => {\n      this._fireEvent(eventName, props);\n    });\n  }\n\n  static initSharedAudioContext() {\n    _audioFeeder.default.initSharedAudioContext();\n  }\n\n  _initAudioFeeder() {\n    let options = this._options;\n    let audioOptions = {\n      // Pass the resource dir down to AudioFeeder, so it can load the dynamicaudio.swf\n      base: options.base || _OGVLoaderWeb.default.base,\n      // Buffer in largeish chunks to survive long CPU spikes on slow CPUs (eg, 32-bit iOS)\n      bufferSize: 8192\n    };\n\n    if (options.audioContext) {\n      // Try passing a pre-created AudioContext in?\n      audioOptions.audioContext = options.audioContext;\n    }\n\n    if (options.audioDestination) {\n      // Try passing a pre-created output node in?\n      audioOptions.output = options.audioDestination;\n    }\n\n    if (options.audioBackendFactory) {\n      // Allow setting a custom backend for audioFeeder\n      audioOptions.backendFactory = options.audioBackendFactory;\n    }\n\n    if (this._video && !audioOptions.output) {\n      // Set up an audio route...\n      if (!audioOptions.audioContext) {\n        // We need the AudioContext first to create the capture node\n        audioOptions.audioContext = _audioFeeder.default.initSharedAudioContext();\n      }\n\n      let dest = audioOptions.audioContext.createMediaStreamDestination();\n      this._audioTrack = dest.stream.getAudioTracks()[0];\n\n      this._mediaStream.addTrack(this._audioTrack);\n\n      if (navigator.userAgent.match(/WebKit/)) {\n        // Safari drops after we change the stream, so reconnect it.\n        this._video.src = this._mediaStream;\n      }\n\n      this._video.play();\n\n      audioOptions.output = dest;\n    }\n\n    let audioFeeder = this._audioFeeder = new _audioFeeder.default(audioOptions);\n    audioFeeder.init(this._audioInfo.channels, this._audioInfo.rate); //Fire when _audioFeeder is populated\n\n    if (this.onaudiofeedercreated) this.onaudiofeedercreated(this._audioFeeder); // At our requested 8192 buffer size, bufferDuration should be\n    // about 185ms at 44.1 kHz or 170ms at 48 kHz output, covering\n    // 4-6 frames at 24-30fps.\n    //\n    // 2 or 3 buffers' worth will be in flight at any given time;\n    // be warned that durationBuffered includes that in-flight stuff.\n    //\n    // Set our bufferThreshold to a full 1s for plenty of extra headroom,\n    // and make sure we've queued up twice that when we're operating.\n\n    audioFeeder.bufferThreshold = 1;\n    audioFeeder.volume = this.volume;\n    audioFeeder.muted = this.muted;\n    audioFeeder.tempo = this.playbackRate; // If we're in a background tab, timers may be throttled.\n    // audioFeeder will call us when buffers need refilling,\n    // without any throttling.\n\n    audioFeeder.onbufferlow = () => {\n      this._log('onbufferlow');\n\n      if (this._stream && (this._stream.buffering || this._stream.seeking) || this._pendingAudio) {// We're waiting on input or other async processing;\n        // we'll get triggered later.\n      } else {\n        // We're in an async event so it's safe to run the loop:\n        this._pingProcessing();\n      }\n    }; // If we ran out of audio *completely* schedule some more processing.\n    // This shouldn't happen if we keep up with onbufferlow.\n\n\n    audioFeeder.onstarved = () => {\n      if (this._dataEnded) {\n        // Probably end of file.\n        // Do nothing!\n        this._log('onstarved: appear to have reached end of audio');\n      } else {\n        this._log('onstarved: halting audio due to starvation');\n\n        this._stopPlayback();\n\n        this._prebufferingAudio = true;\n      }\n\n      if (this._isProcessing()) {// We're waiting on input or other async processing;\n        // we'll get triggered later.\n      } else {\n        // Schedule loop after this synchronous event.\n        this._pingProcessing(0);\n      }\n    };\n  }\n\n  _startPlayback(offset) {\n    if (this._audioFeeder) {\n      this._audioFeeder.start();\n\n      let state = this._audioFeeder.getPlaybackState();\n\n      this._initialPlaybackPosition = state.playbackPosition;\n    } else {\n      this._initialPlaybackPosition = this._playbackRate * getTimestamp() / 1000;\n    }\n\n    if (offset !== undefined) {\n      this._initialPlaybackOffset = offset;\n    } // Clear the late flag if it was set.\n\n\n    this._prebufferingAudio = false;\n\n    this._log('continuing at ' + this._initialPlaybackPosition + ', ' + this._initialPlaybackOffset);\n  }\n\n  _stopPlayback() {\n    this._initialPlaybackOffset = this._getPlaybackTime();\n\n    this._log('pausing at ' + this._initialPlaybackOffset);\n\n    if (this._audioFeeder) {\n      this._audioFeeder.stop();\n    }\n  }\n  /**\n   * Get audio playback time position in file's units\n   *\n   * @return {number} seconds since file start\n   */\n\n\n  _getPlaybackTime(state) {\n    if (this._prebufferingAudio || this._paused) {\n      return this._initialPlaybackOffset;\n    } else {\n      let position;\n\n      if (this._audioFeeder) {\n        state = state || this._audioFeeder.getPlaybackState();\n        position = state.playbackPosition;\n      } else {\n        // @fixme handle paused/stoped time better\n        position = this._playbackRate * getTimestamp() / 1000;\n      }\n\n      return position - this._initialPlaybackPosition + this._initialPlaybackOffset;\n    }\n  } // called when stopping old video on load()\n\n\n  _stopVideo() {\n    this._log(\"STOPPING\"); // kill the previous video if any\n\n\n    this._state = State.INITIAL;\n    this._seekState = SeekState.NOT_SEEKING;\n    this._started = false; //this._paused = true; // don't change this?\n\n    this._ended = false;\n    this._frameEndTimestamp = 0.0;\n    this._audioEndTimestamp = 0.0;\n    this._lastFrameDecodeTime = 0.0;\n    this._prebufferingAudio = false; // Abort all queued actions\n\n    this._actionQueue.splice(0, this._actionQueue.length);\n\n    if (this._stream) {\n      // @todo fire an abort event if still loading\n      // @todo fire an emptied event if previously had data\n      this._stream.abort();\n\n      this._stream = null;\n      this._streamEnded = false;\n    }\n\n    if (this._codec) {\n      this._codec.close();\n\n      this._codec = null;\n      this._pendingFrame = 0;\n      this._pendingAudio = 0;\n      this._dataEnded = false;\n    }\n\n    this._videoInfo = null;\n    this._audioInfo = null;\n\n    if (this._audioFeeder) {\n      this._audioFeeder.close();\n\n      this._audioFeeder = null;\n    }\n\n    if (this._nextProcessingTimer) {\n      clearTimeout(this._nextProcessingTimer);\n      this._nextProcessingTimer = null;\n    }\n\n    if (this._nextFrameTimer) {\n      clearTimeout(this._nextFrameTimer);\n      this._nextFrameTimer = null;\n    }\n\n    if (this._frameSink) {\n      this._frameSink.clear();\n\n      this._frameSink = null;\n    }\n\n    if (this._decodedFrames) {\n      this._decodedFrames = [];\n    }\n\n    if (this._pendingFrames) {\n      this._pendingFrames = [];\n    }\n\n    this._initialSeekTime = 0.0; // @todo set playback position, may need to fire timeupdate if wasnt previously 0\n\n    this._initialPlaybackPosition = 0;\n    this._initialPlaybackOffset = 0;\n    this._duration = null; // do not fire durationchange\n    // timeline offset to 0?\n  }\n\n  _doFrameComplete() {\n    let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (this._startedPlaybackInDocument && !document.body.contains(this)) {\n      // We've been de-parented since we last ran\n      // Stop playback at next opportunity!\n      setImmediate(() => {\n        this.stop();\n      });\n    }\n\n    let newFrameTimestamp = getTimestamp(),\n        wallClockTime = newFrameTimestamp - this._lastFrameTimestamp,\n        //jitter = wallClockTime - this._targetPerFrameTime;\n    jitter = this._actualPerFrameTime - this._targetPerFrameTime;\n    this._totalJitter += Math.abs(jitter);\n    this._playTime += wallClockTime;\n    let timing = {\n      cpuTime: this._lastFrameDecodeTime,\n      drawingTime: this._drawingTime - this._lastFrameDrawingTime,\n      bufferTime: this._bufferTime - this._lastFrameBufferTime,\n      proxyTime: this._proxyTime - this._lastFrameProxyTime,\n      demuxerTime: 0,\n      videoTime: 0,\n      audioTime: 0,\n      //clockTime: wallClockTime\n      clockTime: this._actualPerFrameTime,\n      late: data.dropped,\n      dropped: data.dropped\n    };\n\n    if (this._codec) {\n      timing.demuxerTime = this._codec.demuxerCpuTime - this._lastFrameDemuxerCpuTime;\n      timing.videoTime += this._currentVideoCpuTime - this._lastFrameVideoCpuTime;\n      timing.audioTime += this._codec.audioCpuTime - this._lastFrameAudioCpuTime;\n    }\n\n    timing.cpuTime += timing.demuxerTime;\n    this._lastFrameDecodeTime = 0;\n    this._lastFrameTimestamp = newFrameTimestamp;\n\n    if (this._codec) {\n      this._lastFrameVideoCpuTime = this._currentVideoCpuTime;\n      this._lastFrameAudioCpuTime = this._codec.audioCpuTime;\n      this._lastFrameDemuxerCpuTime = this._codec.demuxerCpuTime;\n    } else {\n      this._lastFrameVideoCpuTime = 0;\n      this._lastFrameAudioCpuTime = 0;\n      this._lastFrameDemuxerCpuTime = 0;\n    }\n\n    this._lastFrameDrawingTime = this._drawingTime;\n    this._lastFrameBufferTime = this._bufferTime;\n    this._lastFrameProxyTime = this._proxyTime;\n\n    function n(x) {\n      return Math.round(x * 10) / 10;\n    }\n\n    this._log('drew frame ' + data.frameEndTimestamp + ': ' + 'clock time ' + n(wallClockTime) + ' (jitter ' + n(jitter) + ') ' + 'cpu: ' + n(timing.cpuTime) + ' (mux: ' + n(timing.demuxerTime) + ' buf: ' + n(timing.bufferTime) + ' draw: ' + n(timing.drawingTime) + ' proxy: ' + n(timing.proxyTime) + ') ' + 'vid: ' + n(timing.videoTime) + ' aud: ' + n(timing.audioTime));\n\n    this._fireEventAsync('framecallback', timing);\n\n    if (!this._lastTimeUpdate || newFrameTimestamp - this._lastTimeUpdate >= this._timeUpdateInterval) {\n      this._lastTimeUpdate = newFrameTimestamp;\n\n      this._fireEventAsync('timeupdate');\n    }\n\n    if (this._codec && data.yCbCrBuffer) {\n      this._codec.recycleFrame(data.yCbCrBuffer);\n    }\n  }\n\n  _seekStream(offset) {\n    if (this._stream.seeking) {\n      this._stream.abort();\n    }\n\n    if (this._stream.buffering) {\n      this._stream.abort();\n    }\n\n    this._streamEnded = false;\n    this._dataEnded = false;\n    this._ended = false;\n\n    this._stream.seek(offset).then(() => {\n      this._readBytesAndWait();\n    }).catch(e => {\n      this._onStreamError(e);\n    });\n  }\n\n  _onStreamError(err) {\n    if (err.name === 'AbortError') {\n      // do nothing\n      this._log('i/o promise canceled; ignoring');\n    } else {\n      this._log(\"i/o error: \" + err);\n\n      this._mediaError = new _OGVMediaError.default(_OGVMediaError.default.MEDIA_ERR_NETWORK, String(err));\n      this._state = State.ERROR;\n\n      this._stopPlayback();\n    }\n  }\n\n  _seek(toTime, mode) {\n    this._log('requested seek to ' + toTime + ', mode ' + mode);\n\n    if (this.readyState == this.HAVE_NOTHING) {\n      this._log('not yet loaded; saving seek position for later');\n\n      this._initialSeekTime = toTime;\n      return;\n    }\n\n    if (this._stream && !this._stream.seekable) {\n      throw new Error('Cannot seek a non-seekable stream');\n    }\n\n    if (this._codec && !this._codec.seekable) {\n      throw new Error('Cannot seek in a non-seekable file');\n    }\n\n    let prepForSeek = callback => {\n      if (this._stream && this._stream.buffering) {\n        this._stream.abort();\n      }\n\n      if (this._stream && this._stream.seeking) {\n        this._stream.abort();\n      } // clear any queued input/seek-start\n\n\n      this._actionQueue.splice(0, this._actionQueue.length);\n\n      this._stopPlayback();\n\n      this._prebufferingAudio = false;\n\n      if (this._audioFeeder) {\n        this._audioFeeder.flush();\n      }\n\n      this._state = State.SEEKING;\n      this._seekTargetTime = toTime;\n      this._seekMode = mode;\n\n      if (this._codec) {\n        this._codec.flush(callback);\n      } else {\n        callback();\n      }\n    }; // Abort any previous seek or play suitably\n\n\n    prepForSeek(() => {\n      if (this._isProcessing()) {// already waiting on input\n      } else {\n        // start up the new load *after* event loop churn\n        this._pingProcessing(0);\n      }\n    });\n\n    this._actionQueue.push(() => {\n      // Just in case another async task stopped us...\n      prepForSeek(() => {\n        this._doSeek(toTime);\n      });\n    });\n  }\n\n  _doSeek(toTime) {\n    this._streamEnded = false;\n    this._dataEnded = false;\n    this._ended = false;\n    this._state = State.SEEKING;\n    this._seekTargetTime = toTime;\n    this._lastSeekPosition = -1;\n    this._decodedFrames = [];\n    this._pendingFrames = [];\n    this._pendingFrame = 0;\n    this._pendingAudio = 0;\n    this._didSeek = false;\n\n    this._codec.seekToKeypoint(toTime, seeking => {\n      if (seeking) {\n        this._seekState = SeekState.LINEAR_TO_TARGET;\n\n        this._fireEventAsync('seeking');\n\n        if (this._didSeek) {\n          // wait for i/o to trigger readBytesAndWait\n          return;\n        } else {\n          this._pingProcessing();\n\n          return;\n        }\n      } // Use the old interface still implemented on ogg demuxer\n\n\n      this._codec.getKeypointOffset(toTime, offset => {\n        if (offset > 0) {\n          // This file has an index!\n          //\n          // Start at the keypoint, then decode forward to the desired time.\n          //\n          this._seekState = SeekState.LINEAR_TO_TARGET;\n\n          this._seekStream(offset);\n        } else {\n          // No index.\n          //\n          // Bisect through the file finding our target time, then we'll\n          // have to do it again to reach the keypoint, and *then* we'll\n          // have to decode forward back to the desired time.\n          //\n          this._seekState = SeekState.BISECT_TO_TARGET;\n\n          this._startBisection(this._seekTargetTime);\n        }\n\n        this._fireEventAsync('seeking');\n      });\n    });\n  }\n\n  _startBisection(targetTime) {\n    // leave room for potentially long Ogg page syncing\n    let endPoint = Math.max(0, this._stream.length - 65536);\n    this._bisectTargetTime = targetTime;\n    this._seekBisector = new _Bisector.default({\n      start: 0,\n      end: endPoint,\n      process: (start, end, position) => {\n        if (position == this._lastSeekPosition) {\n          return false;\n        } else {\n          this._lastSeekPosition = position;\n\n          this._codec.flush(() => {\n            this._seekStream(position);\n          });\n\n          return true;\n        }\n      }\n    });\n\n    this._seekBisector.start();\n  }\n\n  _continueSeekedPlayback() {\n    this._seekState = SeekState.NOT_SEEKING;\n    this._state = State.READY;\n    this._frameEndTimestamp = this._codec.frameTimestamp;\n    this._audioEndTimestamp = this._codec.audioTimestamp;\n\n    if (this._codec.hasAudio) {\n      this._seekTargetTime = this._codec.audioTimestamp;\n    } else {\n      this._seekTargetTime = this._codec.frameTimestamp;\n    }\n\n    this._initialPlaybackOffset = this._seekTargetTime;\n\n    let finishedSeeking = () => {\n      this._lastTimeUpdate = this._seekTargetTime;\n\n      this._fireEventAsync('timeupdate');\n\n      this._fireEventAsync('seeked');\n\n      if (this._isProcessing()) {// wait for whatever's going on to complete\n      } else {\n        this._pingProcessing();\n      }\n    };\n\n    if (this._codec.hasVideo && this._decodedFrames.length) {\n      // We landed between frames. Show the last frame.\n      let frame = this._decodedFrames.shift();\n\n      this._drawFrame(frame.yCbCrBuffer);\n\n      finishedSeeking();\n    } else if (this._codec.hasVideo && this._codec.frameReady) {\n      // Exact seek, no decoded frames.\n      //\n      // Decode and show first frame immediately\n      // hack! move this into the main loop when retooling\n      // to avoid maintaining this double draw\n      this._codec.decodeFrame(ok => {\n        if (ok) {\n          this._drawFrame(this._codec.frameBuffer);\n        }\n\n        finishedSeeking();\n      });\n\n      this._codec.sync();\n\n      return;\n    } else {\n      finishedSeeking();\n    }\n  }\n\n  _drawFrame(buffer) {\n    if (this._thumbnail) {\n      this.removeChild(this._thumbnail);\n      this._thumbnail = null;\n    } // const time = new Date();\n    // const currentTime = time.getHours() + \":\" + time.getMinutes() + \":\" + time.getSeconds();\n    // console.log(' ====> Draw frame actual ', currentTime);\n\n\n    this._frameSink.drawFrame(buffer);\n\n    if (this._video) {\n      if (!this._canvasStream) {\n        this._canvasStream = this._canvas.captureStream(0);\n        this._videoTrack = this._canvasStream.getVideoTracks()[0];\n\n        this._mediaStream.addTrack(this._videoTrack);\n\n        if (navigator.userAgent.match(/WebKit/)) {\n          // Safari drops when we change tracks, so reconnect.\n          this._video.src = this._mediaStream;\n\n          this._video.play();\n        }\n      } // Update the media stream with the new frame, so we don't\n      // have to fake a constant frame rate that might be too high\n      // or too low.\n\n\n      if (this._videoTrack && this._videoTrack.requestFrame) {\n        this._videoTrack.requestFrame();\n      } else if (this._canvasStream && this._canvasStream.requestFrame) {\n        this._canvasStream.requestFrame();\n      }\n    }\n  }\n  /**\n   * @return {boolean} true to continue processing, false to wait for input data\n   */\n  // _doProcessLinearSeeking() {\n  // \tlet frameDuration;\n  // \tif (this._codec.hasVideo) {\n  // \t\tframeDuration = this._targetPerFrameTime / 1000;\n  // \t} else {\n  // \t\tframeDuration = 1 / 256; // approximate packet audio size, fake!\n  // \t}\n  // \tif (this._codec.hasVideo) {\n  // \t\tif (this._pendingFrame) {\n  // \t\t\t// wait\n  // \t\t\treturn;\n  // \t\t} else if (!this._codec.frameReady) {\n  // \t\t\t// Haven't found a frame yet, process more data\n  // \t\t\tthis._codec.process((more) => {\n  // \t\t\t\tif (more) {\n  // \t\t\t\t\t// need more packets\n  // \t\t\t\t\tthis._pingProcessing();\n  // \t\t\t\t} else if (this._streamEnded) {\n  // \t\t\t\t\tthis._log('stream ended during linear seeking on video');\n  // \t\t\t\t\tthis._dataEnded = true;\n  // \t\t\t\t\tthis._continueSeekedPlayback();\n  // \t\t\t\t} else {\n  // \t\t\t\t\tthis._readBytesAndWait();\n  // \t\t\t\t}\n  // \t\t\t});\n  // \t\t\treturn;\n  // \t\t} else if (this._seekMode === SeekMode.FAST && this._codec.keyframeTimestamp == this._codec.frameTimestamp) {\n  // \t\t\t// Found some frames? Go ahead now!\n  // \t\t\tthis._continueSeekedPlayback();\n  // \t\t\treturn;\n  // \t\t} else if (this._codec.frameTimestamp <= this._seekTargetTime) {\n  // \t\t\t// Haven't found a time yet, or haven't reached the target time,\n  // \t\t\t// Or reached the target time and ready to decode and show.\n  // \t\t\t// Decode it in case we're at our keyframe or a following intraframe,\n  // \t\t\t// or if it's a match because we need to show it immediately.\n  // \t\t\tlet nextFrameEndTimestamp = this._codec.frameTimestamp;\n  // \t\t\tthis._pendingFrame++;\n  // \t\t\tthis._pendingFrames.push({\n  // \t\t\t\tframeEndTimestamp: nextFrameEndTimestamp\n  // \t\t\t});\n  // \t\t\tthis._decodedFrames.splice(0, this._decodedFrames.length);\n  // \t\t\tthis._codec.decodeFrame((ok) => {\n  // \t\t\t\tthis._pendingFrame--;\n  // \t\t\t\tthis._pendingFrames.shift();\n  // \t\t\t\tthis._decodedFrames.push({\n  // \t\t\t\t\tyCbCrBuffer: this._codec.frameBuffer,\n  // \t\t\t\t\tvideoCpuTime: this._codec.videoCpuTime,\n  // \t\t\t\t\tframeEndTimestamp: nextFrameEndTimestamp\n  // \t\t\t\t});\n  // \t\t\t\tthis._pingProcessing();\n  // \t\t\t});\n  // \t\t\tthis._codec.sync();\n  // \t\t\treturn;\n  // \t\t} else {\n  // \t\t\t// Reached or surpassed the target time.\n  // \t\t\tif (this._codec.hasAudio) {\n  // \t\t\t\t// Keep processing the audio track\n  // \t\t\t\t// fall through...\n  // \t\t\t} else {\n  // \t\t\t\tthis._continueSeekedPlayback();\n  // \t\t\t\treturn;\n  // \t\t\t}\n  // \t\t}\n  // \t}\n  // \tif (this._codec.hasAudio) {\n  // \t\tif (this._pendingAudio) {\n  // \t\t\t// wait\n  // \t\t\treturn;\n  // \t\t} if (!this._codec.audioReady) {\n  // \t\t\t// Haven't found an audio packet yet, process more data\n  // \t\t\tthis._codec.process((more) => {\n  // \t\t\t\tif (more) {\n  // \t\t\t\t\t// need more packets\n  // \t\t\t\t\tthis._pingProcessing();\n  // \t\t\t\t} else if (this._streamEnded) {\n  // \t\t\t\t\tthis._log('stream ended during linear seeking on audio');\n  // \t\t\t\t\tthis._dataEnded = true;\n  // \t\t\t\t\tthis._continueSeekedPlayback();\n  // \t\t\t\t} else {\n  // \t\t\t\t\tthis._readBytesAndWait();\n  // \t\t\t\t}\n  // \t\t\t});\n  // \t\t\treturn;\n  // \t\t} else if (this._codec.audioTimestamp + frameDuration < this._seekTargetTime) {\n  // \t\t\t// Haven't found a time yet, or haven't reached the target time.\n  // \t\t\t// Decode it so when we reach the target we've got consistent data.\n  // \t\t\tthis._codec.decodeAudio(() => {\n  // \t\t\t\tthis._pingProcessing();\n  // \t\t\t});\n  // \t\t\treturn;\n  // \t\t} else {\n  // \t\t\tthis._continueSeekedPlayback();\n  // \t\t\treturn;\n  // \t\t}\n  // \t}\n  // }\n\n\n  _doProcessBisectionSeek() {\n    let frameDuration, timestamp;\n\n    if (this._codec.hasVideo) {\n      timestamp = this._codec.frameTimestamp;\n      frameDuration = this._targetPerFrameTime / 1000;\n    } else if (this._codec.hasAudio) {\n      timestamp = this._codec.audioTimestamp;\n      frameDuration = 1 / 256; // approximate packet audio size, fake!\n    } else {\n      throw new Error('Invalid seek state; no audio or video track available');\n    }\n\n    if (timestamp < 0) {\n      // Haven't found a packet yet.\n      this._codec.process(more => {\n        if (more) {\n          // need more data\n          this._pingProcessing();\n        } else if (this._streamEnded) {\n          this._log('stream ended during bisection seek'); // We may have to go back further to find packets.\n\n\n          if (this._seekBisector.right()) {// wait for new data to come in\n          } else {\n            this._log('failed going back');\n\n            throw new Error('not sure what to do');\n          }\n        } else {\n          this._readBytesAndWait();\n        }\n      });\n    } else if (timestamp - frameDuration / 2 > this._bisectTargetTime) {\n      if (this._seekBisector.left()) {// wait for new data to come in\n      } else {\n        this._log('close enough (left)'); // We're having trouble finding a new packet position;\n        // likely it's an audio file with lots of small packets.\n        // Since we can't find an earlier packet, just continue here.\n\n\n        this._seekTargetTime = timestamp;\n\n        this._continueSeekedPlayback();\n      }\n    } else if (timestamp + frameDuration / 2 < this._bisectTargetTime) {\n      if (this._seekBisector.right()) {// wait for new data to come in\n      } else {\n        this._log('close enough (right)'); // We're having trouble finding a new packet position;\n        // likely it's an audio file with lots of small packets.\n        // Switch to linear mode to find the final target.\n\n\n        this._seekState = SeekState.LINEAR_TO_TARGET;\n\n        this._pingProcessing();\n      }\n    } else {\n      // Reached the bisection target!\n      if (this._seekState == SeekState.BISECT_TO_TARGET && this._codec.hasVideo && this._codec.keyframeTimestamp < this._codec.frameTimestamp) {\n        // We have to go back and find a keyframe. Sigh.\n        this._log('finding the keypoint now');\n\n        this._seekState = SeekState.BISECT_TO_KEYPOINT;\n\n        this._startBisection(this._codec.keyframeTimestamp);\n      } else {\n        this._log('straight seeking now'); // Switch to linear mode to find the final target.\n\n\n        this._seekState = SeekState.LINEAR_TO_TARGET;\n\n        this._pingProcessing();\n      }\n    }\n  }\n\n  _setupVideo() {\n    if (this._videoInfo.fps > 0) {\n      this._targetPerFrameTime = 1000 / this._videoInfo.fps;\n    } else {\n      this._targetPerFrameTime = 16.667; // recalc this later\n    }\n\n    this._canvas.width = this._videoInfo.displayWidth;\n    this._canvas.height = this._videoInfo.displayHeight;\n    OGVPlayer.styleManager.appendRule('.' + this._instanceId, {\n      width: this._videoInfo.displayWidth + 'px',\n      height: this._videoInfo.displayHeight + 'px'\n    });\n    OGVPlayer.updatePositionOnResize();\n    let canvasOptions = {};\n\n    if (this._options.webGL !== undefined) {\n      // @fixme confirm format of webGL option\n      canvasOptions.webGL = this._options.webGL;\n    }\n\n    if (!!this._options.forceWebGL) {\n      canvasOptions.webGL = 'required';\n    }\n\n    this._frameSink = _yuvCanvas.default.attach(this._canvas, canvasOptions);\n  }\n\n  _doProcessing() {\n    if (this._didSeek) {\n      this._didSeek = false;\n    }\n\n    this._nextProcessingTimer = null;\n\n    if (this._isProcessing()) {// Called async while waiting for something else to complete...\n      // let it finish, then we'll get called again to continue.\n      //return;\n      //throw new Error('REENTRANCY FAIL: doProcessing during processing');\n    }\n\n    if (this._depth > 0) {\n      throw new Error('REENTRANCY FAIL: doProcessing recursing unexpectedly');\n    }\n\n    let iters = 0;\n\n    do {\n      // console.log('suman loop processing for audio and video suman bogati');\n      this._needProcessing = false;\n      this._depth++;\n\n      this._doProcessingLoop();\n\n      this._depth--;\n\n      if (this._needProcessing && this._isProcessing()) {\n        throw new Error('REENTRANCY FAIL: waiting on input or codec but asked to keep processing');\n      }\n\n      if (++iters > 500) {\n        this._log('stuck in processing loop; breaking with timer');\n\n        this._needProcessing = 0;\n\n        this._pingProcessing(0);\n      }\n    } while (this._needProcessing);\n  }\n\n  _doProcessingLoop() {\n    // console.log('suman processing loop');\n    // console.log('suman  player state before execute ', this._state);\n    if (this._actionQueue.length) {\n      // data or user i/o to process in our serialized event stream\n      // The function should eventually bring us back here via pingProcessing(),\n      // directly or via further i/o.\n      let action = this._actionQueue.shift();\n\n      action();\n    } else if (this._state == State.INITIAL) {\n      this._doProcessInitial();\n    } else if (this._state == State.SEEKING_END) {\n      this._doProcessSeekingEnd();\n    } else if (this._state == State.LOADED) {\n      this._doProcessLoaded();\n    } else if (this._state == State.PRELOAD) {\n      this._doProcessPreload();\n    } else if (this._state == State.READY) {\n      this._doProcessReady();\n    } else if (this._state == State.SEEKING) {\n      this._doProcessSeeking();\n    } else if (this._state == State.PLAYING) {\n      this._doProcessPlay();\n    } else if (this._state == State.ERROR) {\n      this._doProcessError();\n    } else {\n      throw new Error('Unexpected OGVPlayer state ' + this._state);\n    } // SUMAN changed here\n\n\n    if (this._state == 'READY') {} // this._paused = false;\n    // console.log('suman  player state after execute ', this._state);\n\n  }\n\n  _doProcessInitial() {\n    if (this._codec.loadedMetadata) {\n      // we just fell over from headers into content; call onloadedmetadata etc\n      if (!this._codec.hasVideo && !this._codec.hasAudio) {\n        throw new Error('No audio or video found, something is wrong');\n      }\n\n      if (this._codec.hasAudio) {\n        this._audioInfo = this._codec.audioFormat;\n      }\n\n      if (this._codec.hasVideo) {\n        this._videoInfo = this._codec.videoFormat;\n\n        this._setupVideo();\n      }\n\n      if (!isNaN(this._codec.duration)) {\n        this._duration = this._codec.duration;\n      }\n\n      if (this._duration === null) {\n        // if (this._stream.seekable && this._detectedType == 'video/ogg') {\n        // \t// fixme this is ogg-specific maybe?\n        // \tthis._state = State.SEEKING_END;\n        // \tthis._lastSeenTimestamp = -1;\n        // \tthis._codec.flush(() => {\n        // \t\tthis._seekStream(Math.max(0, this._stream.length - 65536 * 2));\n        // \t});\n        // } else {\n        // \t// Stream not seekable and no x-content-duration; assuming infinite stream.\n        // \tthis._state = State.LOADED;\n        // \tthis._pingProcessing();\n        // }\n        this._state = State.LOADED;\n\n        this._pingProcessing(); // suman changes\n\n      } else {\n        // We already know the duration.\n        this._state = State.LOADED;\n\n        this._pingProcessing();\n      }\n    } else {\n      this._codec.process(more => {\n        if (more) {\n          // Keep processing headers\n          this._pingProcessing();\n        } else if (this._streamEnded) {\n          throw new Error('end of file before headers found');\n        } else {\n          // Read more data!\n          this._log('reading more cause we are out of data');\n\n          this._readBytesAndWait();\n        }\n      });\n    }\n  }\n\n  _doProcessSeekingEnd() {\n    // Look for the last item.\n    if (this._codec.frameReady) {\n      this._log('saw frame with ' + this._codec.frameTimestamp);\n\n      this._lastSeenTimestamp = Math.max(this._lastSeenTimestamp, this._codec.frameTimestamp);\n\n      this._codec.discardFrame(() => {\n        this._pingProcessing();\n      });\n    } else if (this._codec.audioReady) {\n      this._log('saw audio with ' + this._codec.audioTimestamp);\n\n      this._lastSeenTimestamp = Math.max(this._lastSeenTimestamp, this._codec.audioTimestamp);\n\n      this._codec.discardAudio(() => {\n        this._pingProcessing();\n      });\n    } else {\n      this._codec.process(more => {\n        if (more) {\n          // Keep processing headers\n          this._pingProcessing();\n        } else {\n          // Read more data!\n          if (!this._stream.eof) {\n            this._readBytesAndWait();\n          } else {\n            // We are at the end!\n            this._log('seek-duration: we are at the end: ' + this._lastSeenTimestamp);\n\n            if (this._lastSeenTimestamp > 0) {\n              this._duration = this._lastSeenTimestamp;\n            } // Ok, seek back to the beginning and resync the streams.\n\n\n            this._state = State.LOADED;\n\n            this._codec.flush(() => {\n              this._streamEnded = false;\n              this._dataEnded = false;\n\n              this._seekStream(0);\n            });\n          }\n        }\n      });\n    }\n  }\n\n  _doProcessLoaded() {\n    this._state = State.PRELOAD;\n\n    this._fireEventAsync('loadedmetadata');\n\n    this._fireEventAsync('durationchange');\n\n    if (this._codec.hasVideo) {\n      this._fireEventAsync('resize');\n    }\n\n    this._pingProcessing(0);\n  }\n\n  _doProcessPreload() {\n    if ((this._codec.frameReady || !this._codec.hasVideo) && (this._codec.audioReady || !this._codec.hasAudio)) {\n      this._state = State.READY;\n\n      this._fireEventAsync('loadeddata');\n\n      this._pingProcessing();\n    } else {\n      this._codec.process(more => {\n        if (more) {\n          this._pingProcessing();\n        } else if (this._streamEnded) {\n          // Ran out of data before data available...?\n          this._ended = true;\n        } else {\n          this._readBytesAndWait();\n        }\n      });\n    }\n  }\n\n  _doProcessReady() {\n    this._log('initial seek to ' + this._initialSeekTime);\n\n    if (this._initialSeekTime > 0) {\n      let target = this._initialSeekTime;\n      this._initialSeekTime = 0;\n\n      this._log('initial seek to ' + target);\n\n      this._doSeek(target);\n    } else if (this._paused) {\n      // Paused? stop here.\n      this._log('paused while in ready');\n    } else {\n      let finishStartPlaying = () => {\n        this._log('finishStartPlaying');\n\n        this._state = State.PLAYING;\n        this._lastFrameTimestamp = getTimestamp();\n\n        if (this._codec.hasAudio && this._audioFeeder) {\n          // Pre-queue audio before we start the clock\n          this._prebufferingAudio = true;\n        } else {\n          this._startPlayback();\n        }\n\n        this._pingProcessing(0);\n\n        this._fireEventAsync('play');\n\n        this._fireEventAsync('playing');\n      };\n\n      if (this._codec.hasAudio && !this._audioFeeder && !this._muted) {\n        this._initAudioFeeder();\n\n        this._audioFeeder.waitUntilReady(finishStartPlaying);\n      } else {\n        finishStartPlaying();\n      }\n    }\n  }\n\n  _doProcessSeeking() {\n    if (this._seekState == SeekState.NOT_SEEKING) {\n      throw new Error('seeking in invalid state (not seeking?)');\n    } else if (this._seekState == SeekState.BISECT_TO_TARGET) {\n      this._doProcessBisectionSeek();\n    } else if (this._seekState == SeekState.BISECT_TO_KEYPOINT) {\n      this._doProcessBisectionSeek();\n    } else if (this._seekState == SeekState.LINEAR_TO_TARGET) {\n      this._doProcessLinearSeeking();\n    } else {\n      throw new Error('Invalid seek state ' + this._seekState);\n    }\n  }\n\n  _doProcessPlay() {\n    // console.log('suman ====> suman processPLay 1');\n    let codec = this._codec;\n\n    if (this._paused) {\n      // ok we're done for now!\n      this._log('paused during playback; stopping loop');\n    } else {\n      if ((!codec.hasAudio || codec.audioReady || this._pendingAudio || this._dataEnded) && (!codec.hasVideo || codec.frameReady || this._pendingFrame || this._decodedFrames.length || this._dataEnded)) {\n        var audioState = null,\n            playbackPosition = 0,\n            readyForAudioDecode,\n            audioEnded = false,\n            readyForFrameDraw,\n            frameDelay = 0,\n            readyForFrameDecode,\n            // timers never fire earlier than 4ms\n        timerMinimum = 4,\n            // ok to draw a couple ms early\n        fudgeDelta = timerMinimum; // console.log('suman ======> SUMAN DO PROECSS PLAY INVOKE ');\n\n        if (codec.hasAudio && this._audioFeeder) {\n          // Drive on the audio clock!\n          // console.log('suman ======> SUMAN DO PROECSS PLAY INVOKE ======>');\n          audioState = this._audioFeeder.getPlaybackState();\n          playbackPosition = this._getPlaybackTime(audioState); // console.log('suman ====> play back position ', playbackPosition);\n\n          audioEnded = this._dataEnded && this._audioFeeder.durationBuffered == 0; // if (!this.sumanStartAudio) {\n          // \tconsole.log('audio feeder duration buffered ', this._audioFeeder.durationBuffered);\n          // }\n\n          if (this._prebufferingAudio && (this._audioFeeder.durationBuffered >= this._audioFeeder.bufferThreshold * 2 && (!codec.hasVideo || this._decodedFrames.length >= this._framePipelineDepth) || this._dataEnded)) {\n            // this.sumanStartAudio = true;\n            this._log('prebuffering audio done; buffered to ' + this._audioFeeder.durationBuffered);\n\n            this._startPlayback(playbackPosition);\n\n            this._prebufferingAudio = false;\n          }\n\n          if (audioState.dropped != this._droppedAudio) {\n            this._log('dropped ' + (audioState.dropped - this._droppedAudio));\n          }\n\n          if (audioState.delayed != this._delayedAudio) {\n            this._log('delayed ' + (audioState.delayed - this._delayedAudio));\n          }\n\n          this._droppedAudio = audioState.dropped;\n          this._delayedAudio = audioState.delayed;\n          readyForAudioDecode = this._audioFeeder.durationBuffered <= this._audioFeeder.bufferThreshold * 2;\n\n          if (!readyForAudioDecode) {// just to skip the remaining items in debug log\n          } else if (!this._codec.audioReady) {\n            // NEED MOAR BUFFERS\n            readyForAudioDecode = false;\n          } else if (this._pendingAudio >= this._audioPipelineDepth) {\n            // We'll check in when done decoding\n            this._log('audio decode disabled: ' + this._pendingAudio + ' packets in flight');\n\n            readyForAudioDecode = false;\n          }\n        } else {\n          // No audio; drive on the general clock.\n          // @fixme account for dropped frame times...\n          playbackPosition = this._getPlaybackTime(); // console.log('suman ====> play back position 2', playbackPosition);\n          // If playing muted with no audio output device,\n          // just keep up with audio in general.\n\n          readyForAudioDecode = this._codec.audioReady && this._audioEndTimestamp < playbackPosition;\n        } // console.log('suman ======> SUMAN DO PROECSS PLAY INVOKE ');\n\n\n        if (this._codec.hasVideo) {\n          //\tconsole.log('======> SUMAN DO PROECSS PLAY INVOKE =====>');\n          readyForFrameDraw = this._decodedFrames.length > 0; // if (readyForFrameDraw) {\n          // \tconsole.log('READY FOR FRAME DRAW', this._codec.frameReady);\n          // }\n\n          if (this._codec.frameReady) {// console.log('suman SUMAN FOUND VIDEO FRAME READY', this._codec.frameReady);\n          } else {// console.log('suman SUMAN FOUND VIDEO FRAME READY NOT', this._codec.frameReady);\n            }\n\n          readyForFrameDecode = this._pendingFrame + this._decodedFrames.length < this._framePipelineDepth + this._frameParallelism && this._codec.frameReady;\n\n          if (readyForFrameDecode) {// console.log('suman SUMAN FOUND VIDEO FRAME READY ACTUAL ========> ', this._codec.frameReady);\n          } else {}\n\n          if (readyForFrameDraw) {\n            frameDelay = (this._decodedFrames[0].frameEndTimestamp - playbackPosition) * 1000;\n            this._actualPerFrameTime = this._targetPerFrameTime - frameDelay; //frameDelay = Math.max(0, frameDelay);\n            //frameDelay = Math.min(frameDelay, this._targetPerFrameTime);\n          }\n\n          let audioSyncThreshold = this._targetPerFrameTime;\n\n          if (this._prebufferingAudio) {\n            if (readyForFrameDecode) {\n              this._log('decoding a frame during prebuffering');\n            }\n\n            readyForFrameDraw = false;\n          } else if (readyForFrameDraw && this._dataEnded && audioEnded) {\n            // If audio timeline reached end, make sure the last frame draws\n            this._log('audio timeline ended? ready to draw frame');\n          } else if (readyForFrameDraw && -frameDelay >= audioSyncThreshold) {\n            // late frame!\n            let skipPast = -1;\n\n            for (let i = 0; i < this._decodedFrames.length - 1; i++) {\n              if (this._decodedFrames[i].frameEndTimestamp < playbackPosition) {\n                skipPast = i - 1;\n              }\n            }\n\n            if (skipPast >= 0) {\n              while (skipPast-- >= 0) {\n                this._lateFrames++;\n\n                let frame = this._decodedFrames.shift();\n\n                this._log('skipping already-decoded late frame at ' + frame.frameEndTimestamp);\n\n                frameDelay = (frame.frameEndTimestamp - playbackPosition) * 1000;\n                this._frameEndTimestamp = frame.frameEndTimestamp;\n                this._actualPerFrameTime = this._targetPerFrameTime - frameDelay;\n                this._framesProcessed++; // pretend!\n\n                frame.dropped = true;\n\n                this._doFrameComplete(frame);\n              }\n            } // Resync at the next keyframe.\n            // @todo make this work when there's no audio stream being decoded ahead\n\n\n            let nextKeyframe = this._codec.nextKeyframeTimestamp; // When resyncing, allow time to decode a couple frames!\n\n            let videoSyncPadding = this._targetPerFrameTime / 1000 * (this._framePipelineDepth + this._pendingFrame);\n            let timeToResync = nextKeyframe - videoSyncPadding;\n\n            if (nextKeyframe >= 0 && nextKeyframe != this._codec.frameTimestamp && playbackPosition >= timeToResync) {\n              this._log('skipping late frame at ' + this._decodedFrames[0].frameEndTimestamp + ' vs ' + playbackPosition + ', expect to see keyframe at ' + nextKeyframe); // First skip any already-decoded frames\n\n\n              for (let i = 0; i < this._decodedFrames.length; i++) {\n                let frame = this._decodedFrames[i];\n                this._lateFrames++;\n                this._framesProcessed++; // pretend!\n\n                this._frameEndTimestamp = frame.frameEndTimestamp;\n                frameDelay = (frame.frameEndTimestamp - playbackPosition) * 1000;\n                this._actualPerFrameTime = this._targetPerFrameTime - frameDelay;\n                frame.dropped = true;\n\n                this._doFrameComplete(frame);\n              }\n\n              this._decodedFrames = [];\n\n              for (let i = 0; i < this._pendingFrames.length; i++) {\n                let frame = this._pendingFrames[i];\n                this._lateFrames++;\n                this._framesProcessed++; // pretend!\n\n                this._frameEndTimestamp = frame.frameEndTimestamp;\n                frameDelay = (frame.frameEndTimestamp - playbackPosition) * 1000;\n                this._actualPerFrameTime = this._targetPerFrameTime - frameDelay;\n                frame.dropped = true;\n\n                this._doFrameComplete(frame);\n              }\n\n              this._pendingFrames = [];\n              this._pendingFrame = 0; // Now discard anything up to the keyframe\n\n              while (this._codec.frameReady && this._codec.frameTimestamp < nextKeyframe) {\n                // note: this is a known synchronous operation :)\n                let frame = {\n                  frameEndTimestamp: this._codec.frameTimestamp,\n                  dropped: true\n                };\n                frameDelay = (frame.frameEndTimestamp - playbackPosition) * 1000;\n                this._actualPerFrameTime = this._targetPerFrameTime - frameDelay;\n                this._lateFrames++;\n\n                this._codec.discardFrame(() => {\n                  /*fake*/\n                });\n\n                this._framesProcessed++; // pretend!\n\n                this._doFrameComplete(frame);\n              }\n\n              if (this._isProcessing()) {// console.log('suman ====> suman processPLay 3');\n                // wait\n              } else {\n                // console.log('suman ====> suman processPLay 2');\n                this._pingProcessing();\n              }\n\n              return;\n            }\n          } else if (readyForFrameDraw && frameDelay <= fudgeDelta) {// on time! draw\n          } else {\n            // not yet\n            readyForFrameDraw = false;\n          }\n        }\n\n        if (readyForFrameDecode) {\n          this._log('play loop: ready to decode frame; thread depth: ' + this._pendingFrame + ', have buffered: ' + this._decodedFrames.length);\n\n          if (this._videoInfo.fps == 0 && this._codec.frameTimestamp - this._frameEndTimestamp > 0) {\n            // WebM doesn't encode a frame rate\n            this._targetPerFrameTime = (this._codec.frameTimestamp - this._frameEndTimestamp) * 1000;\n          }\n\n          this._totalFrameTime += this._targetPerFrameTime;\n          this._totalFrameCount++;\n          let nextFrameEndTimestamp = this._frameEndTimestamp = this._codec.frameTimestamp;\n          this._pendingFrame++;\n\n          this._pendingFrames.push({\n            frameEndTimestamp: nextFrameEndTimestamp\n          });\n\n          let currentPendingFrames = this._pendingFrames;\n          let wasAsync = false;\n\n          let frameDecodeTime = this._time(() => {\n            this._codec.decodeFrame(ok => {\n              if (currentPendingFrames !== this._pendingFrames) {\n                this._log('play loop callback after flush, discarding');\n\n                return;\n              }\n\n              this._log('play loop callback: decoded frame');\n\n              this._pendingFrame--;\n\n              this._pendingFrames.shift();\n\n              if (ok) {\n                if (!this.sumanOffset) {\n                  this._initialPlaybackPosition = nextFrameEndTimestamp;\n                  this._initialPlaybackOffset = nextFrameEndTimestamp;\n                  this.sumanOffset = true;\n                } // Save the buffer until it's time to draw\n\n\n                this._decodedFrames.push({\n                  yCbCrBuffer: this._codec.frameBuffer,\n                  videoCpuTime: this._codec.videoCpuTime,\n                  frameEndTimestamp: nextFrameEndTimestamp\n                });\n              } else {\n                // Bad packet or something.\n                this._log('Bad video packet or something');\n              }\n\n              this._codec.process(() => {\n                // console.log('suman suman media from player decode video ');\n                if (this._isProcessing()) {// wait\n                  // console.log('suman ====> suman processPLay 3');\n                } else {\n                  // console.log('suman ====> suman processPLay 2');\n                  this._pingProcessing(wasAsync ? undefined : 0);\n                }\n              });\n            });\n          });\n\n          if (this._pendingFrame) {\n            // console.log('suman ====> pending frame ', this._pendingFrame);\n            wasAsync = true;\n            this._proxyTime += frameDecodeTime; // We can process something else while that's running\n            // console.log('suman ====> suman processPLay 2');\n\n            this._pingProcessing();\n\n            if (this._dataEnded) {\n              this._codec.sync();\n            }\n          }\n        } else if (readyForAudioDecode) {\n          this._log('play loop: ready for audio; depth: ' + this._pendingAudio);\n\n          this._pendingAudio++;\n          let nextAudioEndTimestamp = this._codec.audioTimestamp;\n\n          let audioDecodeTime = this._time(() => {\n            this._codec.decodeAudio(ok => {\n              this._pendingAudio--;\n\n              this._log('play loop callback: decoded audio');\n\n              this._audioEndTimestamp = nextAudioEndTimestamp;\n\n              if (ok) {\n                let buffer = this._codec.audioBuffer;\n\n                if (buffer) {\n                  // console.log('suman suman media from player decode audio ');\n                  // Keep track of how much time we spend queueing audio as well\n                  // This is slow when using the Flash shim on IE 10/11\n                  this._bufferTime += this._time(() => {\n                    if (this._audioFeeder) {\n                      this._audioFeeder.bufferData(buffer);\n                    }\n                  });\n\n                  if (!this._codec.hasVideo) {\n                    this._framesProcessed++; // pretend!\n\n                    let frame = {\n                      frameEndTimestamp: this._audioEndTimestamp\n                    };\n\n                    this._doFrameComplete(frame);\n                  }\n                }\n              }\n\n              if (this._isProcessing()) {// wait\n                // console.log('suman ====> suman processPLay 3');\n              } else {\n                this._pingProcessing();\n              }\n            });\n          });\n\n          if (this._pendingAudio) {\n            this._proxyTime += audioDecodeTime; // We can process something else while that's running\n\n            if (this._codec.audioReady) {\n              // console.log('suman ====> suman processPLay 2');\n              this._pingProcessing();\n            } else {\n              // Trigger a demux immediately if we need it;\n              // audio processing is our mostly-idle time\n              this._doProcessPlayDemux();\n            }\n          }\n        } else if (readyForFrameDraw) {\n          this._log('play loop: ready to draw frame');\n\n          if (this._nextFrameTimer) {\n            clearTimeout(this._nextFrameTimer);\n            this._nextFrameTimer = null;\n          } // Ready to draw the decoded frame...\n\n\n          if (this._thumbnail) {\n            this.removeChild(this._thumbnail);\n            this._thumbnail = null;\n          }\n\n          let frame = this._decodedFrames.shift();\n\n          this._currentVideoCpuTime = frame.videoCpuTime;\n          this._drawingTime += this._time(() => {\n            this._drawFrame(frame.yCbCrBuffer);\n          });\n          this._framesProcessed++;\n\n          this._doFrameComplete(frame); // console.log('suman ====> suman processPLay 2');\n\n\n          this._pingProcessing();\n        } else if (this._decodedFrames.length && !this._nextFrameTimer && !this._prebufferingAudio) {\n          let targetTimer = frameDelay; // @todo consider using requestAnimationFrame\n\n          this._log('play loop: setting a timer for drawing ' + targetTimer);\n\n          this._nextFrameTimer = setTimeout(() => {\n            this._nextFrameTimer = null; // console.log('suman ====> suman processPLay 2');\n\n            this._pingProcessing();\n          }, targetTimer);\n        } else if (this._dataEnded && !(this._pendingAudio || this._pendingFrame || this._decodedFrames.length)) {\n          this._log('play loop: playback reached end of data ' + [this._pendingAudio, this._pendingFrame, this._decodedFrames.length]);\n\n          let finalDelay = 0;\n\n          if (this._codec.hasAudio && this._audioFeeder) {\n            finalDelay = this._audioFeeder.durationBuffered * 1000;\n          }\n\n          if (finalDelay > 0) {\n            this._log('play loop: ending pending ' + finalDelay + ' ms'); // console.log('suman ====> suman processPLay 2');\n\n\n            this._pingProcessing(Math.max(0, finalDelay));\n          } else {\n            this._log('play loop: ENDING NOW: playback time ' + this._getPlaybackTime() + '; frameEndTimestamp: ' + this._frameEndTimestamp);\n\n            this._stopPlayback();\n\n            this._prebufferingAudio = false;\n            this._initialPlaybackOffset = Math.max(this._audioEndTimestamp, this._frameEndTimestamp);\n            this._ended = true; // @todo implement loop behavior\n\n            this._paused = true;\n\n            this._fireEventAsync('pause');\n\n            this._fireEventAsync('ended');\n          }\n        } else if (this._prebufferingAudio && (codec.hasVideo && !codec.frameReady || codec.hasAudio && !codec.audioReady)) {\n          this._log('play loop: prebuffering demuxing'); // console.log('suman ====> suman processPLay 4 actual process');\n\n\n          this._doProcessPlayDemux();\n        } else {\n          this._log('play loop: waiting on async/timers');\n        }\n      } else {\n        // console.log('suman ====> suman processPLay 4 actual process');\n        this._log('play loop: demuxing');\n\n        this._doProcessPlayDemux();\n      }\n    }\n  }\n\n  _doProcessPlayDemuxOld() {\n    console.log('====> CHECK demux has packet or not');\n    console.log('====> suman bogati demux play demux ');\n    let wasFrameReady = this._codec.frameReady,\n        wasAudioReady = this._codec.audioReady;\n\n    this._codec.process(more => {\n      if (this._codec.frameReady && !wasFrameReady || this._codec.audioReady && !wasAudioReady) {\n        this._log('demuxer has packets');\n\n        this._pingProcessing();\n      } else if (more) {\n        // Have to process some more pages to find data.\n        this._log('demuxer processing to find more packets');\n\n        this._pingProcessing();\n      } else {\n        this._log('demuxer ran out of data');\n\n        if (!this._streamEnded) {\n          // Ran out of buffered input\n          this._log('demuxer loading more data');\n\n          this._readBytesAndWait();\n        } else {\n          // Ran out of stream!\n          this._log('demuxer reached end of data stream');\n\n          this._dataEnded = true;\n\n          this._pingProcessing();\n        }\n      }\n    });\n  }\n\n  _doProcessPlayDemux() {\n    // console.log('suman ====> CHECK demux has packet or not');\n    let wasFrameReady = this._codec.frameReady,\n        wasAudioReady = this._codec.audioReady;\n\n    this._codec.process(more => {\n      // console.log('suman  suman more ', more);\n      if (this._codec.frameReady && !wasFrameReady || this._codec.audioReady && !wasAudioReady) {\n        this._log('demuxer has packets');\n\n        this._pingProcessing();\n      } else if (more) {\n        // Have to process some more pages to find data.\n        this._log('demuxer processing to find more packets');\n\n        this._pingProcessing();\n      } else {\n        this.outofRanData = true; // console.log('suman suman out of ran data');\n        // console.log('suman congrea out of buffer 1');\n\n        this._log('demuxer ran out of data');\n\n        if (!this._streamEnded) {\n          // Ran out of buffered input\n          this._log('demuxer loading more data');\n\n          this._readBytesAndWait();\n        } else {\n          // Ran out of stream!\n          this._log('demuxer reached end of data stream');\n\n          this._dataEnded = true;\n\n          this._pingProcessing();\n        }\n      }\n    });\n  }\n\n  _doProcessError() {} // Nothing to do.\n  //// console.log(\"Reached error state. Sorry bout that.\");\n\n  /**\n   * Are we waiting on an async operation that will return later?\n   */\n\n\n  _isProcessing() {\n    return this._stream && (this._stream.buffering || this._stream.seeking) || this._codec && this._codec.processing;\n  } // _readBytesAndWait() {\n  // \tif (this._stream.buffering || this._stream.seeking) {\n  // \t\tthis._log('readBytesAndWait during i/o');\n  // \t\treturn;\n  // \t}\n  // \t// keep i/o size small to reduce CPU impact of demuxing on slow machines\n  // \t// @todo make buffer size larger when packets are larger?\n  // \tconst bufferSize = 32768;\n  // \tthis._stream.read(bufferSize).then((data) => {\n  // \t\t// if (sumanNum > 4) return;\n  // \t\t sumanNum++;\n  // \t\tthis._log('got input ' + [data.byteLength]);\n  // \t\tconsole.log('====> suman got input, suman media hello');\n  // \t\tif (data.byteLength) {\n  // \t\t\t// Save chunk to pass into the codec's buffer\n  // \t\t\tthis._actionQueue.push(() => {\n  // \t\t\t\tthis._codec.receiveInput(data, () => {\n  // \t\t\t\t\tconsole.log('got input, ping processing after input');\n  // \t\t\t\t\tthis._pingProcessing();\n  // \t\t\t\t});\n  // \t\t\t});\n  // \t\t}\n  // \t\tif (this._stream.eof) {\n  // \t\t\t// @todo record doneness in networkState\n  // \t\t\tthis._log('stream is at end!');\n  // \t\t\tthis._streamEnded = true;\n  // \t\t}\n  // \t\tif (this._isProcessing()) {\n  // \t\t\t// We're waiting on the codec already...\n  // \t\t} else {\n  // \t\t\t// Let the read/decode/draw loop know we're out!\n  // \t\t\tconsole.log('got input, ping processing after input 2');\n  // \t\t\tthis._pingProcessing();\n  // \t\t}\n  // \t}).catch((e) => {\n  // \t\tthis._onStreamError(e)\n  // \t});\n  // }\n\n\n  _readBytesAndWait() {\n    // if (this._stream.buffering || this._stream.seeking) {\n    // \tthis._log('readBytesAndWait during i/o');\n    // \treturn;\n    // }\n    // if (sumanNum > 4) return; // suman did changes\n    // if (allBuffers.length > 0) {\n    // \tconst data = allBuffers.shift();\n    const data = virtualclass.liveStream.getChunkForOgvPlayer();\n\n    if (data) {\n      sumanNum++;\n\n      this._log('got input ' + [data.byteLength]); // console.log('suman ====> suman got input, suman media hello');\n\n\n      if (data.byteLength) {\n        // Save chunk to pass into the codec's buffer\n        this._actionQueue.push(() => {\n          this._codec.receiveInput(data, () => {\n            // console.log('suman got input, ping processing after input');\n            this._pingProcessing();\n          });\n        });\n      } // if (this._stream.eof) {\n      // \t// @todo record doneness in networkState\n      // \tthis._log('stream is at end!');\n      // \tthis._streamEnded = true;\n      // }\n\n\n      if (this._isProcessing()) {// We're waiting on the codec already...\n      } else {\n        // Let the read/decode/draw loop know we're out!\n        console.log('got input, ping processing after input 2');\n\n        this._pingProcessing();\n      }\n\n      delete virtualclass.liveStream.listStream[virtualclass.liveStream.tempFile];\n      virtualclass.liveStream.currentExecuted = virtualclass.liveStream.tempFile; //\t}\n    }\n  }\n\n  _pingProcessing() {\n    let delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;\n\n    // console.log('suman got input, ping processing after input 3');\n    // console.log('suman ====> Suman depth ', this._depth);\n    if (this._stream && this._stream.waiting) {\n      // wait for this input pls\n      this._log('waiting on input');\n\n      return;\n    }\n\n    if (this._nextProcessingTimer) {\n      this._log('canceling old processing timer');\n\n      clearTimeout(this._nextProcessingTimer);\n      this._nextProcessingTimer = null;\n    }\n\n    let fudge = -1 / 256;\n\n    if (delay > fudge) {\n      //this._log('pingProcessing delay: ' + delay);\n      this._nextProcessingTimer = setTimeout(() => {\n        // run through pingProcessing again to check\n        // in case some io started asynchronously in the meantime\n        // console.log('suman loop processing for audio and video suman bogati, DELAY ', delay)\n        this._pingProcessing();\n      }, delay);\n    } else if (this._depth) {\n      //this._log('pingProcessing tail call (' + delay + ')');\n      this._needProcessing = true;\n    } else {\n      this._doProcessing();\n    }\n  }\n\n  _startProcessingVideo(firstBuffer) {\n    if (this._started || this._codec) {\n      return;\n    }\n\n    this._framesProcessed = 0;\n    this._bufferTime = 0;\n    this._drawingTime = 0;\n    this._proxyTime = 0;\n    this._started = true;\n    this._ended = false;\n    let codecOptions = {\n      // Base to the worker thread, so it can load the codec JS\n      base: this._options.base,\n      worker: this._enableWorker,\n      threading: this._enableThreading,\n      wasm: this._enableWASM,\n      simd: this._enableSIMD\n    };\n\n    if (this._detectedType) {\n      codecOptions.type = this._detectedType;\n    }\n\n    this._codec = new _OGVWrapperCodec.default(codecOptions);\n    this._lastVideoCpuTime = 0;\n    this._lastAudioCpuTime = 0;\n    this._lastDemuxerCpuTime = 0;\n    this._lastBufferTime = 0;\n    this._lastDrawingTime = 0;\n    this._lastProxyTime = 0;\n    this._lastFrameVideoCpuTime = 0;\n    this._lastFrameAudioCpuTime = 0;\n    this._lastFrameDemuxerCpuTime = 0;\n    this._lastFrameBufferTime = 0;\n    this._lastFrameProxyTime = 0;\n    this._lastFrameDrawingTime = 0;\n    this._currentVideoCpuTime = 0;\n\n    this._codec.onseek = offset => {\n      this._didSeek = true;\n\n      if (this._stream) {\n        this._seekStream(offset);\n      }\n    };\n\n    this._codec.init(() => {\n      this._codec.receiveInput(firstBuffer, () => {\n        this._readBytesAndWait();\n      });\n    });\n  }\n\n  _loadCodec(buf, callback) {\n    // @todo use the demuxer and codec interfaces directly\n    let hdr = new Uint8Array(buf);\n\n    if (hdr.length > 4 && hdr[0] == 'O'.charCodeAt(0) && hdr[1] == 'g'.charCodeAt(0) && hdr[2] == 'g'.charCodeAt(0) && hdr[3] == 'S'.charCodeAt(0)) {\n      // Ogg stream\n      this._detectedType = 'video/ogg';\n    } else if (hdr.length > 4 && hdr[0] == 0x1a && hdr[1] == 0x45 && hdr[2] == 0xdf && hdr[3] == 0xa3) {\n      // Matroska or WebM\n      this._detectedType = 'video/webm';\n    } else {\n      // @todo handle unknown file types gracefully\n      this._detectedType = 'video/ogg';\n    } // Pass that first buffer in to the demuxer!\n\n\n    callback(buf);\n  }\n\n  _prepForLoad(preload) {\n    alert('suman bogati');\n\n    this._stopVideo();\n\n    let doLoad = () => {\n      // @todo networkState == NETWORK_LOADING\n      if (this._options.stream) {\n        // Allow replacement compatible with the StreamFile interface.\n        // This interface may not be fully stable in future, but should\n        // help folks doing custom streaming until the MSE interfaces\n        // are built up.\n        this._stream = this._options.stream;\n      } else {\n        this._stream = new _streamFile.default({\n          url: this.src,\n          cacheSize: 16 * 1024 * 1024,\n          // Workaround for https://github.com/brion/ogv.js/issues/514\n          // binary string used for progressive downloads can cause\n          // data corruption when UTF-16 BOM markers appear at chunk\n          // boundaries.\n          progressive: false\n        });\n      }\n\n      this._stream.load().then(() => {\n        this._loading = false; // @todo handle failure / unrecognized type\n\n        this._currentSrc = this.src; // Fire off the read/decode/draw loop...\n\n        this._byteLength = this._stream.seekable ? this._stream.length : 0; // If we get X-Content-Duration, that's as good as an explicit hint\n\n        let durationHeader = this._stream.headers['x-content-duration'];\n\n        if (typeof durationHeader === 'string') {\n          this._duration = parseFloat(durationHeader);\n        }\n\n        this._loadCodec(buf => {\n          this._startProcessingVideo(buf);\n        });\n      }).catch(e => {\n        this._onStreamError(e);\n      });\n    }; // @todo networkState = this.NETWORK_NO_SOURCE;\n    // @todo show poster\n    // @todo set 'delay load event flag'\n\n\n    this._currentSrc = '';\n    this._loading = true;\n\n    this._actionQueue.push(() => {\n      if (preload && this.preload === 'none') {\n        // Done for now, we'll pick up if someone hits play() or load()\n        this._loading = false;\n      } else {\n        doLoad();\n      }\n    });\n\n    this._pingProcessing(0);\n  }\n  /**\n   * HTMLMediaElement load method\n   *\n   * https://www.w3.org/TR/html5/embedded-content-0.html#concept-media-load-algorithm\n   */\n\n\n  load() {\n    this._prepForLoad();\n  }\n  /**\n   * HTMLMediaElement canPlayType method\n   */\n\n\n  canPlayType(contentType) {\n    let type = new _OGVMediaType.default(contentType);\n\n    function checkTypes(supported) {\n      if (type.codecs) {\n        let knownCodecs = 0,\n            unknownCodecs = 0;\n        type.codecs.forEach(codec => {\n          if (supported.indexOf(codec) >= 0) {\n            knownCodecs++;\n          } else {\n            unknownCodecs++;\n          }\n        });\n\n        if (knownCodecs === 0) {\n          return '';\n        } else if (unknownCodecs > 0) {\n          return '';\n        } // All listed codecs are ones we know. Neat!\n\n\n        return 'probably';\n      } else {\n        return 'maybe';\n      }\n    }\n\n    if (type.minor === 'ogg' && (type.major === 'audio' || type.major === 'video' || type.major === 'application')) {\n      return checkTypes(['vorbis', 'opus', 'theora']);\n    } else if (type.minor === 'webm' && (type.major === 'audio' || type.major === 'video')) {\n      return checkTypes(['vorbis', 'opus', 'vp8', 'vp9']);\n    } else {\n      return '';\n    }\n  }\n  /**\n   * HTMLMediaElement play method\n   * @fixme return a promise\n   */\n  // play() {\n  // \tif (!this._muted && !this._options.audioContext) {\n  // \t\tOGVPlayer.initSharedAudioContext();\n  // \t}\n  // \tif (this._paused) {\n  // \t\tthis._startedPlaybackInDocument = document.body.contains(this);\n  // \t\tthis._paused = false;\n  // \t\tif (this._state == State.SEEKING) {\n  // \t\t\t// Seeking? Just make sure we know to pick up after.\n  // \t\t} else if (this._started && this._codec && this._codec.loadedMetadata) {\n  // \t\t\tif (this._ended && this._stream && this._byteLength) {\n  // \t\t\t\tthis._log('.play() starting over after end');\n  // \t\t\t\tthis._seek(0);\n  // \t\t\t} else {\n  // \t\t\t\tthis._log('.play() while already started');\n  // \t\t\t}\n  // \t\t\tthis._state = State.READY;\n  // \t\t\tif (this._isProcessing()) {\n  // \t\t\t\t// waiting on the codec already\n  // \t\t\t} else {\n  // \t\t\t\tthis._pingProcessing();\n  // \t\t\t}\n  // \t\t} else if (this._loading) {\n  // \t\t\tthis._log('.play() while loading');\n  // \t\t} else {\n  // \t\t\tthis._log('.play() before started');\n  // \t\t\t// Let playback begin when metadata loading is complete\n  // \t\t\tif (!this._stream) {\n  // \t\t\t\tthis.load();\n  // \t\t\t}\n  // \t\t}\n  // \t}\n  // \t// suman did disable\n  // \tif (this._video && this._video.paused) {\n  // \t\tthis._video.play();\n  // \t}\n  // }\n\n\n  play() {\n    if (!this._muted && !this._options.audioContext) {\n      OGVPlayer.initSharedAudioContext();\n    }\n\n    if (this._paused) {\n      this._startedPlaybackInDocument = document.body.contains(this);\n      this._paused = false;\n\n      if (this._state == State.SEEKING) {// Seeking? Just make sure we know to pick up after.\n      } else if (this._started && this._codec && this._codec.loadedMetadata) {\n        if (this._ended && this._stream && this._byteLength) {\n          this._log('.play() starting over after end');\n\n          this._seek(0);\n        } else {\n          this._log('.play() while already started');\n        }\n\n        this._state = State.READY;\n\n        if (this._isProcessing()) {// waiting on the codec already\n        } else {\n          this._pingProcessing();\n        }\n      } else if (this._loading) {\n        this._log('.play() while loading');\n      } else {\n        this._log('.play() before started'); // Let playback begin when metadata loading is complete\n\n\n        if (!this._stream) {\n          this.load();\n        }\n      }\n    } // // suman did disable\n\n\n    if (this._video && this._video.paused) {\n      this._video.play();\n    }\n  }\n  /**\n   * custom getPlaybackStats method\n   */\n\n\n  getPlaybackStats() {\n    return {\n      targetPerFrameTime: this._targetPerFrameTime,\n      framesProcessed: this._framesProcessed,\n      videoBytes: this._codec ? this._codec.videoBytes : 0,\n      audioBytes: this._codec ? this._codec.audioBytes : 0,\n      playTime: this._playTime,\n      demuxingTime: this._codec ? this._codec.demuxerCpuTime - this._lastDemuxerCpuTime : 0,\n      videoDecodingTime: this._codec ? this._codec.videoCpuTime - this._lastVideoCpuTime : 0,\n      audioDecodingTime: this._codec ? this._codec.audioCpuTime - this._lastAudioCpuTime : 0,\n      bufferTime: this._bufferTime - this._lastBufferTime,\n      drawingTime: this._drawingTime - this._lastDrawingTime,\n      proxyTime: this._proxyTime - this._lastProxyTime,\n      droppedAudio: this._droppedAudio,\n      delayedAudio: this._delayedAudio,\n      jitter: this._totalJitter / this._framesProcessed,\n      lateFrames: this._lateFrames\n    };\n  }\n\n  resetPlaybackStats() {\n    this._framesProcessed = 0;\n    this._playTime = 0;\n\n    if (this._codec) {\n      this._lastDemuxerCpuTime = this._codec.demuxerCpuTime;\n      this._lastVideoCpuTime = this._codec.videoCpuTime;\n      this._lastAudioCpuTime = this._codec.audioCpuTime;\n      this._codec.videoBytes = 0;\n      this._codec.audioBytes = 0;\n    }\n\n    this._lastBufferTime = this._bufferTime;\n    this._lastDrawingTime = this._drawingTime;\n    this._lastProxyTime = this._proxyTime;\n    this._totalJitter = 0;\n    this._totalFrameTime = 0;\n    this._totalFrameCount = 0;\n  }\n\n  getVideoFrameSink() {\n    return this._frameSink;\n  }\n\n  getCanvas() {\n    return this._canvas;\n  }\n\n  getVideo() {\n    return this._video;\n  }\n  /**\n   * HTMLMediaElement pause method\n   */\n\n\n  pause() {\n    if (!this._paused) {\n      if (this._nextProcessingTimer) {\n        clearTimeout(this._nextProcessingTimer);\n        this._nextProcessingTimer = null;\n      }\n\n      this._stopPlayback();\n\n      this._prebufferingAudio = false;\n      this._paused = true;\n\n      this._fireEvent('pause');\n    }\n  }\n  /**\n   * custom 'stop' method\n   */\n\n\n  stop() {\n    this._stopVideo();\n\n    this._paused = true;\n  }\n\n  fastSeek(seekToTime) {\n    this._seek(+seekToTime, SeekMode.FAST);\n  }\n\n}\n/**\n * Set up constants on the class and instances\n */\n\n\n(0, _extend.default)(OGVPlayer, constants);\nOGVPlayer.instanceCount = 0;\n\nfunction StyleManager() {\n  var self = this;\n  var el = document.createElement('style');\n  el.type = 'text/css';\n  el.textContent = 'ogvjs { ' + 'display: inline-block; ' + 'position: relative; ' + '-webkit-user-select: none; ' + '-webkit-tap-highlight-color: rgba(0,0,0,0); ';\n  '}';\n  document.head.appendChild(el);\n  var sheet = el.sheet;\n\n  self.appendRule = function (selector, defs) {\n    var bits = [];\n\n    for (var prop in defs) {\n      if (defs.hasOwnProperty(prop)) {\n        bits.push(prop + ':' + defs[prop]);\n      }\n    }\n\n    var rule = selector + '{' + bits.join(';') + '}';\n    sheet.insertRule(rule, sheet.cssRules.length - 1);\n  };\n}\n\nOGVPlayer.styleManager = new StyleManager(); // IE 10/11 and Edge 12 don't support object-fit.\n// Also just for fun, IE 10 doesn't support 'auto' sizing on canvas. o_O\n\nOGVPlayer.supportsObjectFit = typeof document.createElement('canvas').style.objectFit === 'string';\n\nif (OGVPlayer.supportsObjectFit && navigator.userAgent.match(/iPhone|iPad|iPod Touch/)) {\n  // Safari for iOS 8/9 supports it but positions our <canvas> incorrectly when using WebGL >:(\n  OGVPlayer.supportsObjectFit = false;\n}\n\nif (OGVPlayer.supportsObjectFit && navigator.userAgent.match(/Edge/)) {\n  // Edge 16 supports it but it doesn't actually work on <canvas>\n  OGVPlayer.supportsObjectFit = false;\n}\n\nif (OGVPlayer.supportsObjectFit) {\n  OGVPlayer.updatePositionOnResize = function () {// no-op\n  };\n} else {\n  OGVPlayer.updatePositionOnResize = function () {\n    function fixup(el, width, height) {\n      var container = el.offsetParent || el.parentNode,\n          containerAspect = container.offsetWidth / container.offsetHeight,\n          intrinsicAspect = width / height;\n\n      if (intrinsicAspect > containerAspect) {\n        var vsize = container.offsetWidth / intrinsicAspect,\n            vpad = (container.offsetHeight - vsize) / 2;\n        el.style.width = '100%';\n        el.style.height = vsize + 'px';\n        el.style.marginLeft = 0;\n        el.style.marginRight = 0;\n        el.style.marginTop = vpad + 'px';\n        el.style.marginBottom = vpad + 'px';\n      } else {\n        var hsize = container.offsetHeight * intrinsicAspect,\n            hpad = (container.offsetWidth - hsize) / 2;\n        el.style.width = hsize + 'px';\n        el.style.height = '100%';\n        el.style.marginLeft = hpad + 'px';\n        el.style.marginRight = hpad + 'px';\n        el.style.marginTop = 0;\n        el.style.marginBottom = 0;\n      }\n    }\n\n    function queryOver(selector, callback) {\n      var nodeList = document.querySelectorAll(selector),\n          nodeArray = Array.prototype.slice.call(nodeList);\n      nodeArray.forEach(callback);\n    }\n\n    queryOver('ogvjs > canvas', function (canvas) {\n      fixup(canvas, canvas.width, canvas.height);\n    });\n    queryOver('ogvjs > img', function (poster) {\n      fixup(poster, poster.naturalWidth, poster.naturalHeight);\n    });\n  };\n\n  var fullResizeVideo = function fullResizeVideo() {\n    // fullscreens may ping us before the resize happens\n    setImmediate(OGVPlayer.updatePositionOnResize);\n  };\n\n  window.addEventListener('resize', OGVPlayer.updatePositionOnResize);\n  window.addEventListener('orientationchange', OGVPlayer.updatePositionOnResize);\n  document.addEventListener('fullscreenchange', fullResizeVideo);\n  document.addEventListener('mozfullscreenchange', fullResizeVideo);\n  document.addEventListener('webkitfullscreenchange', fullResizeVideo);\n  document.addEventListener('MSFullscreenChange', fullResizeVideo);\n}\n\nvar _default = OGVPlayer;\nexports.default = _default;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate))\n\n//# sourceURL=webpack://ogvjs/./src/js/OGVPlayer.js?");

/***/ }),

/***/ "./src/js/OGVProxyClass.js":
/*!*********************************!*\
  !*** ./src/js/OGVProxyClass.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\n/* global ArrayBuffer */\n\n/**\n * Proxy object for web worker interface for codec classes.\n *\n * Used by the high-level player interface.\n *\n * @author Brion Vibber <brion@pobox.com>\n * @copyright 2015-2019 Brion Vibber\n * @license MIT-style\n */\nfunction OGVProxyClass(initialProps) {\n  return class {\n    constructor(worker, className, options) {\n      options = options || {};\n      this.worker = worker;\n\n      this.transferables = function () {\n        let buffer = new ArrayBuffer(1024),\n            bytes = new Uint8Array(buffer);\n\n        try {\n          worker.postMessage({\n            action: 'transferTest',\n            bytes: bytes\n          }, [buffer]);\n\n          if (buffer.byteLength) {\n            // No transferable support\n            return false;\n          } else {\n            return true;\n          }\n        } catch (e) {\n          return false;\n        }\n      }(); // Set up proxied properties\n\n\n      for (let propName in initialProps) {\n        if (initialProps.hasOwnProperty(propName)) {\n          this[propName] = initialProps[propName];\n        }\n      } // Current player wants to avoid async confusion.\n\n\n      this.processingQueue = 0;\n      Object.defineProperty(this, 'processing', {\n        get: function get() {\n          return this.processingQueue > 0;\n        }\n      }); // And some infrastructure!\n\n      this.messageCount = 0;\n      this.pendingCallbacks = {};\n      this.worker.addEventListener('message', event => {\n        this.handleMessage(event);\n      }); // Tell the proxy to load and initialize the appropriate class\n\n      this.proxy('construct', [className, options], () => {});\n    }\n\n    proxy(action, args, callback) {\n      let transfers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n      if (!this.worker) {\n        throw 'Tried to call \"' + action + '\" method on closed proxy object';\n      }\n\n      let callbackId = 'callback-' + ++this.messageCount + '-' + action;\n\n      if (callback) {\n        this.pendingCallbacks[callbackId] = callback;\n      }\n\n      let out = {\n        'action': action,\n        'callbackId': callbackId,\n        'args': args || []\n      };\n      this.processingQueue++;\n\n      if (this.transferables) {\n        this.worker.postMessage(out, transfers);\n      } else {\n        this.worker.postMessage(out);\n      }\n    }\n\n    terminate() {\n      if (this.worker) {\n        this.worker.terminate();\n        this.worker = null;\n        this.processingQueue = 0;\n        this.pendingCallbacks = {};\n      }\n    }\n\n    handleMessage(event) {\n      this.processingQueue--;\n\n      if (event.data.action !== 'callback') {\n        // ignore\n        return;\n      }\n\n      let data = event.data,\n          callbackId = data.callbackId,\n          args = data.args,\n          callback = this.pendingCallbacks[callbackId]; // Save any updated properties returned to us...\n\n      if (data.props) {\n        for (let propName in data.props) {\n          if (data.props.hasOwnProperty(propName)) {\n            this[propName] = data.props[propName];\n          }\n        }\n      }\n\n      if (callback) {\n        delete this.pendingCallbacks[callbackId];\n        callback.apply(this, args);\n      }\n    }\n\n  };\n}\n\nvar _default = OGVProxyClass;\nexports.default = _default;\n\n//# sourceURL=webpack://ogvjs/./src/js/OGVProxyClass.js?");

/***/ }),

/***/ "./src/js/OGVTimeRanges.js":
/*!*********************************!*\
  !*** ./src/js/OGVTimeRanges.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\n/**\n * Analogue of the TimeRanges class returned by various\n * HTMLMediaElement properties\n */\nclass OGVTimeRanges {\n  /**\n   * Pass an array of two-element arrays, each containing a start and end time.\n   */\n  constructor(ranges) {\n    this._ranges = ranges;\n    this.length = ranges.length;\n  }\n\n  start(i) {\n    if (i < 0 || i > this.length || i !== (i | 0)) {\n      throw new RangeError(\"Invalid index\");\n    }\n\n    return this._ranges[i][0];\n  }\n\n  end(i) {\n    if (i < 0 || i > this.length || i !== (i | 0)) {\n      throw new RangeError(\"Invalid index\");\n    }\n\n    return this._ranges[i][1];\n  }\n\n}\n\nvar _default = OGVTimeRanges;\nexports.default = _default;\n\n//# sourceURL=webpack://ogvjs/./src/js/OGVTimeRanges.js?");

/***/ }),

/***/ "./src/js/OGVWrapperCodec.js":
/*!***********************************!*\
  !*** ./src/js/OGVWrapperCodec.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _OGVLoaderWeb = _interopRequireDefault(__webpack_require__(/*! ./OGVLoaderWeb.js */ \"./src/js/OGVLoaderWeb.js\"));\n\n/**\n * Proxy object for web worker interface for codec classes.\n *\n * Used by the high-level player interface.\n *\n * @author Brion Vibber <brion@pobox.com>\n * @copyright 2015-2019 Brion Vibber\n * @license MIT-style\n */\nclass OGVWrapperCodec {\n  constructor(options) {\n    this.options = options || {};\n    this.demuxer = null;\n    this.videoDecoder = null;\n    this.audioDecoder = null;\n    this.flushIter = 0;\n    this.loadedMetadata = false;\n    this.processing = false;\n    Object.defineProperties(this, {\n      duration: {\n        get: function get() {\n          if (this.loadedMetadata) {\n            return this.demuxer.duration;\n          } else {\n            return NaN;\n          }\n        }\n      },\n      hasAudio: {\n        get: function get() {\n          return this.loadedMetadata && !!this.audioDecoder;\n        }\n      },\n      audioReady: {\n        get: function get() {\n          return this.hasAudio && this.demuxer.audioReady;\n        }\n      },\n      audioTimestamp: {\n        get: function get() {\n          return this.demuxer.audioTimestamp;\n        }\n      },\n      audioFormat: {\n        get: function get() {\n          if (this.hasAudio) {\n            return this.audioDecoder.audioFormat;\n          } else {\n            return null;\n          }\n        }\n      },\n      audioBuffer: {\n        get: function get() {\n          if (this.hasAudio) {\n            return this.audioDecoder.audioBuffer;\n          } else {\n            return null;\n          }\n        }\n      },\n      hasVideo: {\n        get: function get() {\n          return this.loadedMetadata && !!this.videoDecoder;\n        }\n      },\n      frameReady: {\n        get: function get() {\n          return this.hasVideo && this.demuxer.frameReady;\n        }\n      },\n      frameTimestamp: {\n        get: function get() {\n          return this.demuxer.frameTimestamp;\n        }\n      },\n      keyframeTimestamp: {\n        get: function get() {\n          return this.demuxer.keyframeTimestamp;\n        }\n      },\n      nextKeyframeTimestamp: {\n        get: function get() {\n          return this.demuxer.nextKeyframeTimestamp;\n        }\n      },\n      videoFormat: {\n        get: function get() {\n          if (this.hasVideo) {\n            return this.videoDecoder.videoFormat;\n          } else {\n            return null;\n          }\n        }\n      },\n      frameBuffer: {\n        get: function get() {\n          if (this.hasVideo) {\n            return this.videoDecoder.frameBuffer;\n          } else {\n            return null;\n          }\n        }\n      },\n      seekable: {\n        get: function get() {\n          return this.demuxer.seekable;\n        }\n      },\n      demuxerCpuTime: {\n        get: function get() {\n          if (this.demuxer) {\n            return this.demuxer.cpuTime;\n          } else {\n            return 0;\n          }\n        }\n      },\n      audioCpuTime: {\n        get: function get() {\n          if (this.audioDecoder) {\n            return this.audioDecoder.cpuTime;\n          } else {\n            return 0;\n          }\n        }\n      },\n      videoCpuTime: {\n        get: function get() {\n          if (this.videoDecoder) {\n            return this.videoDecoder.cpuTime;\n          } else {\n            return 0;\n          }\n        }\n      }\n    });\n    this.loadedDemuxerMetadata = false;\n    this.loadedAudioMetadata = false;\n    this.loadedVideoMetadata = false;\n    this.loadedAllMetadata = false;\n    this.onseek = null;\n    this.videoBytes = 0;\n    this.audioBytes = 0;\n    return this;\n  } // Wrapper for callbacks to drop them after a flush\n\n\n  flushSafe(func) {\n    let savedFlushIter = this.flushIter;\n    return arg => {\n      if (this.flushIter <= savedFlushIter) {\n        func(arg);\n      }\n    };\n  } // - public methods\n\n\n  init(callback) {\n    this.processing = true;\n    let demuxerClassName;\n\n    if (this.options.type === 'video/webm' || this.options.type === 'audio/webm') {\n      demuxerClassName = this.options.wasm ? 'OGVDemuxerWebMW' : 'OGVDemuxerWebM';\n    } else {\n      demuxerClassName = this.options.wasm ? 'OGVDemuxerOggW' : 'OGVDemuxerOgg';\n    }\n\n    _OGVLoaderWeb.default.loadClass(demuxerClassName, demuxerClass => {\n      demuxerClass().then(demuxer => {\n        this.demuxer = demuxer;\n\n        demuxer.onseek = offset => {\n          if (this.onseek) {\n            this.onseek(offset);\n          }\n        };\n\n        demuxer.init(() => {\n          this.processing = false;\n          callback();\n        });\n      });\n    });\n  }\n\n  close() {\n    if (this.demuxer) {\n      this.demuxer.close();\n      this.demuxer = null;\n    }\n\n    if (this.videoDecoder) {\n      this.videoDecoder.close();\n      this.videoDecoder = null;\n    }\n\n    if (this.audioDecoder) {\n      this.audioDecoder.close();\n      this.audioDecoder = null;\n    }\n  }\n\n  receiveInput(data, callback) {\n    this.demuxer.receiveInput(data, callback);\n  }\n\n  process(callback) {\n    if (this.processing) {\n      throw new Error('reentrancy fail on OGVWrapperCodec.process');\n    }\n\n    this.processing = true;\n\n    let finish = result => {\n      // // console.log('====> suman processing load video codec 2');\n      this.processing = false;\n      callback(result);\n    };\n\n    let doProcessData = () => {\n      this.demuxer.process(finish);\n    };\n\n    if (this.demuxer.loadedMetadata && !this.loadedDemuxerMetadata) {\n      // console.log('====> SUMAN meta data loaded init ');\n      // Demuxer just reached its metadata. Load the relevant codecs!\n      this.loadAudioCodec(() => {\n        this.loadVideoCodec(() => {\n          this.loadedDemuxerMetadata = true;\n          this.loadedAudioMetadata = !this.audioDecoder;\n          this.loadedVideoMetadata = !this.videoDecoder;\n          this.loadedAllMetadata = this.loadedAudioMetadata && this.loadedVideoMetadata;\n          finish(true);\n        });\n      });\n    } else if (this.loadedDemuxerMetadata && !this.loadedAudioMetadata) {\n      if (this.audioDecoder.loadedMetadata) {\n        this.loadedAudioMetadata = true;\n        this.loadedAllMetadata = this.loadedAudioMetadata && this.loadedVideoMetadata; // console.log('====> SUMAN meta data loaded audio ', this.loadedAudioMetadata);\n\n        finish(true);\n      } else if (this.demuxer.audioReady) {\n        this.demuxer.dequeueAudioPacket((packet, _discardPadding) => {\n          this.audioBytes += packet.byteLength;\n          this.audioDecoder.processHeader(packet, ret => {\n            finish(true);\n          });\n        });\n      } else {\n        doProcessData();\n      }\n    } else if (this.loadedAudioMetadata && !this.loadedVideoMetadata) {\n      if (this.videoDecoder.loadedMetadata) {\n        this.loadedVideoMetadata = true;\n        this.loadedAllMetadata = this.loadedAudioMetadata && this.loadedVideoMetadata; // console.log('====> SUMAN meta data loaded video ', this.loadedVideoMetadata);\n\n        finish(true);\n      } else if (this.demuxer.frameReady) {\n        this.processing = true;\n        this.demuxer.dequeueVideoPacket(packet => {\n          this.videoBytes += packet.byteLength;\n          this.videoDecoder.processHeader(packet, () => {\n            finish(true);\n          });\n        });\n      } else {\n        doProcessData();\n      }\n    } else if (this.loadedVideoMetadata && !this.loadedMetadata && this.loadedAllMetadata) {\n      // Ok we've found all the metadata there is. Enjoy.\n      this.loadedMetadata = true; // console.log('====> SUMAN meta data loaded all ', this.loadedMetadata);\n\n      finish(true);\n    } else if (this.loadedMetadata && (!this.hasAudio || this.demuxer.audioReady) && (!this.hasVideo || this.demuxer.frameReady)) {\n      // Already queued up some packets. Go read them!\n      finish(true);\n    } else {\n      // We need to process more of the data we've already received,\n      // or ask for more if we ran out!\n      doProcessData();\n    }\n  }\n\n  decodeFrame(callback) {\n    // console.log('====> suman bogati demux decode frame ');\n    let cb = this.flushSafe(callback),\n        timestamp = this.frameTimestamp,\n        keyframeTimestamp = this.keyframeTimestamp;\n    this.demuxer.dequeueVideoPacket(packet => {\n      this.videoBytes += packet.byteLength;\n      this.videoDecoder.processFrame(packet, ok => {\n        // console.log('====> suman orginal process video frame');\n        // hack\n        let fb = this.videoDecoder.frameBuffer;\n\n        if (fb) {\n          fb.timestamp = timestamp;\n          fb.keyframeTimestamp = keyframeTimestamp;\n        }\n\n        cb(ok);\n      });\n    });\n  }\n\n  decodeAudio(callback) {\n    let cb = this.flushSafe(callback);\n    this.demuxer.dequeueAudioPacket((packet, discardPadding) => {\n      this.audioBytes += packet.byteLength; // console.log('====> Suman audio byte length ' + this.audioBytes);\n\n      this.audioDecoder.processAudio(packet, ret => {\n        if (discardPadding) {\n          // discardPadding is in nanoseconds\n          // negative value trims from beginning\n          // positive value trims from end\n          let samples = this.audioDecoder.audioBuffer;\n          let trimmed = [];\n\n          for (let channel of samples) {\n            let trim = Math.round(discardPadding * this.audioFormat.rate / 1000000000);\n\n            if (trim > 0) {\n              trimmed.push(channel.subarray(0, channel.length - Math.min(trim, channel.length)));\n            } else {\n              trimmed.push(channel.subarray(Math.min(Math.abs(trim), channel.length), channel.length));\n            }\n          } // kinda hacky for now\n\n\n          this.audioDecoder.audioBuffer = trimmed;\n        }\n\n        return cb(ret);\n      });\n    });\n  }\n\n  discardFrame(callback) {\n    this.demuxer.dequeueVideoPacket(packet => {\n      this.videoBytes += packet.byteLength;\n      callback();\n    });\n  }\n\n  discardAudio(callback) {\n    this.demuxer.dequeueAudioPacket((packet, _discardPadding) => {\n      this.audioBytes += packet.byteLength;\n      callback();\n    });\n  }\n\n  flush(callback) {\n    this.flushIter++;\n    this.demuxer.flush(callback);\n  }\n\n  sync() {\n    if (this.videoDecoder) {\n      this.videoDecoder.sync();\n    }\n  }\n\n  recycleFrame(frame) {\n    if (this.videoDecoder) {\n      this.videoDecoder.recycleFrame(frame);\n    }\n  }\n\n  getKeypointOffset(timeSeconds, callback) {\n    this.demuxer.getKeypointOffset(timeSeconds, callback);\n  }\n\n  seekToKeypoint(timeSeconds, callback) {\n    this.demuxer.seekToKeypoint(timeSeconds, this.flushSafe(callback));\n  }\n\n  loadAudioCodec(callback) {\n    if (this.demuxer.audioCodec) {\n      let wasm = !!this.options.wasm;\n      let audioClassMap = {\n        vorbis: wasm ? 'OGVDecoderAudioVorbisW' : 'OGVDecoderAudioVorbis',\n        opus: wasm ? 'OGVDecoderAudioOpusW' : 'OGVDecoderAudioOpus'\n      };\n      let className = audioClassMap[this.demuxer.audioCodec];\n      this.processing = true;\n\n      _OGVLoaderWeb.default.loadClass(className, audioCodecClass => {\n        let audioOptions = {};\n\n        if (this.demuxer.audioFormat) {\n          audioOptions.audioFormat = this.demuxer.audioFormat;\n        }\n\n        audioCodecClass(audioOptions).then(decoder => {\n          this.audioDecoder = decoder;\n          decoder.init(() => {\n            this.loadedAudioMetadata = decoder.loadedMetadata;\n            this.processing = false;\n            callback();\n          });\n        });\n      }, {\n        worker: this.options.worker\n      });\n    } else {\n      callback();\n    }\n  }\n\n  loadVideoCodec(callback) {\n    if (this.demuxer.videoCodec) {\n      let wasm = !!this.options.wasm,\n          simd = !!this.options.simd,\n          threading = !!this.options.threading;\n      let videoClassMap = {\n        theora: wasm ? 'OGVDecoderVideoTheoraW' : 'OGVDecoderVideoTheora',\n        vp8: wasm ? threading ? 'OGVDecoderVideoVP8MTW' : 'OGVDecoderVideoVP8W' : 'OGVDecoderVideoVP8',\n        vp9: wasm ? threading ? simd ? 'OGVDecoderVideoVP9SIMDMTW' : 'OGVDecoderVideoVP9MTW' : simd ? 'OGVDecoderVideoVP9SIMDW' : 'OGVDecoderVideoVP9W' : 'OGVDecoderVideoVP9',\n        av1: wasm ? threading ? simd ? 'OGVDecoderVideoAV1SIMDMTW' : 'OGVDecoderVideoAV1MTW' : simd ? 'OGVDecoderVideoAV1SIMDW' : 'OGVDecoderVideoAV1W' : 'OGVDecoderVideoAV1'\n      };\n      let className = videoClassMap[this.demuxer.videoCodec];\n      this.processing = true;\n\n      _OGVLoaderWeb.default.loadClass(className, videoCodecClass => {\n        let videoOptions = {};\n\n        if (this.demuxer.videoFormat) {\n          videoOptions.videoFormat = this.demuxer.videoFormat;\n        }\n\n        if (threading) {\n          // Hack around multiple-instantiation pthreads/modularize bug\n          // in emscripten 1.38.27\n          delete window.ENVIRONMENT_IS_PTHREAD;\n        }\n\n        videoCodecClass(videoOptions).then(decoder => {\n          this.videoDecoder = decoder;\n          decoder.init(() => {\n            this.loadedVideoMetadata = decoder.loadedMetadata; // console.log('====> suman processing load video codec 1');\n\n            this.processing = false;\n            callback();\n          });\n        });\n      }, {\n        worker: this.options.worker && !this.options.threading\n      });\n    } else {\n      callback();\n    }\n  }\n\n}\n\nvar _default = OGVWrapperCodec;\nexports.default = _default;\n\n//# sourceURL=webpack://ogvjs/./src/js/OGVWrapperCodec.js?");

/***/ }),

/***/ "./src/js/WebAssemblyCheck.js":
/*!************************************!*\
  !*** ./src/js/WebAssemblyCheck.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction testSafariWebAssemblyBug() {\n  /*\n      Source of module at https://github.com/brion/min-wasm-fail\n      (module\n          (memory 1)\n          (func $test (param $loc i32) (result i32)\n              ;; Safari on iOS 11.2.5 returns 0 when asked to modify and read loc 4\n              ;; via a parameter. If using an i32.const or a local for the location,\n              ;; it works as expected.\n              get_local $loc\n              i32.const 1\n              i32.store\n              get_local $loc\n              i32.load\n          )\n          (export \"test\" (func $test))\n      )\n  */\n  let bin = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 6, 1, 96, 1, 127, 1, 127, 3, 2, 1, 0, 5, 3, 1, 0, 1, 7, 8, 1, 4, 116, 101, 115, 116, 0, 0, 10, 16, 1, 14, 0, 32, 0, 65, 1, 54, 2, 0, 32, 0, 40, 2, 0, 11]);\n  let mod = new WebAssembly.Module(bin);\n  let inst = new WebAssembly.Instance(mod, {}); // test storing to and loading from a non-zero location via a parameter.\n  // Safari on iOS 11.2.5 returns 0 unexpectedly at non-zero locations\n\n  return inst.exports.test(4) !== 0;\n}\n\nclass WebAssemblyChecker {\n  constructor() {\n    this.tested = false;\n    this.testResult = undefined;\n  }\n  /**\n   * Check if WebAssembly appears to be present and working.\n   * Tests for presence of the APIs, and runs a test for a known bug\n   * in Safari/WebKit on iOS 11.2.2-11.2.5.\n   *\n   * @return boolean do we think wasm will work on this device?\n   */\n\n\n  wasmSupported() {\n    if (!this.tested) {\n      try {\n        if (typeof WebAssembly === 'object') {\n          this.testResult = testSafariWebAssemblyBug();\n        } else {\n          this.testResult = false;\n        }\n      } catch (e) {\n        // Something else went wrong with compilation.\n        console.log('Exception while testing WebAssembly', e);\n        this.testResult = false;\n      }\n\n      this.tested = true;\n    }\n\n    return this.testResult;\n  }\n\n}\n\nlet WebAssemblyCheck = new WebAssemblyChecker();\nvar _default = WebAssemblyCheck;\nexports.default = _default;\n\n//# sourceURL=webpack://ogvjs/./src/js/WebAssemblyCheck.js?");

/***/ }),

/***/ "./src/js/extend.js":
/*!**************************!*\
  !*** ./src/js/extend.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction extend(dest, src) {\n  for (let prop in src) {\n    if (src.hasOwnProperty(prop)) {\n      dest[prop] = src[prop];\n    }\n  }\n}\n\nvar _default = extend;\nexports.default = _default;\n\n//# sourceURL=webpack://ogvjs/./src/js/extend.js?");

/***/ }),

/***/ "./src/js/ogv.js":
/*!***********************!*\
  !*** ./src/js/ogv.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"OGVCompat\", {\n  enumerable: true,\n  get: function get() {\n    return _OGVCompat.default;\n  }\n});\nObject.defineProperty(exports, \"OGVLoader\", {\n  enumerable: true,\n  get: function get() {\n    return _OGVLoaderWeb.default;\n  }\n});\nObject.defineProperty(exports, \"OGVMediaError\", {\n  enumerable: true,\n  get: function get() {\n    return _OGVMediaError.default;\n  }\n});\nObject.defineProperty(exports, \"OGVMediaType\", {\n  enumerable: true,\n  get: function get() {\n    return _OGVMediaType.default;\n  }\n});\nObject.defineProperty(exports, \"OGVPlayer\", {\n  enumerable: true,\n  get: function get() {\n    return _OGVPlayer.default;\n  }\n});\nObject.defineProperty(exports, \"OGVTimeRanges\", {\n  enumerable: true,\n  get: function get() {\n    return _OGVTimeRanges.default;\n  }\n});\nexports.OGVVersion = void 0;\n\nvar _es6Promise = _interopRequireDefault(__webpack_require__(/*! es6-promise */ \"./node_modules/es6-promise/dist/es6-promise.js\"));\n\nvar _OGVCompat = _interopRequireDefault(__webpack_require__(/*! ./OGVCompat.js */ \"./src/js/OGVCompat.js\"));\n\nvar _OGVLoaderWeb = _interopRequireDefault(__webpack_require__(/*! ./OGVLoaderWeb.js */ \"./src/js/OGVLoaderWeb.js\"));\n\nvar _OGVMediaError = _interopRequireDefault(__webpack_require__(/*! ./OGVMediaError.js */ \"./src/js/OGVMediaError.js\"));\n\nvar _OGVMediaType = _interopRequireDefault(__webpack_require__(/*! ./OGVMediaType.js */ \"./src/js/OGVMediaType.js\"));\n\nvar _OGVPlayer = _interopRequireDefault(__webpack_require__(/*! ./OGVPlayer.js */ \"./src/js/OGVPlayer.js\"));\n\nvar _OGVTimeRanges = _interopRequireDefault(__webpack_require__(/*! ./OGVTimeRanges.js */ \"./src/js/OGVTimeRanges.js\"));\n\n//\n// -- ogv.js\n// https://github.com/brion/ogv.js\n// Copyright (c) 2013-2019 Brion Vibber\n//\n_es6Promise.default.polyfill();\n\nconst OGVVersion = undefined; // Version 1.0's web-facing and test-facing interfaces\n\nexports.OGVVersion = OGVVersion;\n\nif (typeof window === 'object') {\n  window.OGVCompat = _OGVCompat.default;\n  window.OGVLoader = _OGVLoaderWeb.default;\n  window.OGVMediaError = _OGVMediaError.default; // exposed for testing, for now\n\n  window.OGVMediaType = _OGVMediaType.default;\n  window.OGVTimeRanges = _OGVTimeRanges.default; // exposed for testing, for now\n\n  window.OGVPlayer = _OGVPlayer.default;\n  window.OGVVersion = OGVVersion;\n}\n\n//# sourceURL=webpack://ogvjs/./src/js/ogv.js?");

/***/ })

/******/ });
});