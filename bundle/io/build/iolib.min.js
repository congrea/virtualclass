/*
  2014 Pinky Sharma  {@link http://vidyamantra.com}
 @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
*/
var io={cfg:{},sock:null,wsuri:null,error:null,uniquesids:null,serial:null,packetQueue:[],init:function(a,c){this.cfg=a;this.wsconnect()},wsconnect:function(){io.wsuri=this.cfg.rid;"WebSocket"in window?this.sock=new WebSocket(io.wsuri):"MozWebSocket"in window?this.sock=new MozWebSocket(io.wsuri):(console.log("Browser does not support WebSocket!"),this.error=lang.wserror);var a=this;this.sock.onopen=function(){console.log("Connected to "+a.cfg.rid);$.event.trigger({type:"connectionopen"});a.userauthenticat();
a.addclient()};this.sock.binaryType="arraybuffer";this.sock.onmessage=function(a){if(a.data instanceof ArrayBuffer)io.onRecBinary(a);else{var b=JSON.parse(a.data);b.hasOwnProperty("m")?b.m.hasOwnProperty("serial")?ioMissingPackets.checkMissing(b):b.m.hasOwnProperty("reqMissPac")?ioMissingPackets.sendMissedPackets(b):b.m.hasOwnProperty("missedpackets")?ioMissingPackets.fillExecutedStore(b):b.m.hasOwnProperty("userSerial")?ioMissingPackets.userCheckMissing(b):b.m.hasOwnProperty("userReqMissPac")?ioMissingPackets.userSendMissedPackets(b):
b.m.hasOwnProperty("userMissedpackets")?ioMissingPackets.userFillExecutedStore(b):(io.onRecSave(b,a.data),io.onRecJson(b)):(io.onRecSave(b,a.data),io.onRecJson(b))}};this.sock.onerror=function(c){a.error=c;console.log("Error:"+c);$.event.trigger({type:"error",message:c})};this.sock.onclose=function(c){console.log("Connection Closed");$.event.trigger({type:"connectionclose",message:c.reason});console.log("Connection closed (wasClean = "+c.wasClean+", code = "+c.code+", reason = '"+c.reason+"')");setTimeout(function(){virtualclass.gObj.hasOwnProperty("saveSession")||
a.wsconnect()},5E3)}},userauthenticat:function(){var a=JSON.stringify({cfun:"authenticate",arg:{authuser:this.cfg.authuser,authpass:this.cfg.authpass}});this.sock.send(a)},addclient:function(){var a=JSON.stringify({cfun:"joinroom",arg:{client:this.cfg.userid,roomname:this.cfg.room,user:this.cfg.userobj}});this.sock.send(a)},send:function(a,c,b){a={cfun:c,arg:{msg:a}};b&&(a.arg.touser=b);if(this.sock&&1==this.sock.readyState){if(0<io.packetQueue.length){for(b=0;b<io.packetQueue.length;b++)c=JSON.parse(io.packetQueue[b]),
this.realSend(c);io.packetQueue.length=0}this.realSend(a)}else console.log("SOCKET is not ready."),b=JSON.stringify(a),io.packetQueue.push(b)},realSend:function(a){if("undefined"!=typeof a.arg.touser&&(a.arg.touser=io.uniquesids[a.arg.touser],"undefined"==typeof a.arg.touser)){console.log("User is not connected."+a.arg.touser);return}a=JSON.stringify(a);this.sock.send(a)},sendBinary:function(a){this.sock&&1==this.sock.readyState&&this.sock.send(a.buffer)},onRecMessage:function(a){if(a.data instanceof
ArrayBuffer)this.onRecBinary(a);else{var c=JSON.parse(a.data);this.onRecSave(c,a.data);io.onRecJson(c,a.data)}},onRecSave:function(a,c){(!a.hasOwnProperty("userto")||a.hasOwnProperty("userto")&&a.m.hasOwnProperty("eddata"))&&ioStorage.completeStorage(c)},onRecBinary:function(a){a.data instanceof ArrayBuffer&&($.event.trigger({type:"binrec",message:a.data}),a=new Uint8Array(a.data),a=101==a[0]?new Int8Array(a):new Uint8ClampedArray(a),ioStorage.dataBinaryStore(a))},onRecJson:function(a){var c="";switch(a.type){case "joinroom":console.log("New user join room "+
a.users);var b=null;null!=io.uniquesids&&$.each(a.clientids,function(a,c){void 0==io.uniquesids[a]&&(b=a)});io.uniquesids=a.clientids;$.event.trigger({type:"member_added",message:a.users,newuser:b});break;case "broadcastToAll":case "broadcast":null!==a&&(void 0!=a.userto&&(c=a.userto),$.event.trigger({type:"newmessage",message:a.m,fromUser:a.user,toUser:c}));break;case "userleft":void 0!=a.userto&&(c=a.userto);null!=io.uniquesids&&delete io.uniquesids[a.user.userid];$.event.trigger({type:"user_logout",
fromUser:a.user,message:"offline",toUser:c});break;case "leftroom":$.event.trigger({type:"member_removed",message:a.users});break;case "Unauthenticated":$.event.trigger({type:"authentication_failed",message:"Authentication failed"});break;case "Multiple_login":$.event.trigger({type:"Multiple_login"})}},disconnect:function(){this.sock.onclose=function(){};this.sock.close();console.log("i am closing this connection")}};
